<!doctypehtml><html prefix="og: http://ogp.me/ns#"lang=en_US><meta charset=utf-8><meta content=width=device-width,initial-scale=1 name=viewport><title>Fast limited-range conversion between ints and floats | purplesyringa's blog</title><link href=../../favicon.ico?v=2 rel=icon><link href=../../all.css rel=stylesheet><link href=../../blog.css rel=stylesheet><link href=../../vendor/Temml-Local.css rel=stylesheet><link crossorigin href=https://fonts.googleapis.com/css2?family=Noto+Sans:ital,wght@0,100..900;1,100..900&family=Roboto+Mono:ital,wght@0,100..700;1,100..700&family=Roboto:ital,wght@0,400;0,700;1,400;1,700&family=Slabo+27px&display=swap rel=stylesheet><link href=../../fonts/webfont.css rel=stylesheet><link media="screen and (prefers-color-scheme: dark"href=../../vendor/atom-one-dark.min.css rel=stylesheet><link media="screen and (prefers-color-scheme: light"href=../../vendor/a11y-light.min.css rel=stylesheet><link title="Blog posts"href=../../blog/feed.rss rel=alternate type=application/rss+xml><meta content="Fast limited-range conversion between ints and floats"property=og:title><meta content=article property=og:type><meta content=https://purplesyringa.moe/blog/fast-limited-range-conversion-between-ints-and-floats/og.png property=og:image><meta content=https://purplesyringa.moe/blog/fast-limited-range-conversion-between-ints-and-floats/ property=og:url><meta content="This post is about a popular but niche technique I can never find a succinct reference for. I didn’t invent it, I just need a page I can link when giving optimization advice.
Integer ↔ float casts that utilize specialized processor instructions, i.e. those that compilers use by default, typically have worse throughput and higher latency than alternatives based on applying bit tricks to the IEEE-754 format. (Please benchmark them anyway, I’ve seen them decrease performance occasionally.) Unfortunately, these bit tricks only work over a reduced range, e.g. numbers up to 2 23 or 2 52 as opposed to the full 2 32 or 2 64 range. Still, they can be very useful in specialized tasks."property=og:description><meta content=en_US property=og:locale><meta content="purplesyringa's blog"property=og:site_name><meta content=summary_large_image name=twitter:card><meta content=https://purplesyringa.moe/blog/fast-limited-range-conversion-between-ints-and-floats/og.png name=twitter:image><script data-website-id=0da1961d-43f2-45cc-a8e2-75679eefbb69 defer src=https://zond.tei.su/script.js></script><body><header><div class=viewport-container><div class=media><a href=https://github.com/purplesyringa><img alt=GitHub src=../../images/github-mark-white.svg></a></div><h1><a href=/>purplesyringa</a></h1><nav><a href=../..>about</a><a class=current href=../../blog/>blog</a><a href=../../sink/>kitchen sink</a></nav></div></header><section><div class=viewport-container><h2>Fast limited-range conversion between ints and floats</h2><time>Jun 7, 2025</time><p>This post is about a popular but niche technique I can never find a succinct reference for. I didn’t invent it, I just need a page I can link when giving optimization advice.<p>Integer <eq><math><mo lspace=0em rspace=0em stretchy=false>↔</mo></math></eq> float casts that utilize specialized processor instructions, i.e. those that compilers use by default, typically have worse throughput and higher latency than alternatives based on applying bit tricks to the IEEE-754 format. (Please benchmark them anyway, I’ve seen them decrease performance occasionally.) Unfortunately, these bit tricks only work over a reduced range, e.g. numbers up to <eq><math><msup><mn>2</mn><mn>23</mn></msup></math></eq> or <eq><math><msup><mn>2</mn><mn>52</mn></msup></math></eq> as opposed to the full <eq><math><msup><mn>2</mn><mn>32</mn></msup></math></eq> or <eq><math><msup><mn>2</mn><mn>64</mn></msup></math></eq> range. Still, they can be very useful in specialized tasks.<p class=next-group><span aria-level=3 class=side-header role=heading><span>Snippets</span></span>All functions are vectorizable.<pre><code class=language-rust><span class=hljs-comment>/// Convert an integer in range [0; 2^23) to a float exactly.</span>
<span class=hljs-comment>///</span>
<span class=hljs-comment>/// Produces an incorrect result for integers outside the range.</span>
<span class=hljs-keyword>fn</span> <span class="hljs-title function_">u23_to_f32</span>(x: <span class=hljs-type>u32</span>) <span class=hljs-punctuation>-></span> <span class=hljs-type>f32</span> {
    <span class=hljs-keyword>let</span> <span class=hljs-variable>magic</span> = ((<span class=hljs-number>1u32</span> << <span class=hljs-number>23</span>) <span class=hljs-keyword>as</span> <span class=hljs-type>f32</span>).<span class="hljs-title function_ invoke__">to_bits</span>();
    <span class=hljs-type>f32</span>::<span class="hljs-title function_ invoke__">from_bits</span>(x ^ magic) - <span class=hljs-type>f32</span>::<span class="hljs-title function_ invoke__">from_bits</span>(magic)
}

<span class=hljs-comment>/// Convert an integer in range [0; 2^52) to a double exactly.</span>
<span class=hljs-comment>///</span>
<span class=hljs-comment>/// Produces an incorrect result for integers outside the range.</span>
<span class=hljs-keyword>fn</span> <span class="hljs-title function_">u52_to_f64</span>(x: <span class=hljs-type>u64</span>) <span class=hljs-punctuation>-></span> <span class=hljs-type>f64</span> {
    <span class=hljs-keyword>let</span> <span class=hljs-variable>magic</span> = ((<span class=hljs-number>1u64</span> << <span class=hljs-number>52</span>) <span class=hljs-keyword>as</span> <span class=hljs-type>f64</span>).<span class="hljs-title function_ invoke__">to_bits</span>();
    <span class=hljs-type>f64</span>::<span class="hljs-title function_ invoke__">from_bits</span>(x ^ magic) - <span class=hljs-type>f64</span>::<span class="hljs-title function_ invoke__">from_bits</span>(magic)
}

<span class=hljs-comment>/// Convert a float in range [-0.25; 2^23] to the nearest integer, rounding ties to even.</span>
<span class=hljs-comment>///</span>
<span class=hljs-comment>/// Produces an incorrect result for floats outside the range or `NaN`s. Rounds just like</span>
<span class=hljs-comment>/// `x.round_ties_even()`.</span>
<span class=hljs-keyword>fn</span> <span class="hljs-title function_">f32_to_u23_rounding</span>(x: <span class=hljs-type>f32</span>) <span class=hljs-punctuation>-></span> <span class=hljs-type>u32</span> {
    <span class=hljs-keyword>let</span> <span class=hljs-variable>magic</span> = (<span class=hljs-number>1u32</span> << <span class=hljs-number>23</span>) <span class=hljs-keyword>as</span> <span class=hljs-type>f32</span>;
    (x + magic).<span class="hljs-title function_ invoke__">to_bits</span>() ^ magic.<span class="hljs-title function_ invoke__">to_bits</span>()
}

<span class=hljs-comment>/// Convert a double in range [-0.25; 2^52] to the nearest integer, rounding ties to even.</span>
<span class=hljs-comment>///</span>
<span class=hljs-comment>/// Produces an incorrect result for doubles outside the range or `NaN`s. Rounds just like</span>
<span class=hljs-comment>/// `x.round_ties_even()`.</span>
<span class=hljs-keyword>fn</span> <span class="hljs-title function_">f64_to_u52_rounding</span>(x: <span class=hljs-type>f64</span>) <span class=hljs-punctuation>-></span> <span class=hljs-type>u64</span> {
    <span class=hljs-keyword>let</span> <span class=hljs-variable>magic</span> = (<span class=hljs-number>1u64</span> << <span class=hljs-number>52</span>) <span class=hljs-keyword>as</span> <span class=hljs-type>f64</span>;
    (x + magic).<span class="hljs-title function_ invoke__">to_bits</span>() ^ magic.<span class="hljs-title function_ invoke__">to_bits</span>()
}

<span class=hljs-comment>/// Convert a double in range [-0.25; 2^32 - 0.5) to the nearest integer, rounding ties to even.</span>
<span class=hljs-comment>///</span>
<span class=hljs-comment>/// Produces an incorrect result for doubles outside the range or `NaN`s. Rounds just like</span>
<span class=hljs-comment>/// `x.round_ties_even()`.</span>
<span class=hljs-keyword>fn</span> <span class="hljs-title function_">f64_to_u32_rounding</span>(x: <span class=hljs-type>f64</span>) <span class=hljs-punctuation>-></span> <span class=hljs-type>u32</span> {
    <span class=hljs-keyword>let</span> <span class=hljs-variable>magic</span> = (<span class=hljs-number>1u64</span> << <span class=hljs-number>52</span>) <span class=hljs-keyword>as</span> <span class=hljs-type>f64</span>;
    (x + magic).<span class="hljs-title function_ invoke__">to_bits</span>() <span class=hljs-keyword>as</span> <span class=hljs-type>u32</span>
}
</code></pre><p>No alternatives for flooring are explicitly provided; if you has access to AVX-512, changing the rounding of addition in the last two methods to flooring should work.<p class=next-group><span aria-level=3 class=side-header role=heading><span>How this works</span></span><code>(1u32 << 23) as f32</code> is an IEEE-754 number with the (unbiased) exponent set to <eq><math><mrow><mo>+</mo></mrow><mrow><mn>23</mn></mrow></math></eq> and a zero mantissa.<p>In <code>u23_to_f32</code>, <eq><math><mi>x</mi></math></eq> is a <eq><math><mn>23</mn></math></eq>-bit integer. <eq><math><mrow><mi>x</mi><mo>⊕︎</mo></mrow><mrow><mrow><mtext></mtext><mi>magic</mi></mrow></mrow></math></eq> is thus an IEEE-754 number with exponent <eq><math><mrow><mo>+</mo></mrow><mrow><mn>23</mn></mrow></math></eq> and mantissa <eq><math><mi>x</mi></math></eq>. It’s mathematically equal to <eq><math><mrow><msup><mn>2</mn><mn>23</mn></msup><mo>⋅</mo></mrow><mrow><mrow><mo fence=true form=prefix>(</mo><mn>1</mn><mo>+</mo><mfrac><mi>x</mi><msup><mn>2</mn><mn>23</mn></msup></mfrac><mo fence=true form=postfix>)</mo></mrow><mo>=</mo></mrow><mrow><msup><mn>2</mn><mn>23</mn></msup><mo>+</mo></mrow><mrow><mi>x</mi></mrow></math></eq>. Subtracting a floating-point value <eq><math><msup><mn>2</mn><mn>23</mn></msup></math></eq> thus produces an IEEE-754 number equal to <eq><math><mi>x</mi></math></eq>.<p>In <code>f32_to_u23</code>, <eq><math><mi>x</mi></math></eq> is usually a non-negative number with exponent <eq><math><mrow><mo><</mo></mrow><mrow><mn>23</mn></mrow></math></eq>. Adding <eq><math><msup><mn>2</mn><mn>23</mn></msup></math></eq> thus produces a number with exponent exactly <eq><math><mn>23</mn></math></eq>. Its mantissa is therefore <eq><math><mrow><mo form=prefix stretchy=false>(</mo><msup><mn>2</mn><mn>23</mn></msup><mo>+</mo><mi>x</mi><mo form=postfix stretchy=false>)</mo><mo>−</mo></mrow><mrow><msup><mn>2</mn><mn>23</mn></msup><mo>=</mo></mrow><mrow><mi>x</mi></mrow></math></eq>. XORing the number with <eq><math><mrow><mtext></mtext><mi>magic</mi></mrow></math></eq>, which has the same exponent but a zero mantissa, leaves around just the mantissa <eq><math><mi>x</mi></math></eq>. Rounding matches the rounding of <eq><math><mo lspace=0em rspace=0em>+</mo></math></eq>. It works for <eq><math><mrow><mo>−</mo></mrow><mrow><mn>0.25</mn><mo>≤</mo></mrow><mrow><mi>x</mi><mo><</mo></mrow><mrow><mn>0</mn></mrow></math></eq> because <eq><math><mo lspace=0em rspace=0em>+</mo></math></eq> rounds such sums to <eq><math><msup><mn>2</mn><mn>23</mn></msup></math></eq> exactly. It works for <eq><math><mrow><mi>x</mi><mo>=</mo></mrow><mrow><msup><mn>2</mn><mn>23</mn></msup></mrow></math></eq> because the effect of the exponent changing from <eq><math><mn>23</mn></math></eq> to <eq><math><mn>24</mn></math></eq> happens to flip the bit just before the mantissa from <eq><math><mn>0</mn></math></eq> to <eq><math><mn>1</mn></math></eq>.<p>The situation for doubles and <eq><math><mn>64</mn></math></eq>-bit integers is similar.<p><code>f64_to_u32_rounding</code> is equivalent to <code>f64_to_u52_rounding(x) as u32</code>; it’s mentioned explicitly because the bottom <eq><math><mn>32</mn></math></eq> bits of <eq><math><mrow><mtext></mtext><mi>magic</mi></mrow></math></eq> are zero, and thus the XOR can be optimized out. This trick was probably authored by <a href=https://stackoverflow.com/a/429812/5417677>deft_code</a>.<p>In cases where two different constants would make more intuitive sense, <eq><math><mrow><mtext></mtext><mi>magic</mi></mrow></math></eq> is used twice to improve code size and reduce register pressure.</div></section><footer><div class=viewport-container><h2>Made with my own bare hands (why.)</h2></div></footer><script>window.addEventListener("keydown", e => {
				if (e.key === "Enter") {
					if (e.ctrlKey) {
						window.open("https://github.com/purplesyringa/site/edit/master/blog/fast-limited-range-conversion-between-ints-and-floats/index.md", "_blank");
					} else if (
						e.target.type === "checkbox"
						&& e.target.parentNode
						&& e.target.parentNode.className === "expansible-code"
					) {
						e.target.click();
					}
				}
			});</script>