<!doctypehtml><html prefix="og: http://ogp.me/ns#"lang=en_US><meta charset=utf-8><meta content=width=device-width,initial-scale=1 name=viewport><title>Faster comparison modulo Œ±-equivalence | purplesyringa's blog</title><link href=../../favicon.ico?v=2 rel=icon><link href=../../all.css rel=stylesheet><link href=../../blog.css rel=stylesheet><link href=../../vendor/Temml-Local.css rel=stylesheet><link crossorigin href=https://fonts.googleapis.com/css2?family=Noto+Sans:ital,wght@0,100..900;1,100..900&family=Roboto+Mono:ital,wght@0,100..700;1,100..700&family=Roboto:ital,wght@0,400;0,700;1,400;1,700&family=Slabo+27px&display=swap rel=stylesheet><link href=../../fonts/webfont.css rel=stylesheet><link media="screen and (prefers-color-scheme: dark"href=../../vendor/atom-one-dark.min.css rel=stylesheet><link media="screen and (prefers-color-scheme: light"href=../../vendor/a11y-light.min.css rel=stylesheet><link title="Blog posts"href=../../blog/feed.rss rel=alternate type=application/rss+xml><meta content="Faster comparison modulo Œ±-equivalence"property=og:title><meta content=article property=og:type><meta content=https://purplesyringa.moe/blog/faster-comparison-modulo-alpha-equivalence/og.png property=og:image><meta content=https://purplesyringa.moe/blog/faster-comparison-modulo-alpha-equivalence/ property=og:url><meta content="Given a Œª -calculus expression, suppose we want to quickly find all of its Œ± -equivalent subterms, i.e. subexpressions that are syntactically identical up to renaming variables defined inside the expression.
For example, consider:
Œª a . ( Œª x . a x ) ( Œª t . ( Œª y . a y ) ( Œª b . Œª x . b x ) ) The terms Œª x . a x and Œª y . a y are Œ± -equivalent, since x can be renamed to y , and both x and y are declared within the corresponding terms. The terms Œª x . a x and Œª x . b x are not Œ± -equivalent, since a and b are distinct variables declared outside the terms.
This article describes how to:

Calculate hashes of subterms in ùí™ ( n ) time, such that hashes of Œ± -equivalent subterms are guaranteed to match, and hashes of non- Œ± -equivalent subterms don‚Äôt match with high probability.
Calculate equivalence classes in ùí™ ( n log ‚Å° n ) so that the comparison can be performed without risk of false positive."property=og:description><meta content=en_US property=og:locale><meta content="purplesyringa's blog"property=og:site_name><meta content=summary_large_image name=twitter:card><meta content=https://purplesyringa.moe/blog/faster-comparison-modulo-alpha-equivalence/og.png name=twitter:image><script data-website-id=0da1961d-43f2-45cc-a8e2-75679eefbb69 defer src=https://zond.tei.su/script.js></script><body><header><div class=viewport-container><div class=media><a href=https://github.com/purplesyringa><img alt=GitHub src=../../images/github-mark-white.svg></a></div><h1><a href=/>purplesyringa</a></h1><nav><a href=../..>about</a><a class=current href=../../blog/>blog</a><a href=../../sink/>kitchen sink</a></nav></div></header><section><div class=viewport-container><h2>Faster comparison modulo Œ±-equivalence</h2><time>November 27, 2025</time><p>This article is a technical counterpart of my previous post <a href=../finding-duplicated-code-with-tools-from-your-cs-course/>Finding duplicated code with tools from your CS course</a>. It is deliberately written in a terse manner, and I‚Äôm not going to hold your hand. Consider reading the previous post first and coming back here later.<p class=next-group><span aria-level=3 class=side-header role=heading><span>Introduction</span></span>Given a <eq><math><mi>Œª</mi></math></eq>-calculus term, suppose we want to find all of its <eq><math><mi>Œ±</mi></math></eq>-equivalent subterms. Terms <eq><math><msub><mi>t</mi><mn>1</mn></msub></math></eq> and <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq> are considered <eq><math><mi>Œ±</mi></math></eq>-equivalent (denoted as <eq><math><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq> in this article) if they are syntactically equal up to a bijection between their bound variables. For example, <eq><math><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>=</mo></mrow><mrow><mi>Œª</mi><mi>x</mi><mi>.</mi><mi>a</mi><mspace width=0.1667em></mspace><mi>x</mi></mrow></math></eq> and <eq><math><mrow><msub><mi>t</mi><mn>2</mn></msub><mo>=</mo></mrow><mrow><mi>Œª</mi><mi>y</mi><mi>.</mi><mi>a</mi><mspace width=0.1667em></mspace><mi>y</mi></mrow></math></eq> are <eq><math><mi>Œ±</mi></math></eq>-equivalent because the bijection <eq><math><mrow><mo form=prefix stretchy=false>{</mo><mi>x</mi><mo>‚Ü¶</mo><mi>y</mi><mo form=postfix stretchy=false>}</mo></mrow></math></eq> translates <eq><math><msub><mi>t</mi><mn>1</mn></msub></math></eq> to <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq>, and <eq><math><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>=</mo></mrow><mrow><mi>Œª</mi><mi>x</mi><mi>.</mi><mi>a</mi><mspace width=0.1667em></mspace><mi>x</mi></mrow></math></eq> and <eq><math><mrow><msub><mi>t</mi><mn>2</mn></msub><mo>=</mo></mrow><mrow><mi>Œª</mi><mi>x</mi><mi>.</mi><mi>b</mi><mspace width=0.1667em></mspace><mi>x</mi></mrow></math></eq> are not <eq><math><mi>Œ±</mi></math></eq>-equivalent because <eq><math><mi>a</mi></math></eq> and <eq><math><mi>b</mi></math></eq> are free in <eq><math><msub><mi>t</mi><mn>1</mn></msub></math></eq> and <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq> respectively.<p>Terms are <eq><math><mi>Œ±</mi></math></eq>-equivalent if and only if their <em>locally nameless</em> forms are syntactically equal. The locally nameless form of a term <eq><math><mi>t</mi></math></eq> represents variables free in <eq><math><mi>t</mi></math></eq> by name, and variables bound in <eq><math><mi>t</mi></math></eq> by de Bruijn index. For example, <eq><math><mrow><mi>Œª</mi><mi>x</mi><mi>.</mi><mi>a</mi><mspace width=0.1667em></mspace><mi>x</mi></mrow></math></eq> is represented as <eq><math><mrow><mi>Œª</mi><mi>.</mi><mi>a</mi><mspace width=0.1667em></mspace><mrow style="padding:0 0 0.1em 0;border-bottom:0.065em solid;"><mn>1</mn></mrow></mrow></math></eq>. While computing the locally nameless form of a single term is straightforward, efficiently computing forms of all subterms of a term is tricky, since whether a variable is free or bound depends on the term whose form is being computed.<p>This article describes:<ol><li>A linear-time algorithm for computing hashes of subterms up to <eq><math><mi>Œ±</mi></math></eq>-equivalence, i.e. hashes of their locally nameless forms. We prove a bound on the collision rate of non-<eq><math><mi>Œ±</mi></math></eq>-equivalent subterms.<li>A linear-time algorithm for validating the resulting hashes for lack of collisions. Together with 1., this produces a reliable classification algorithm with expected linear runtime.<li>An algorithm for computing <eq><math><mi>Œ±</mi></math></eq>-equivalence classes in <eq><math><mrow><mi class=mathcal>ùí™</mi><mo form=prefix stretchy=false>(</mo><mi>n</mi><mrow><mspace width=0.1667em></mspace><mi>log</mi><mo>‚Å°</mo><mspace width=0.1667em></mspace></mrow><mi>n</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> guaranteed time, as a deterministic alternative to 1.+2.</ol><p class=next-group><span aria-level=3 class=side-header role=heading><span>Prior art</span></span>Our first algorithm is an adaptation of the algorithm developed in:<blockquote><p>Krzysztof Maziarz, Tom Ellis, Alan Lawrence, Andrew Fitzgibbon, and Simon Peyton Jones. 2021. <a href=https://arxiv.org/abs/2105.02856>Hashing modulo alpha-equivalence</a>. In Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation (PLDI 2021). Association for Computing Machinery, New York, NY, USA, 960‚Äì973. <a href=https://doi.org/10.1145/3453483.3454088>https://doi.org/10.1145/3453483.3454088</a></blockquote><p>Maziarz et al.'s algorithm has <eq><math><mrow><mi class=mathcal>ùí™</mi><mo form=prefix stretchy=false>(</mo><mi>n</mi><mspace width=0.1667em></mspace><msup><mi>log</mi><mn>2</mn></msup><mo>‚Å°</mo><mspace width=0.1667em></mspace><mi>n</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> runtime, but can be straightforwardly adjusted to expected <eq><math><mrow><mi class=mathcal>ùí™</mi><mo form=prefix stretchy=false>(</mo><mi>n</mi><mrow><mspace width=0.1667em></mspace><mi>log</mi><mo>‚Å°</mo><mspace width=0.1667em></mspace></mrow><mi>n</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> time by replacing binary trees with hash tables. Crucially, this algorithm allows hashes to be computed <em>incrementally</em>. It achieves this by producing <em>e-summaries</em>, which represent the entire contents of a term up to <eq><math><mi>Œ±</mi></math></eq>-equivalence, and efficiently combining e-summaries in application terms. We believe this ‚Äúpurely functional‚Äù approach does not allow for faster algorithms, so our algorithm expects the entire expression to be provided upfront.<p>To the best of our knowledge, our algorithm for validating hashes is novel.<p>The third algorithm is an adaptation of:<blockquote><p>Lasse Blaauwbroek, Miroslav Ol≈°√°k, and Herman Geuvers. 2024. <a href=https://arxiv.org/abs/2401.02948>Hashing Modulo Context-Sensitive Œ±-Equivalence</a>. Proc. ACM Program. Lang. 8, PLDI, Article 229 (June 2024), 24 pages. <a href=https://doi.org/10.1145/3656459>https://doi.org/10.1145/3656459</a></blockquote><p>Our algorithm has the same asymptotic complexity as described in the paper, but is adjusted to non-context-sensitive <eq><math><mi>Œ±</mi></math></eq>-equivalence and simplified, which hopefully leads to easier intuitive understanding and faster practical performance.<p class=next-group><span aria-level=3 class=side-header role=heading><span>Hashing</span></span>We start with a named form, where all variables are accessed by names. This ensures that the innermost terms are already in the locally nameless form. We then compute the locally nameless forms of other terms recursively:<section><eqn><math style="display:block math;"class=tml-display display=block><mtable columnalign="right left"displaystyle=true><mtr><mtd style="padding:0.7ex 0em 0.7ex 0em;"class=tml-right><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>x</mi><mo form=postfix stretchy=false>)</mo></mrow></mtd><mtd style="padding:0.7ex 0em 0.7ex 0em;"class=tml-left><mrow><mo>=</mo><mi>x</mi></mrow></mtd></mtr><mtr><mtd style="padding:0.7ex 0em 0.7ex 0em;"class=tml-right><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><msub><mi>t</mi><mn>1</mn></msub><msub><mi>t</mi><mn>2</mn></msub><mo form=postfix stretchy=false>)</mo></mrow></mtd><mtd style="padding:0.7ex 0em 0.7ex 0em;"class=tml-left><mrow><mo>=</mo><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><msub><mi>t</mi><mn>1</mn></msub><mo form=postfix stretchy=false>)</mo><mspace width=0.1667em></mspace><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><msub><mi>t</mi><mn>2</mn></msub><mo form=postfix stretchy=false>)</mo></mrow></mtd></mtr><mtr><mtd style="padding:0.7ex 0em 0.7ex 0em;"class=tml-right><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>Œª</mi><mi>x</mi><mi>.</mi><mi>t</mi><mo form=postfix stretchy=false>)</mo></mrow></mtd><mtd style="padding:0.7ex 0em 0.7ex 0em;"class=tml-left><mrow><mo>=</mo><mi>Œª</mi><mi>.</mi><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>t</mi><mo form=postfix stretchy=false>)</mo><mo form=prefix stretchy=false>[</mo><mi>x</mi><mo lspace=0.2222em rspace=0em>:</mo><mo lspace=0em>=</mo><mrow style="padding:0 0 0.1em 0;border-bottom:0.065em solid;"><mn>0</mn></mrow><mo form=postfix stretchy=false>]</mo></mrow></mtd></mtr></mtable></math></eqn></section><p><eq><math><mrow><mo form=prefix stretchy=false>[</mo><mi>x</mi><mo lspace=0.2222em rspace=0em>:</mo><mo lspace=0em>=</mo><mrow style="padding:0 0 0.1em 0;border-bottom:0.065em solid;"><mn>0</mn></mrow><mo form=postfix stretchy=false>]</mo></mrow></math></eq> denotes that the form of <eq><math><mrow><mi>Œª</mi><mi>x</mi><mi>.</mi><mi>t</mi></mrow></math></eq> is computed from the form of <eq><math><mi>t</mi></math></eq> by replacing mentions of <eq><math><mi>x</mi></math></eq> with de Bruijn indices. This replacement is the crux of the problem: while it can be easily performed on strings, the (possibly very long) strings then need to be rehashed on each iteration, since we want to compute the hash of each term.<p>However, some string hashes, most commonly rolling hashes, allow the hash to be recomputed efficiently if part of the string is changed. Adjusting <eq><math><mrow><mtext></mtext><mi>repr</mi></mrow></math></eq> to return such a hash allows the rewrite <eq><math><mrow><mo form=prefix stretchy=false>[</mo><mi>x</mi><mo lspace=0.2222em rspace=0em>:</mo><mo lspace=0em>=</mo><mrow style="padding:0 0 0.1em 0;border-bottom:0.065em solid;"><mn>0</mn></mrow><mo form=postfix stretchy=false>]</mo></mrow></math></eq> to be performed directly on the hash. Consider in particular the polynomial hash parameterized by a constant <eq><math><mi>b</mi></math></eq>, chosen randomly, and a prime number <eq><math><mi>p</mi></math></eq>:<section><eqn><math style="display:block math;"class=tml-display display=block><mrow><mrow><mtext></mtext><mi>hash</mi></mrow><mo form=prefix stretchy=false>(</mo><msub><mi>c</mi><mn>0</mn></msub><msub><mi>c</mi><mn>1</mn></msub><mo>‚Ä¶</mo><msub><mi>c</mi><mrow><mi>n</mi><mo>‚àí</mo><mn>1</mn></mrow></msub><mo form=postfix stretchy=false>)</mo><mo>=</mo><mrow><munder><mo movablelimits=false>‚àë</mo><mi>i</mi></munder></mrow><msub><mi>c</mi><mi>i</mi></msub><msup><mi>b</mi><mi>i</mi></msup><mo></mo><mspace width=1em></mspace><mrow><mtext></mtext><mi>mod</mi></mrow><mspace width=0.1667em></mspace><mspace width=0.1667em></mspace><mi>p</mi><mi>.</mi></mrow></math></eqn></section><p>A character at index <eq><math><mi>i</mi></math></eq> can be changed from <eq><math><mi>x</mi></math></eq> to <eq><math><mi>y</mi></math></eq> by adding <eq><math><mrow><mo form=prefix stretchy=false>(</mo><mi>y</mi><mo>‚àí</mo><mi>x</mi><mo form=postfix stretchy=false>)</mo><msup><mi>b</mi><mi>i</mi></msup></mrow></math></eq> to the hash value. The hash of <eq><math><mrow><mi>Œª</mi><mi>.</mi><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>t</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> and the ‚Äúpatch‚Äù replacing each mention of <eq><math><mi>x</mi></math></eq> with a de Bruijn index can be computed separately and then merged at the abstraction, since the offset of a given variable mention within the corresponding abstraction can be calculated efficiently, and patches can be merged by adding them together.<p>An implementation of the algorithm is reproduced below:<pre><code class=language-python><div class=expansible-code><input id=expansible1 type=checkbox><div class=highlighted>range_of_expr: <span class=hljs-built_in>dict</span>[Expr, <span class=hljs-built_in>tuple</span>[<span class=hljs-built_in>int</span>, <span class=hljs-built_in>int</span>]] = {}
variable_nesting: <span class=hljs-built_in>dict</span>[VariableName, <span class=hljs-built_in>int</span>] = {}
variable_accesses: <span class=hljs-built_in>dict</span>[VariableName, <span class=hljs-built_in>list</span>[<span class=hljs-built_in>tuple</span>[<span class=hljs-built_in>int</span>, <span class=hljs-built_in>int</span>]]] = {}
current_location: <span class=hljs-built_in>int</span> = <span class=hljs-number>0</span>

<span class=hljs-keyword>def</span> <span class="hljs-title function_">collect_locations</span>(<span class=hljs-params>expr: Expr, nesting: <span class=hljs-built_in>int</span></span>):
    <span class=hljs-keyword>global</span> current_location
    start = current_location
    <span class=hljs-keyword>match</span> expr:
        <span class=hljs-keyword>case</span> Variable(x):
            <span class=hljs-comment># x</span>
            current_location += <span class=hljs-number>1</span>
            variable_accesses[x].append((start, nesting - variable_nesting[x]))
        <span class=hljs-keyword>case</span> Abstraction(x, body):
            <span class=hljs-comment># \, body</span>
            current_location += <span class=hljs-number>1</span>
            variable_nesting[x] = nesting
            variable_accesses[x] = []
            collect_locations(body, nesting + <span class=hljs-number>1</span>)
        <span class=hljs-keyword>case</span> Application(f, a):
            <span class=hljs-comment># length, f, a</span>
            current_location += <span class=hljs-number>1</span>
            collect_locations(f, nesting)
            collect_locations(a, nesting)
    end = current_location
    range_of_expr[expr] = (start, end)

collect_locations(root, <span class=hljs-number>0</span>)

powers_of_b: <span class=hljs-built_in>list</span>[<span class=hljs-built_in>int</span>] = [<span class=hljs-number>1</span>]

<span class=hljs-comment># Computes `h * b ** count % p` in amortized constant time.</span>
<span class=hljs-keyword>def</span> <span class="hljs-title function_">shift</span>(<span class=hljs-params>h: <span class=hljs-built_in>int</span>, count: <span class=hljs-built_in>int</span></span>) -> <span class=hljs-built_in>int</span>:
    <span class=hljs-keyword>while</span> <span class=hljs-built_in>len</span>(powers_of_b) <= count:
        powers_of_b.append(powers_of_b[-<span class=hljs-number>1</span>] * b % p)
    <span class=hljs-keyword>return</span> h * powers_of_b[count] % p

<span class=hljs-comment># Functions capable of hashing variable names, de Bruijn indices, lengths, and the character \</span>
<span class=hljs-comment># without collisions.</span>
<span class=hljs-keyword>def</span> <span class="hljs-title function_">hash_lambda</span>() -> <span class=hljs-built_in>int</span>: <span class=hljs-keyword>return</span> <span class=hljs-number>0</span>
<span class=hljs-keyword>def</span> <span class="hljs-title function_">hash_variable_name</span>(<span class=hljs-params>x: VariableName</span>) -> <span class=hljs-built_in>int</span>: <span class=hljs-keyword>return</span> x.int_id * <span class=hljs-number>3</span> + <span class=hljs-number>1</span>
<span class=hljs-keyword>def</span> <span class="hljs-title function_">hash_de_bruijn_index</span>(<span class=hljs-params>i: <span class=hljs-built_in>int</span></span>) -> <span class=hljs-built_in>int</span>: <span class=hljs-keyword>return</span> i * <span class=hljs-number>3</span> + <span class=hljs-number>2</span>
<span class=hljs-keyword>def</span> <span class="hljs-title function_">hash_length</span>(<span class=hljs-params>l: <span class=hljs-built_in>int</span></span>) -> <span class=hljs-built_in>int</span>: <span class=hljs-keyword>return</span> l * <span class=hljs-number>3</span> + <span class=hljs-number>3</span>

<span class=hljs-keyword>def</span> <span class="hljs-title function_">calculate_hashes</span>(<span class=hljs-params>expr: Expr</span>) -> <span class=hljs-built_in>int</span>:
    start, end = range_of_expr[expr]
    <span class=hljs-keyword>match</span> expr:
        <span class=hljs-keyword>case</span> Variable(x):
            h = hash_variable_name(x)
        <span class=hljs-keyword>case</span> Abstraction(x, body):
            h = hash_lambda() + shift(calculate_hashes(body), <span class=hljs-number>1</span>)
            <span class=hljs-keyword>for</span> location, de_bruijn_index <span class=hljs-keyword>in</span> variable_accesses[x]:
                h += shift(
                    hash_de_bruijn_index(de_bruijn_index) - hash_variable_name(x),
                    location - start,
                )
                h %= p
        <span class=hljs-keyword>case</span> Application(f, a):
            h = (
                hash_length(end - start)
                + shift(calculate_hashes(f), <span class=hljs-number>1</span>)
                + shift(calculate_hashes(a), range_of_expr[a][<span class=hljs-number>0</span>] - start)
            )
    h %= p
    <span class=hljs-built_in>print</span>(<span class=hljs-string>"The hash of"</span>, expr, <span class=hljs-string>"is"</span>, h)
    <span class=hljs-keyword>return</span> h

calculate_hashes(root)
</div><label for=expansible1>Expand</label></div></code></pre><p>The probabilistic guarantees of this scheme depend entirely on the choice of the hash. The collision probability of rolling hashes typically scales linearly with the length of the input. In this case, the length of the input exactly matches the number of subterms <eq><math><mi>n</mi></math></eq>, and each element of the input is a <eq><math><mrow><mrow><mi>log</mi><mo>‚Å°</mo><mspace width=0.1667em></mspace></mrow><mi>n</mi><mo>+</mo></mrow><mrow><mi class=mathcal>ùí™</mi><mo form=prefix stretchy=false>(</mo><mn>1</mn><mo form=postfix stretchy=false>)</mo></mrow></math></eq>-bit number (assuming binary logarithm from now on).<p>For polynomial hashes, the collision probability is <eq><math><mrow><mo>‚â§</mo></mrow><mrow><mfrac><mrow><mi>n</mi><mo>‚àí</mo><mn>1</mn></mrow><mi>p</mi></mfrac></mrow></math></eq>, assuming <eq><math><mi>b</mi></math></eq> is chosen randomly. If <eq><math><mi>b</mi></math></eq> is instead fixed and <eq><math><mi>p</mi></math></eq> is chosen randomly, the probability is <eq><math><mrow><mo>‚â§</mo></mrow><mrow><mi>C</mi><mfrac><mrow><mi>n</mi><mrow><mspace width=0.1667em></mspace><mi>log</mi><mo>‚Å°</mo><mspace width=0.1667em></mspace></mrow><mi>n</mi></mrow><mi>p</mi></mfrac></mrow></math></eq>, where <eq><math><mi>C</mi></math></eq> depends on how wide the range <eq><math><mi>p</mi></math></eq> is chosen from is. For Rabin fingerprints, the probability is <eq><math><mrow><mo>‚â≤</mo></mrow><mrow><mfrac><mrow><mi>n</mi><mrow><mspace width=0.1667em></mspace><mi>log</mi><mo>‚Å°</mo><mspace width=0.1667em></mspace></mrow><mi>n</mi></mrow><msup><mn>2</mn><mrow><mrow><mspace width=0.1667em></mspace><mi>deg</mi><mo>‚Å°</mo><mspace width=0.1667em></mspace></mrow><mi>p</mi><mo form=prefix stretchy=false>(</mo><mi>x</mi><mo form=postfix lspace=0em rspace=0em stretchy=false>)</mo></mrow></msup></mfrac></mrow></math></eq>.<p class=next-group><span aria-level=3 class=side-header role=heading><span>Verification</span></span>To verify that the computed hashes don‚Äôt produce collisions, we group terms by their hashes and validate that in each group of size <eq><math><mrow><mo>‚â•</mo></mrow><mrow><mn>2</mn></mrow></math></eq>, all terms are <eq><math><mi>Œ±</mi></math></eq>-equivalent. We first check that terms within each group have equal sizes (i.e. the number of subterms, denoted <eq><math><mrow><mo fence=true form=prefix>|</mo><mi>t</mi><mo fence=true form=postfix>|</mo></mrow></math></eq>), and then iterate over groups in order of increasing size. This ensures that while validating terms of size <eq><math><mi>n</mi></math></eq>, terms of sizes <eq><math><mrow><mi>m</mi><mo><</mo></mrow><mrow><mi>n</mi></mrow></math></eq> can be compared for <eq><math><mi>Œ±</mi></math></eq>-equivalence by hash.<p>We now introduce some terminology.<ul><li><p>We call subterms with non-unique hashes (i.e. subterms that are not alone in their groups) <em>pivots</em>.</p><li><p>We say an optimized predicate for <eq><math><mi>Œ±</mi></math></eq>-equivalence is <em>sound</em> if it implies <eq><math><mi>Œ±</mi></math></eq>-equivalence, and <em>complete</em> if it is implied by <eq><math><mi>Œ±</mi></math></eq>-equivalence.</p><li><p>For a term <eq><math><mi>t</mi></math></eq> and a subterm <eq><math><mi>u</mi></math></eq>, we define the <em>path</em> from <eq><math><mi>t</mi></math></eq> to <eq><math><mi>u</mi></math></eq> (written <eq><math><mrow><mi>t</mi><mo>‚áù</mo></mrow><mrow><mi>u</mi></mrow></math></eq>) as a (possibly empty) string of characters <eq><math><mo lspace=0em rspace=0em stretchy=false>‚Üì</mo></math></eq>, <eq><math><mo lspace=0em rspace=0em stretchy=false>‚Üô</mo></math></eq>, <eq><math><mo lspace=0em rspace=0em stretchy=false>‚Üò</mo></math></eq>, where <eq><math><mo lspace=0em rspace=0em stretchy=false>‚Üì</mo></math></eq> means ‚Äúproceed into the body of the abstraction‚Äù and <eq><math><mo lspace=0em rspace=0em stretchy=false>‚Üô</mo></math></eq>/<eq><math><mo lspace=0em rspace=0em stretchy=false>‚Üò</mo></math></eq> mean ‚Äúproceed into the function/argument of the application‚Äù respectively. For fixed <eq><math><mi>t</mi></math></eq>, valid paths map bijectively to subterms of <eq><math><mi>t</mi></math></eq>.</p><li><p>For a term <eq><math><mi>t</mi></math></eq> and a subterm <eq><math><mi>u</mi></math></eq>, we denote by <eq><math><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>u</mi><mi>/</mi><mi>t</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> a representation of <eq><math><mi>u</mi></math></eq> that encodes variable mentions as follows:</p> <ul><li>Variables bound in <eq><math><mi>u</mi></math></eq> use de Bruijn indices.<li>Variables free in <eq><math><mi>t</mi></math></eq> use names.<li>Variables bound in <eq><math><mi>t</mi></math></eq> but free in <eq><math><mi>u</mi></math></eq> use paths from <eq><math><mi>t</mi></math></eq> to the declaring abstraction.</ul> <p>Note that <eq><math><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>t</mi><mi>/</mi><mi>t</mi><mo form=postfix stretchy=false>)</mo><mo>=</mo></mrow><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>t</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq>. The act of writing <eq><math><mrow><mi>u</mi><mi>/</mi><mi>t</mi></mrow></math></eq> implicitly states that <eq><math><mi>u</mi></math></eq> is a subterm of <eq><math><mi>t</mi></math></eq> akin to <eq><math><mfrac><mi>x</mi><mi>y</mi></mfrac></math></eq> implying <eq><math><mrow><mi>y</mi><mo>‚â†</mo></mrow><mrow><mn>0</mn></mrow></math></eq> in arithmetic.</p><li><p>We write <eq><math><mrow><msub><mi>e</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>e</mi><mn>2</mn></msub></mrow></math></eq>, where each <eq><math><msub><mi>e</mi><mi>i</mi></msub></math></eq> is either <eq><math><msub><mi>u</mi><mi>i</mi></msub></math></eq> or <eq><math><mrow><msub><mi>u</mi><mi>i</mi></msub><mi>/</mi><msub><mi>t</mi><mi>i</mi></msub></mrow></math></eq> independently, if <eq><math><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><msub><mi>e</mi><mn>1</mn></msub><mo form=postfix stretchy=false>)</mo><mo>=</mo></mrow><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><msub><mi>e</mi><mn>2</mn></msub><mo form=postfix stretchy=false>)</mo></mrow></math></eq>. For example, <eq><math><mrow><mi>x</mi><mi>/</mi><mi>Œª</mi><mi>x</mi><mi>.</mi><mi>x</mi><mo>‚àº</mo></mrow><mrow><mi>y</mi><mi>/</mi><mi>Œª</mi><mi>y</mi><mi>.</mi><mi>y</mi></mrow></math></eq> even though <eq><math><mrow><mi>x</mi><mo>‚àºÃ∏</mo></mrow><mrow><mi>y</mi></mrow></math></eq>.</p></ul><p>We rely on the following propositions:<ol><li><p>If <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub></mrow></math></eq> and <eq><math><mrow><mrow><mo fence=true form=prefix>|</mo><msub><mi>t</mi><mn>1</mn></msub><mo fence=true form=postfix>|</mo></mrow><mo>=</mo></mrow><mrow><mrow><mo fence=true form=prefix>|</mo><msub><mi>t</mi><mn>2</mn></msub><mo fence=true form=postfix>|</mo></mrow></mrow></math></eq> are distinct terms, then <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub><mi>/</mi><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq>. Indeed, <eq><math><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><msub><mi>u</mi><mn>1</mn></msub><mo form=postfix stretchy=false>)</mo></mrow></math></eq> differs from <eq><math><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><msub><mi>u</mi><mn>1</mn></msub><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub><mo form=postfix stretchy=false>)</mo></mrow></math></eq> at mentions of variables that are free in <eq><math><msub><mi>u</mi><mn>1</mn></msub></math></eq> but bound in <eq><math><msub><mi>t</mi><mn>1</mn></msub></math></eq>. But since <eq><math><msub><mi>t</mi><mn>1</mn></msub></math></eq> and <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq> have the same size, they don‚Äôt share subterms, so <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub></mrow></math></eq> implies <eq><math><msub><mi>u</mi><mn>1</mn></msub></math></eq> doesn‚Äôt mention any variables bound in <eq><math><msub><mi>t</mi><mn>1</mn></msub></math></eq> but not <eq><math><msub><mi>u</mi><mn>1</mn></msub></math></eq>. Hence <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub><mi>/</mi><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq>.</p><li><p>If <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub><mi>/</mi><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq> and there is a <eq><math><mrow><msubsup><mi>u</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>1</mn></msub></mrow></math></eq> that isn‚Äôt a subterm of <eq><math><msub><mi>t</mi><mn>1</mn></msub></math></eq>, then <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub></mrow></math></eq>. Indeed, <eq><math><msubsup><mi>u</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq> cannot mention variables declared within <eq><math><msub><mi>t</mi><mn>1</mn></msub></math></eq>, so <eq><math><msub><mi>u</mi><mn>1</mn></msub></math></eq> can also only mention free variables declared outside <eq><math><msub><mi>t</mi><mn>1</mn></msub></math></eq>, hence <eq><math><msub><mi>u</mi><mn>2</mn></msub></math></eq> can also only mention free variables declared outside <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq>; thus <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>1</mn></msub><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub><mi>/</mi><msub><mi>t</mi><mn>2</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub></mrow></math></eq>.</p><li><p>If <eq><math><mrow><mi>u</mi><mo>‚àº</mo></mrow><mrow><msup><mi>u</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></mrow></math></eq>, then <eq><math><mrow><mi>u</mi><mi>/</mi><mi>t</mi><mo>‚àº</mo></mrow><mrow><msup><mi>u</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup><mi>/</mi><mi>t</mi></mrow></math></eq>. Indeed, <eq><math><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>u</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> differs from <eq><math><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>u</mi><mi>/</mi><mi>t</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> at variables that are free in <eq><math><mi>u</mi></math></eq>, but bound in <eq><math><mi>t</mi></math></eq>. Such variables are accessed by name in <eq><math><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>u</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq>, so by <eq><math><mrow><mi>u</mi><mo>‚àº</mo></mrow><mrow><msup><mi>u</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></mrow></math></eq> they must be accessed by the same name in <eq><math><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><msup><mi>u</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup><mo form=postfix stretchy=false>)</mo></mrow></math></eq> and correspond to the same declaring abstraction <eq><math><mi>a</mi></math></eq>. Since the same <eq><math><mi>t</mi></math></eq> is used in <eq><math><mrow><mi>u</mi><mi>/</mi><mi>t</mi></mrow></math></eq> and <eq><math><mrow><msup><mi>u</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup><mi>/</mi><mi>t</mi></mrow></math></eq>, the same path <eq><math><mrow><mi>t</mi><mo>‚áù</mo></mrow><mrow><mi>a</mi></mrow></math></eq> will be used in both <eq><math><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>u</mi><mi>/</mi><mi>t</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> and <eq><math><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><msup><mi>u</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup><mi>/</mi><mi>t</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq>.</p><li><p>If <eq><math><mrow><mi>u</mi><mi>/</mi><mi>t</mi><mo>‚àº</mo></mrow><mrow><msup><mi>u</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup><mi>/</mi><mi>t</mi></mrow></math></eq>, then <eq><math><mrow><mi>u</mi><mo>‚àº</mo></mrow><mrow><msup><mi>u</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></mrow></math></eq>. Indeed, <eq><math><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>u</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> differs from <eq><math><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>u</mi><mi>/</mi><mi>t</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> at variables that are free in <eq><math><mi>u</mi></math></eq>, but bound in <eq><math><mi>t</mi></math></eq>. Since such variables are accessed by path in <eq><math><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>u</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq>, by <eq><math><mrow><mi>u</mi><mo>‚àº</mo></mrow><mrow><msup><mi>u</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></mrow></math></eq> they must be accessed by the same path in <eq><math><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><msup><mi>u</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup><mo form=postfix stretchy=false>)</mo></mrow></math></eq>. Since the same <eq><math><mi>t</mi></math></eq> is used in <eq><math><mrow><mi>u</mi><mi>/</mi><mi>t</mi></mrow></math></eq> and <eq><math><mrow><msup><mi>u</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup><mi>/</mi><mi>t</mi></mrow></math></eq>, this path denotes the same abstraction <eq><math><mi>a</mi></math></eq> in both cases, and so <eq><math><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>u</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> and <eq><math><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><msup><mi>u</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup><mo form=postfix stretchy=false>)</mo></mrow></math></eq> will include the same name (namely, the name of <eq><math><mi>a</mi></math></eq>).</p><li><p>If <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub><mi>/</mi><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq>, <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msubsup><mi>u</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></mrow></math></eq>, and <eq><math><mrow><msub><mi>u</mi><mn>2</mn></msub><mo>‚àº</mo></mrow><mrow><msubsup><mi>u</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></mrow></math></eq>, then <eq><math><mrow><msubsup><mi>u</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msubsup><mi>u</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mi>/</mi><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq>. Indeed, by proposition 3 we have <eq><math><mrow><msubsup><mi>u</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>1</mn></msub><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub></mrow></math></eq> and <eq><math><mrow><msub><mi>u</mi><mn>2</mn></msub><mi>/</mi><msub><mi>t</mi><mn>2</mn></msub><mo>‚àº</mo></mrow><mrow><msubsup><mi>u</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mi>/</mi><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq>, from which the statement follows by transitivity.</p><li><p>If <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub><mi>/</mi><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq>, <eq><math><mrow><msubsup><mi>u</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msubsup><mi>u</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mi>/</mi><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq>, and <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msubsup><mi>u</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></mrow></math></eq>, then <eq><math><mrow><msub><mi>u</mi><mn>2</mn></msub><mo>‚àº</mo></mrow><mrow><msubsup><mi>u</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></mrow></math></eq>. Indeed, by proposition 3 we have <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msubsup><mi>u</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub></mrow></math></eq>, thus <eq><math><mrow><msub><mi>u</mi><mn>2</mn></msub><mi>/</mi><msub><mi>t</mi><mn>2</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>1</mn></msub><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msubsup><mi>u</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msubsup><mi>u</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mi>/</mi><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq>, from which by proposition 4 <eq><math><mrow><msub><mi>u</mi><mn>2</mn></msub><mo>‚àº</mo></mrow><mrow><msubsup><mi>u</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></mrow></math></eq>.</p><li><p>If <eq><math><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq> and <eq><math><mrow><mo form=prefix stretchy=false>(</mo><msub><mi>t</mi><mn>1</mn></msub><mo>‚áù</mo><msub><mi>u</mi><mn>1</mn></msub><mo form=postfix stretchy=false>)</mo><mo>=</mo></mrow><mrow><mo form=prefix stretchy=false>(</mo><msub><mi>t</mi><mn>2</mn></msub><mo>‚áù</mo><msub><mi>u</mi><mn>2</mn></msub><mo form=postfix stretchy=false>)</mo></mrow></math></eq>, then <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub><mi>/</mi><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq>. Indeed, <eq><math><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><msub><mi>u</mi><mn>1</mn></msub><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub><mo form=postfix stretchy=false>)</mo></mrow></math></eq> and <eq><math><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><msub><mi>u</mi><mn>2</mn></msub><mi>/</mi><msub><mi>t</mi><mn>2</mn></msub><mo form=postfix stretchy=false>)</mo></mrow></math></eq> are identical substrings of the string <eq><math><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><msub><mi>t</mi><mn>1</mn></msub><mo form=postfix stretchy=false>)</mo><mo>=</mo></mrow><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><msub><mi>t</mi><mn>2</mn></msub><mo form=postfix stretchy=false>)</mo></mrow></math></eq>.</p><li><p>If <eq><math><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq> and <eq><math><msub><mi>u</mi><mn>1</mn></msub></math></eq> is a subterm of <eq><math><msub><mi>t</mi><mn>1</mn></msub></math></eq>, there exists a subterm <eq><math><msub><mi>u</mi><mn>2</mn></msub></math></eq> of <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq> such that <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub><mi>/</mi><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq>. Indeed, by <eq><math><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq> the terms <eq><math><msub><mi>t</mi><mn>1</mn></msub></math></eq> and <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq> have identical tree structure, so the path <eq><math><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>‚áù</mo></mrow><mrow><msub><mi>u</mi><mn>1</mn></msub></mrow></math></eq> is valid in both <eq><math><msub><mi>t</mi><mn>1</mn></msub></math></eq> and <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq>. Rerooting it at <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq>, we obtain an identical path <eq><math><mrow><msub><mi>t</mi><mn>2</mn></msub><mo>‚áù</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub></mrow></math></eq>, and by proposition 7 <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub><mi>/</mi><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq>.</p><li><p>If a path <eq><math><mrow><mi>t</mi><mo>‚áù</mo></mrow><mrow><mi>p</mi></mrow></math></eq> does not contain any pivots except <eq><math><mi>t</mi></math></eq> and <eq><math><mi>p</mi></math></eq>, <eq><math><mrow><msup><mi>p</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup><mo>‚àº</mo></mrow><mrow><mi>p</mi></mrow></math></eq> is a distinct term from <eq><math><mi>p</mi></math></eq>, and a path <eq><math><mrow><mi>t</mi><mo>‚áù</mo></mrow><mrow><mi>u</mi><mo>‚áù</mo></mrow><mrow><msup><mi>p</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></mrow></math></eq> exists, where <eq><math><mi>u</mi></math></eq> is a pivot, then <eq><math><mi>p</mi></math></eq> is not a subterm of <eq><math><mi>u</mi></math></eq>. Indeed, <eq><math><mi>p</mi></math></eq> cannot be a strict subterm of <eq><math><mi>u</mi></math></eq> because <eq><math><mrow><mi>t</mi><mo>‚áù</mo></mrow><mrow><mi>p</mi></mrow></math></eq> would contain another pivot <eq><math><mi>u</mi></math></eq>. <eq><math><mrow><mi>p</mi><mo>=</mo></mrow><mrow><mi>u</mi></mrow></math></eq> is also impossible, since <eq><math><mrow><msup><mi>p</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup><mo>‚àº</mo></mrow><mrow><mi>p</mi></mrow></math></eq> would have to be a strict subterm of <eq><math><mi>p</mi></math></eq> due to <eq><math><mrow><mi>p</mi><mo>‚â†</mo></mrow><mrow><msup><mi>p</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></mrow></math></eq>, but a term can never be <eq><math><mi>Œ±</mi></math></eq>-equivalent to its strict subterm.</p></ol><p>To verify <eq><math><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq>, where <eq><math><msub><mi>t</mi><mn>1</mn></msub></math></eq> and <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq> are from the same group, we set <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mo>=</mo></mrow><mrow><msub><mi>t</mi><mn>1</mn></msub><mo separator=true>,</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub><mo>=</mo></mrow><mrow><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq> and assert <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub><mi>/</mi><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq> recursively. At each step, we repeatedly verify that <eq><math><msub><mi>u</mi><mn>1</mn></msub></math></eq> and <eq><math><msub><mi>u</mi><mn>2</mn></msub></math></eq> are subterms of the same ‚Äúkind‚Äù (variable/abstraction/application) and recurse, adjusting <eq><math><msub><mi>u</mi><mn>1</mn></msub></math></eq> and <eq><math><msub><mi>u</mi><mn>2</mn></msub></math></eq> accordingly. We apply two optimizations to ensure the time complexity is subquadratic. For every step except the first, if <eq><math><msub><mi>u</mi><mn>2</mn></msub></math></eq> is a pivot:<ul><li><p>If <eq><math><msub><mi>u</mi><mn>2</mn></msub></math></eq> has an <eq><math><mi>Œ±</mi></math></eq>-equivalent copy outside <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq>, we immediately assert <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub></mrow></math></eq> by hash and don‚Äôt recurse into <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub><mi>/</mi><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq>. This is sound by proposition 1 and complete by proposition 2.</p><li><p>Otherwise, we look for copies of <eq><math><msub><mi>u</mi><mn>2</mn></msub></math></eq> within <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq> (there must be at least one more copy). If this is the first copy we‚Äôve seen during the current comparison, we recurse into <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub><mi>/</mi><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq> and record the mapping <eq><math><mrow><msub><mi>u</mi><mn>2</mn></msub><mo>‚Ü¶</mo></mrow><mrow><msub><mi>u</mi><mn>1</mn></msub></mrow></math></eq>. If there is an earlier copy <eq><math><msubsup><mi>u</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq> mapping to <eq><math><msubsup><mi>u</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq>, we assert <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msubsup><mi>u</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></mrow></math></eq> by hash and don‚Äôt recurse. This is sound by proposition 5 and complete by proposition 6.</p></ul><p>Note that in the latter case, if <eq><math><msub><mi>u</mi><mn>2</mn></msub></math></eq> is entered, it‚Äôs guaranteed to be the first copy in DFS order not only among visited terms, but among all terms. Indeed, suppose the earliest copy <eq><math><msubsup><mi>u</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq> was skipped because some of its ancestor pivots <eq><math><mi>p</mi></math></eq> wasn‚Äôt visited. There could be two reasons for that:<ul><li><p><eq><math><mi>p</mi></math></eq> has a copy <eq><math><msup><mi>p</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></math></eq> outside <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq>. By proposition 8, there exists <eq><math><msubsup><mi>u</mi><mn>2</mn><mrow><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></mrow></msubsup></math></eq> in <eq><math><msup><mi>p</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></math></eq> such that <eq><math><mrow><msubsup><mi>u</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mi>/</mi><mi>p</mi><mo>‚àº</mo></mrow><mrow><msubsup><mi>u</mi><mn>2</mn><mrow><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></mrow></msubsup><mi>/</mi><msup><mi>p</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></mrow></math></eq>. Since <eq><math><mrow><msubsup><mi>u</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub></mrow></math></eq> and <eq><math><msub><mi>u</mi><mn>2</mn></msub></math></eq> is not a subterm of <eq><math><mi>p</mi></math></eq>, by proposition 2 <eq><math><mrow><msubsup><mi>u</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mo>‚àº</mo></mrow><mrow><msubsup><mi>u</mi><mn>2</mn><mrow><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></mrow></msubsup></mrow></math></eq>. Since <eq><math><msubsup><mi>u</mi><mn>2</mn><mrow><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></mrow></msubsup></math></eq> is outside <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq> and <eq><math><mrow><msub><mi>u</mi><mn>2</mn></msub><mo>‚àº</mo></mrow><mrow><msubsup><mi>u</mi><mn>2</mn><mrow><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></mrow></msubsup></mrow></math></eq>, <eq><math><msub><mi>u</mi><mn>2</mn></msub></math></eq> could not be entered.</p><li><p><eq><math><mi>p</mi></math></eq> has an earlier copy <eq><math><msup><mi>p</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></math></eq> inside <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq>. Repeat the process from the previous paragraph, finding <eq><math><mrow><msubsup><mi>u</mi><mn>2</mn><mrow><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></mrow></msubsup><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub></mrow></math></eq>. This <eq><math><msubsup><mi>u</mi><mn>2</mn><mrow><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></mrow></msubsup></math></eq> is earlier than <eq><math><msubsup><mi>u</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq>, so <eq><math><msubsup><mi>u</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq> could not be the earliest copy of <eq><math><msub><mi>u</mi><mn>2</mn></msub></math></eq>.</p></ul><p>An implementation of this algorithm follows.<pre><code class=language-python><span class=hljs-keyword>def</span> <span class="hljs-title function_">compare</span>(<span class=hljs-params>u1: Term, t1: Term, u2: Term, t2: Term, h21: <span class=hljs-built_in>dict</span>[<span class=hljs-built_in>int</span>, <span class=hljs-built_in>int</span>]</span>) -> <span class=hljs-built_in>bool</span>:
    <span class=hljs-keyword>if</span> (u2 <span class=hljs-keyword>is</span> <span class=hljs-keyword>not</span> t2) <span class=hljs-keyword>and</span> (u2 <span class=hljs-keyword>is</span> a pivot):
        <span class=hljs-keyword>if</span> there <span class=hljs-keyword>is</span> <span class=hljs-built_in>any</span> term alpha-equivalent to u2 outside t2:
            <span class=hljs-keyword>return</span> <span class=hljs-built_in>hash</span>[u1] == <span class=hljs-built_in>hash</span>[u2]
        <span class=hljs-keyword>if</span> <span class=hljs-built_in>hash</span>[u2] <span class=hljs-keyword>in</span> h21:
            <span class=hljs-keyword>return</span> h21[<span class=hljs-built_in>hash</span>[u2]] == <span class=hljs-built_in>hash</span>[u1]
        h21[<span class=hljs-built_in>hash</span>[u2]] = <span class=hljs-built_in>hash</span>[u1]

    <span class=hljs-keyword>match</span> (u1, u2):
        <span class=hljs-keyword>case</span> (Variable(x1), Variable(x2)):
            x1 = (x1 <span class=hljs-keyword>as</span> de Bruijn index) <span class=hljs-keyword>if</span> x1 defined within t1 <span class=hljs-keyword>else</span> (x1 <span class=hljs-keyword>as</span> name)
            x2 = (x2 <span class=hljs-keyword>as</span> de Bruijn index) <span class=hljs-keyword>if</span> x2 defined within t2 <span class=hljs-keyword>else</span> (x2 <span class=hljs-keyword>as</span> name)
            <span class=hljs-keyword>return</span> x1 == x2
        <span class=hljs-keyword>case</span> (Application(u11, u12), Application(u21, u22)):
            <span class=hljs-keyword>return</span> compare(u11, t1, u21, t2, h21) <span class=hljs-keyword>and</span> compare(u12, t1, u22, t2, h21)
        <span class=hljs-keyword>case</span> (Abstraction(_, v1), Abstraction(_, v2)):
            <span class=hljs-keyword>return</span> compare(v1, t1, v2, t2, h21)
        <span class=hljs-keyword>case</span> _:
            <span class=hljs-keyword>return</span> <span class=hljs-literal>False</span>

<span class=hljs-keyword>def</span> <span class="hljs-title function_">verify_hashes</span>():
    <span class=hljs-comment># Not implemented: validate that, within each class, all terms have the same size.</span>
    <span class=hljs-comment># Not implemented: sort classes by increasing size of terms.</span>
    <span class=hljs-keyword>for</span> class_members <span class=hljs-keyword>in</span> classes:
        t1 = class_members[<span class=hljs-number>0</span>]
        <span class=hljs-keyword>for</span> t2 <span class=hljs-keyword>in</span> class_members[<span class=hljs-number>1</span>:]:
            <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> compare(t1, t1, t2, t2, {}):
                <span class=hljs-keyword>return</span> <span class=hljs-literal>False</span>
    <span class=hljs-keyword>return</span> <span class=hljs-literal>True</span>
</code></pre><p>It turns out that this algorithm takes linear time. We will now prove this.<p>The pair <eq><math><mrow><mo form=prefix stretchy=false>(</mo><msub><mi>u</mi><mn>2</mn></msub><mo separator=true>,</mo><msub><mi>t</mi><mn>2</mn></msub><mo form=postfix stretchy=false>)</mo></mrow></math></eq> uniquely determines a particular invocation of <code>compare</code>. Split such invocations into two categories depending on whether the path <eq><math><mrow><msub><mi>t</mi><mn>2</mn></msub><mo>‚áù</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub></mrow></math></eq> contains any pivots except <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq> and possibly <eq><math><msub><mi>u</mi><mn>2</mn></msub></math></eq>. For visited pairs without such pivots, <eq><math><msub><mi>u</mi><mn>2</mn></msub></math></eq> determines <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq> almost uniquely: if <eq><math><msub><mi>u</mi><mn>2</mn></msub></math></eq> is not a pivot, <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq> is the closest pivot ancestor; otherwise it‚Äôs either such an ancestor or <eq><math><msub><mi>u</mi><mn>2</mn></msub></math></eq> itself. This means that the number of visited pairs without pivots inbetween is <eq><math><mrow><mo>‚â§</mo></mrow><mrow><mn>2</mn><mi>n</mi><mo>=</mo></mrow><mrow><mi class=mathcal>ùí™</mi><mo form=prefix stretchy=false>(</mo><mi>n</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq>. We will now prove that the number of visited pairs with pivots is also linear with amortized analysis.<p>Consider any path <eq><math><mrow><msub><mi>t</mi><mn>2</mn></msub><mo>‚áù</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub></mrow></math></eq> that does contain an additional pivot. Call the highest such pivot <eq><math><mi>p</mi></math></eq>, so that <eq><math><mrow><msub><mi>t</mi><mn>2</mn></msub><mo>‚áù</mo></mrow><mrow><mi>p</mi></mrow></math></eq> is non-empty and pivot-free except for <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq> and <eq><math><mi>p</mi></math></eq>, and <eq><math><mrow><mi>p</mi><mo>‚áù</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub></mrow></math></eq> is non-empty. Since <eq><math><mrow><mi>p</mi><mo>‚áù</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub></mrow></math></eq> is non-empty, the pivot <eq><math><mi>p</mi></math></eq> must have been recursed into, which only happens if <eq><math><mi>p</mi></math></eq> has no copies outside <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq> and is the earliest copy within <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq>. Call the immediately next copy in DFS order <eq><math><msup><mi>p</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></math></eq>. Since <eq><math><mrow><msup><mi>p</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup><mo>‚àº</mo></mrow><mrow><mi>p</mi></mrow></math></eq>, <eq><math><msup><mi>p</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></math></eq> and <eq><math><mi>p</mi></math></eq> have the same tree structure and we can find <eq><math><msubsup><mi>u</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq> such that <eq><math><mrow><mo form=prefix stretchy=false>(</mo><msup><mi>p</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup><mo>‚áù</mo><msubsup><mi>u</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mo form=postfix stretchy=false>)</mo><mo>=</mo></mrow><mrow><mo form=prefix stretchy=false>(</mo><mi>p</mi><mo>‚áù</mo><msub><mi>u</mi><mn>2</mn></msub><mo form=postfix stretchy=false>)</mo></mrow></math></eq>. We ‚Äúpay‚Äù for entering the pair <eq><math><mrow><mo form=prefix stretchy=false>(</mo><msub><mi>u</mi><mn>2</mn></msub><mo separator=true>,</mo><msub><mi>t</mi><mn>2</mn></msub><mo form=postfix stretchy=false>)</mo></mrow></math></eq> with <eq><math><msubsup><mi>u</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq> and will now demonstrate that all visited pairs pay with different terms, which implies linearity.<p>Suppose that there are two pairs that pay with the same <eq><math><msup><mi>u</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></math></eq>: <eq><math><mrow><mo form=prefix stretchy=false>(</mo><msub><mi>u</mi><mn>1</mn></msub><mo separator=true>,</mo><msub><mi>t</mi><mn>1</mn></msub><mo form=postfix stretchy=false>)</mo></mrow></math></eq> with highest pivot <eq><math><msub><mi>p</mi><mn>1</mn></msub></math></eq> with next copy <eq><math><msubsup><mi>p</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq>, and <eq><math><mrow><mo form=prefix stretchy=false>(</mo><msub><mi>u</mi><mn>2</mn></msub><mo separator=true>,</mo><msub><mi>t</mi><mn>2</mn></msub><mo form=postfix stretchy=false>)</mo></mrow></math></eq> with highest pivot <eq><math><msub><mi>p</mi><mn>2</mn></msub></math></eq> with next copy <eq><math><msubsup><mi>p</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq>. <eq><math><msup><mi>u</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></math></eq> is a subterm of all of <eq><math><mrow><msub><mi>t</mi><mn>1</mn></msub><mo separator=true>,</mo></mrow><mrow><msub><mi>t</mi><mn>2</mn></msub><mo separator=true>,</mo></mrow><mrow><msubsup><mi>p</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mo separator=true>,</mo></mrow><mrow><msubsup><mi>p</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></mrow></math></eq>, so there is a linear order on these four terms. Without loss of generality, assume <eq><math><msub><mi>t</mi><mn>1</mn></msub></math></eq> is an ancestor of <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq>. There are three linear orders matching <eq><math><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>‚â∫</mo></mrow><mrow><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq>, <eq><math><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>‚â∫</mo></mrow><mrow><msubsup><mi>p</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></mrow></math></eq>, <eq><math><mrow><msub><mi>t</mi><mn>2</mn></msub><mo>‚â∫</mo></mrow><mrow><msubsup><mi>p</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></mrow></math></eq> (note that we aren‚Äôt assuming that all terms in this order are distinct):<ol><li><p><eq><math><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>‚â∫</mo></mrow><mrow><msub><mi>t</mi><mn>2</mn></msub><mo>‚â∫</mo></mrow><mrow><msubsup><mi>p</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mo>‚â∫</mo></mrow><mrow><msubsup><mi>p</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></mrow></math></eq>. By proposition 9, <eq><math><msub><mi>p</mi><mn>2</mn></msub></math></eq> is not a subterm of <eq><math><msubsup><mi>p</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq>. By proposition 8, there is <eq><math><mi>q</mi></math></eq> such that <eq><math><mrow><msubsup><mi>p</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mi>/</mi><msubsup><mi>p</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mo>‚àº</mo></mrow><mrow><mi>q</mi><mi>/</mi><msub><mi>p</mi><mn>1</mn></msub></mrow></math></eq>. Since <eq><math><mrow><msub><mi>p</mi><mn>2</mn></msub><mo>‚àº</mo></mrow><mrow><msubsup><mi>p</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></mrow></math></eq> and <eq><math><msub><mi>p</mi><mn>2</mn></msub></math></eq> is not a subterm of <eq><math><msubsup><mi>p</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq>, by proposition 2 <eq><math><mrow><mi>q</mi><mo>‚àº</mo></mrow><mrow><msubsup><mi>p</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></mrow></math></eq>. By proposition 9, <eq><math><msub><mi>p</mi><mn>1</mn></msub></math></eq> is not a subterm of <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq>, thus <eq><math><mi>q</mi></math></eq> is not a subterm of <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq>. This means that <eq><math><msub><mi>p</mi><mn>2</mn></msub></math></eq> could not be entered from <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq>, since it has a copy <eq><math><mi>q</mi></math></eq> outside <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq>.</p><li><p><eq><math><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>‚â∫</mo></mrow><mrow><msub><mi>t</mi><mn>2</mn></msub><mo>‚â∫</mo></mrow><mrow><msubsup><mi>p</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mo>‚â∫</mo></mrow><mrow><msubsup><mi>p</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></mrow></math></eq>. By proposition 9, <eq><math><msub><mi>p</mi><mn>1</mn></msub></math></eq> is not a subterm of <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq> or <eq><math><msubsup><mi>p</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq>. Since <eq><math><msub><mi>p</mi><mn>1</mn></msub></math></eq> is earlier than <eq><math><msubsup><mi>p</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq> in DFS order, <eq><math><msub><mi>p</mi><mn>1</mn></msub></math></eq> is also earlier than <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq>. By proposition 8, there is <eq><math><mi>q</mi></math></eq> such that <eq><math><mrow><msubsup><mi>p</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mi>/</mi><msubsup><mi>p</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mo>‚àº</mo></mrow><mrow><mi>q</mi><mi>/</mi><msub><mi>p</mi><mn>2</mn></msub></mrow></math></eq>. Since <eq><math><mrow><msub><mi>p</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msubsup><mi>p</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></mrow></math></eq> and <eq><math><msub><mi>p</mi><mn>1</mn></msub></math></eq> is not a subterm of <eq><math><msubsup><mi>p</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq>, by proposition 2 <eq><math><mrow><mi>q</mi><mo>‚àº</mo></mrow><mrow><msubsup><mi>p</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></mrow></math></eq>. Since <eq><math><mi>q</mi></math></eq> is in <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq>, it is also later than <eq><math><msub><mi>p</mi><mn>1</mn></msub></math></eq> in DFS order. Since <eq><math><msub><mi>p</mi><mn>2</mn></msub></math></eq> is earlier than <eq><math><msubsup><mi>p</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq>, <eq><math><mi>q</mi></math></eq> is earlier than <eq><math><msubsup><mi>p</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq>. Thus <eq><math><mrow><mi>q</mi><mo>‚àº</mo></mrow><mrow><msub><mi>p</mi><mn>1</mn></msub></mrow></math></eq> is between <eq><math><msub><mi>p</mi><mn>1</mn></msub></math></eq> and <eq><math><msubsup><mi>p</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq> in DFS order, so <eq><math><msubsup><mi>p</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq> cannot be the immediately next copy of <eq><math><msub><mi>p</mi><mn>1</mn></msub></math></eq>.</p><li><p><eq><math><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>‚â∫</mo></mrow><mrow><msubsup><mi>p</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mo>‚â∫</mo></mrow><mrow><msub><mi>t</mi><mn>2</mn></msub><mo>‚â∫</mo></mrow><mrow><msubsup><mi>p</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></mrow></math></eq>. By proposition 8, there are <eq><math><mi>q</mi></math></eq> and <eq><math><msup><mi>q</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></math></eq> such that <eq><math><mrow><msub><mi>p</mi><mn>2</mn></msub><mi>/</mi><msubsup><mi>p</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mo>‚àº</mo></mrow><mrow><mi>q</mi><mi>/</mi><msub><mi>p</mi><mn>1</mn></msub></mrow></math></eq> and <eq><math><mrow><msubsup><mi>p</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mi>/</mi><msubsup><mi>p</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mo>‚àº</mo></mrow><mrow><msup><mi>q</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup><mi>/</mi><msub><mi>p</mi><mn>1</mn></msub></mrow></math></eq>. By proposition 6, <eq><math><mrow><mi>q</mi><mo>‚àº</mo></mrow><mrow><msup><mi>q</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></mrow></math></eq>. Since <eq><math><msub><mi>p</mi><mn>2</mn></msub></math></eq> is earlier than <eq><math><msubsup><mi>p</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq> in DFS order, <eq><math><mrow><mo form=prefix stretchy=false>(</mo><msubsup><mi>p</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mo>‚áù</mo><msub><mi>p</mi><mn>2</mn></msub><mo form=postfix stretchy=false>)</mo><mo>=</mo></mrow><mrow><mo form=prefix stretchy=false>(</mo><msub><mi>p</mi><mn>1</mn></msub><mo>‚áù</mo><mi>q</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq>, and <eq><math><mrow><mo form=prefix stretchy=false>(</mo><msubsup><mi>p</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mo>‚áù</mo><msubsup><mi>p</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mo form=postfix stretchy=false>)</mo><mo>=</mo></mrow><mrow><mo form=prefix stretchy=false>(</mo><msub><mi>p</mi><mn>1</mn></msub><mo>‚áù</mo><msup><mi>q</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup><mo form=postfix stretchy=false>)</mo></mrow></math></eq>, <eq><math><mi>q</mi></math></eq> is earlier than <eq><math><msup><mi>q</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></math></eq> in DFS order. Together with <eq><math><mrow><mi>q</mi><mo>‚àº</mo></mrow><mrow><msup><mi>q</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></mrow></math></eq>, this implies <eq><math><msup><mi>q</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></math></eq> could not be entered from <eq><math><msub><mi>t</mi><mn>1</mn></msub></math></eq>. However, the path <eq><math><mrow><msubsup><mi>p</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mo>‚áù</mo></mrow><mrow><msup><mi>u</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></mrow></math></eq> passes through <eq><math><msubsup><mi>p</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq>, so the rerooted path <eq><math><mrow><msub><mi>p</mi><mn>1</mn></msub><mo>‚áù</mo></mrow><mrow><msub><mi>u</mi><mn>1</mn></msub></mrow></math></eq> passes through <eq><math><msup><mi>q</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></math></eq>, and thus <eq><math><msup><mi>q</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></math></eq> has to be entered for <eq><math><msub><mi>u</mi><mn>1</mn></msub></math></eq> to be reached.</p></ol><p>This proves that the mapping <eq><math><mrow><mo form=prefix stretchy=false>(</mo><msub><mi>t</mi><mn>2</mn></msub><mo separator=true>,</mo><msub><mi>u</mi><mn>2</mn></msub><mo form=postfix stretchy=false>)</mo><mo>‚Ü¶</mo></mrow><mrow><msup><mi>u</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></mrow></math></eq> is injective, and thus this part of the algorithm takes at most linear time, which proves the linear complexity of the entire algorithm.<p>Notes:<ol><li><p>The algorithm is linear even under the presence of collisions. The mapping <eq><math><mrow><mo form=prefix stretchy=false>(</mo><msub><mi>t</mi><mn>2</mn></msub><mo separator=true>,</mo><msub><mi>u</mi><mn>2</mn></msub><mo form=postfix stretchy=false>)</mo><mo>‚Ü¶</mo></mrow><mrow><msup><mi>u</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></mrow></math></eq> will be defined over a smaller set of pairs than with perfect hashes, since the algorithm will abort at some point, but will stay injective.</p><li><p>The arguments <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mo separator=true>,</mo></mrow><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow></math></eq> to <code>compare</code> are not taken into consideration during the proof. <code>compare</code> can be transformed to <code>serialize</code>, which lists non-entered terms as either hash values or backrefs, followed by an assertion that the serialized strings of all terms within a group are equal. This still takes linear time because the total string length is linear. This algorithm can resolve hash collisions locally by splitting groups, but is more complex and requires more memory.</p><li><p>The only reason a <code>serialize</code>-based algorithm needs to be pre-fed with hashes is to determine which terms are pivots ‚Äì the exact hashes or even collisions between pivots are inconsequential. Pivots mostly matter because of the assumption that the path <eq><math><mrow><mi>t</mi><mo>‚áù</mo></mrow><mrow><mi>p</mi></mrow></math></eq> does not contain other pivots. Hashing is an overkill, but we are not aware of any algorithm for detecting pivots without it.</p></ol><p class=next-group><span aria-level=3 class=side-header role=heading><span>Classes</span></span>To compute equivalence classes, we use the opposite approach of the one we used for hashing. We start with de Bruijn indices, compute the equivalence class of the root term using hash consing, and recurse, replacing de Bruijn indices with names as necessary.<pre><code class=language-python><span class=hljs-keyword>def</span> <span class="hljs-title function_">rec</span>(<span class=hljs-params>t: Term</span>) -> <span class=hljs-built_in>int</span>:
    classes[t] = calculate_class(t)
    <span class=hljs-keyword>match</span> t:
        <span class=hljs-keyword>case</span> Variable(_):
            <span class=hljs-keyword>pass</span>
        <span class=hljs-keyword>case</span> Application(t1, t2):
            rec(t1)
            rec(t2)
        <span class=hljs-keyword>case</span> Abstraction(x, u):
            replace_mentions(x, u)
            rec(u)

<span class=hljs-comment># Not implemented: calculate the equivalence class of `t` with hash consing.</span>
<span class=hljs-keyword>def</span> <span class="hljs-title function_">calculate_class</span>(<span class=hljs-params>t: Term</span>) -> <span class=hljs-built_in>int</span>: ...

<span class=hljs-comment># Not implemented: replace all de Bruijn indices corresponding to `x` within `t` with variable name</span>
<span class=hljs-comment># of `x`.</span>
<span class=hljs-keyword>def</span> <span class="hljs-title function_">replace_mentions</span>(<span class=hljs-params>x: Variable, t: Term</span>): ...
</code></pre><p>The time complexity of <code>calculate_class</code> is <eq><math><mrow><mi class=mathcal>ùí™</mi><mrow><mo fence=true form=prefix>(</mo><mrow><mo fence=true form=prefix>|</mo><mi>t</mi><mo fence=true form=postfix>|</mo></mrow><mo fence=true form=postfix>)</mo></mrow></mrow></math></eq>, where <eq><math><mrow><mo fence=true form=prefix>|</mo><mo lspace=0em rspace=0em>‚ãÖ</mo><mo fence=true form=postfix>|</mo></mrow></math></eq> denotes the number of subterms of <eq><math><mi>t</mi></math></eq>, resulting in quadratic time complexity in total.<p>To fix this, we adjust <code>rec</code> to compute not just the class of <eq><math><mi>t</mi></math></eq>, but also of some subterms <eq><math><mi>u</mi></math></eq> of <eq><math><mi>t</mi></math></eq>, at no additional asymptotic cost, with a trick described below. In particular, we ensure that the classes of all subterms <eq><math><mi>u</mi></math></eq> such that <eq><math><mrow><mrow><mo fence=true form=prefix>|</mo><mi>u</mi><mo fence=true form=postfix>|</mo></mrow><mo>‚â•</mo></mrow><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mrow><mo fence=true form=prefix>|</mo><mi>t</mi><mo fence=true form=postfix>|</mo></mrow></mrow></math></eq> are guaranteed to be computed. We then recurse into unhandled subterms, which are guaranteed to have size <eq><math><mrow><mrow><mo fence=true form=prefix>|</mo><mi>u</mi><mo fence=true form=postfix>|</mo></mrow><mo><</mo></mrow><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mrow><mo fence=true form=prefix>|</mo><mi>t</mi><mo fence=true form=postfix>|</mo></mrow></mrow></math></eq>.<p>Since <eq><math><mrow><mo fence=true form=prefix>|</mo><mi>t</mi><mo fence=true form=postfix>|</mo></mrow></math></eq> is at worst halved during each recursive invocation, there are at most <eq><math><mrow><mrow><mi>log</mi><mo>‚Å°</mo><mspace width=0.1667em></mspace></mrow><mi>n</mi></mrow></math></eq> levels of recursion. Since each subterm only contributes <eq><math><mrow><mi class=mathcal>ùí™</mi><mo form=prefix stretchy=false>(</mo><mn>1</mn><mo form=postfix stretchy=false>)</mo></mrow></math></eq> amortized to the time complexity per each recursion invocation it‚Äôs part of, there can be at most <eq><math><mrow><mrow><mi>log</mi><mo>‚Å°</mo><mspace width=0.1667em></mspace></mrow><mi>n</mi></mrow></math></eq> such invocations. Hence the total time complexity is <eq><math><mrow><mi class=mathcal>ùí™</mi><mo form=prefix stretchy=false>(</mo><mi>n</mi><mrow><mspace width=0.1667em></mspace><mi>log</mi><mo>‚Å°</mo><mspace width=0.1667em></mspace></mrow><mi>n</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq>.<p>The rest of the section explains how to efficiently compute classes of all ‚Äúlarge‚Äù subterms of <eq><math><mi>t</mi></math></eq>.<p>First, we adjust <code>calculate_class</code> to save the hash-consed classes of all subterms of <eq><math><mi>t</mi></math></eq> in <code>aux_class</code>. Not all of those classes will be valid answers: for example, in <eq><math><mrow><mi>Œª</mi><mi>.</mi><mi>Œª</mi><mi>.</mi><mi>a</mi><mspace width=0.1667em></mspace><mrow style="padding:0 0 0.1em 0;border-bottom:0.065em solid;"><mn>1</mn></mrow></mrow></math></eq>, the class of the first subterm will be computed as the class of string <eq><math><mrow><mi>Œª</mi><mi>.</mi><mi>a</mi><mspace width=0.1667em></mspace><mrow style="padding:0 0 0.1em 0;border-bottom:0.065em solid;"><mn>1</mn></mrow></mrow></math></eq>, which has a dangling de Bruijn index (<eq><math><mrow><mi>Œª</mi><mi>.</mi><mi>a</mi><mi>x</mi></mrow></math></eq> would be correct).<p>However, these classes are guaranteed to be valid for all <em>locally closed</em> subterms, i.e. subterms without dangling indices. Such subterms can access both variables declared outside <eq><math><mi>t</mi></math></eq> (by name) and variables declared inside themselves (by index), but not variables declared inbetween. To detect locally closed subterms, we calculate the topmost variable that each subterm accesses by the de Bruijn index (<code>max_index</code>). If, for a given subterm <eq><math><mi>u</mi></math></eq>, the top variable is within <eq><math><mi>u</mi></math></eq>, we know <eq><math><mi>u</mi></math></eq> is locally closed.<p>Now that we‚Äôve handled all locally closed subterms, it turns out that large non-locally-closed subterms are guaranteed to be globally unique, and thus we can assign an anonymous equivalence class to them without relying on hash consing. Indeed: each non-locally-closed subterm <eq><math><mi>u</mi></math></eq> refers to variables defined within <eq><math><mi>t</mi></math></eq>, and can thus only be <eq><math><mi>Œ±</mi></math></eq>-equivalent to other subterms of <eq><math><mi>t</mi></math></eq>. But since <eq><math><mrow><mrow><mo fence=true form=prefix>|</mo><mi>u</mi><mo fence=true form=postfix>|</mo></mrow><mo>‚â•</mo></mrow><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mrow><mo fence=true form=prefix>|</mo><mi>t</mi><mo fence=true form=postfix>|</mo></mrow></mrow></math></eq>, there isn‚Äôt enough space within <eq><math><mi>t</mi></math></eq> for another subterm of matching size.<p>The pseudo-code for the complete algorithm is shown below.<pre><code class=language-python><div class=expansible-code><input id=expansible2 type=checkbox><div class=highlighted>size: <span class=hljs-built_in>dict</span>[Term, <span class=hljs-built_in>int</span>] = {}
aux_class: <span class=hljs-built_in>dict</span>[Term, <span class=hljs-built_in>int</span>] = {}
max_index: <span class=hljs-built_in>dict</span>[Term, <span class=hljs-built_in>int</span>] = {}
out_index: <span class=hljs-built_in>dict</span>[Term, <span class=hljs-built_in>int</span>] = {}

<span class=hljs-keyword>def</span> <span class="hljs-title function_">rec</span>(<span class=hljs-params>t: Term</span>) -> <span class=hljs-built_in>int</span>:
    dfs1(t)
    dfs2(t, size[t])

<span class=hljs-keyword>def</span> <span class="hljs-title function_">dfs1</span>(<span class=hljs-params>t: Term</span>):
    <span class=hljs-keyword>match</span> t:
        <span class=hljs-keyword>case</span> Variable(x):
            size[t] = <span class=hljs-number>1</span>
            aux_class[t] = hash_cons(x)
            <span class=hljs-keyword>if</span> x <span class=hljs-keyword>is</span> a de Bruijn index:
                max_index[t] = x
            <span class=hljs-keyword>else</span>:  <span class=hljs-comment># x is a variable name</span>
                max_index[t] = -<span class=hljs-number>1</span>
        <span class=hljs-keyword>case</span> Abstraction(x, u):
            dfs1(u)
            size[t] = <span class=hljs-number>1</span> + size[u]
            aux_class[t] = hash_cons((aux_class[u],))
            max_index[t] = max_index[u] - <span class=hljs-number>1</span>
        <span class=hljs-keyword>case</span> Application(t1, t2):
            dfs1(t1)
            dfs1(t2)
            size[t] = <span class=hljs-number>1</span> + size[t1] + size[t2]
            aux_class[t] = hash_cons((aux_class[t1], aux_class[t2]))
            max_index[t] = <span class=hljs-built_in>max</span>(max_index[t1], max_index[t2])

<span class=hljs-keyword>def</span> <span class="hljs-title function_">dfs2</span>(<span class=hljs-params>t: Term, root_size: <span class=hljs-built_in>int</span></span>):
    <span class=hljs-keyword>if</span> max_index[t] < <span class=hljs-number>0</span>:  <span class=hljs-comment># locally closed</span>
        out_class[t] = aux_class[t]
    <span class=hljs-keyword>else</span>:
        <span class=hljs-keyword>if</span> <span class=hljs-number>2</span> * size[t] < root_size:
            rec(t)
            <span class=hljs-keyword>return</span>
        out_class[t] = anonymous_class()

    <span class=hljs-keyword>match</span> t:
        <span class=hljs-keyword>case</span> Variable(_):
            <span class=hljs-keyword>pass</span>
        <span class=hljs-keyword>case</span> Abstraction(x, u):
            replace_mentions(x, u)
            dfs2(u, root_size)
        <span class=hljs-keyword>case</span> Application(t1, t2):
            dfs2(t1, root_size)
            dfs2(t2, root_size)

<span class=hljs-meta>@functools.cache  </span><span class=hljs-comment># memoize</span>
<span class=hljs-keyword>def</span> <span class="hljs-title function_">hash_cons</span>(<span class=hljs-params>arg</span>) -> <span class=hljs-built_in>int</span>:
    <span class=hljs-keyword>return</span> anonymous_class()

last_class = <span class=hljs-number>0</span>
<span class=hljs-keyword>def</span> <span class="hljs-title function_">anonymous_class</span>() -> <span class=hljs-built_in>int</span>:
    <span class=hljs-keyword>global</span> last_class
    last_class += <span class=hljs-number>1</span>
    <span class=hljs-keyword>return</span> last_class
</div><label for=expansible2>Expand</label></div></code></pre></div></section><footer><div class=viewport-container><h2>Made with my own bare hands (why.)</h2></div></footer><script>window.addEventListener("keydown", e => {
				if (e.key === "Enter") {
					if (e.ctrlKey) {
						window.open("https://github.com/purplesyringa/site/edit/master/blog/faster-comparison-modulo-alpha-equivalence/index.md", "_blank");
					} else if (
						e.target.type === "checkbox"
						&& e.target.parentNode
						&& e.target.parentNode.className === "expansible-code"
					) {
						e.target.click();
					}
				}
			});</script>