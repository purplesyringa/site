<!doctypehtml><html prefix="og: http://ogp.me/ns#"lang=en_US><meta charset=utf-8><meta content=width=device-width,initial-scale=1 name=viewport><title>Faster comparison modulo Œ±-equivalence | purplesyringa's blog</title><link href=../../favicon.ico?v=2 rel=icon><link href=../../all.css rel=stylesheet><link href=../../blog.css rel=stylesheet><link href=../../vendor/Temml-Local.css rel=stylesheet><link crossorigin href=https://fonts.googleapis.com/css2?family=Noto+Sans:ital,wght@0,100..900;1,100..900&family=Roboto+Mono:ital,wght@0,100..700;1,100..700&family=Roboto:ital,wght@0,400;0,700;1,400;1,700&family=Slabo+27px&display=swap rel=stylesheet><link href=../../fonts/webfont.css rel=stylesheet><link media="screen and (prefers-color-scheme: dark"href=../../vendor/atom-one-dark.min.css rel=stylesheet><link media="screen and (prefers-color-scheme: light"href=../../vendor/a11y-light.min.css rel=stylesheet><link title="Blog posts"href=../../blog/feed.rss rel=alternate type=application/rss+xml><meta content="Faster comparison modulo Œ±-equivalence"property=og:title><meta content=article property=og:type><meta content=https://purplesyringa.moe/blog/faster-comparison-modulo-alpha-equivalence/og.png property=og:image><meta content=https://purplesyringa.moe/blog/faster-comparison-modulo-alpha-equivalence/ property=og:url><meta content="This article is a technical counterpart of my previous post Finding duplicated code with tools from your CS course. It is deliberately written in a terse manner, and I‚Äôm not going to hold your hand. Consider reading the previous post first and coming back here later."property=og:description><meta content=en_US property=og:locale><meta content="purplesyringa's blog"property=og:site_name><meta content=summary_large_image name=twitter:card><meta content=https://purplesyringa.moe/blog/faster-comparison-modulo-alpha-equivalence/og.png name=twitter:image><script data-website-id=0da1961d-43f2-45cc-a8e2-75679eefbb69 defer src=https://zond.tei.su/script.js></script><body><header><div class=viewport-container><div class=media><a href=https://github.com/purplesyringa><img alt=GitHub src=../../images/github-mark-white.svg></a></div><h1><a href=/>purplesyringa</a></h1><nav><a href=../..>about</a><a class=current href=../../blog/>blog</a><a href=../../sink/>kitchen sink</a></nav></div></header><section><div class=viewport-container><h2>Faster comparison modulo Œ±-equivalence</h2><time>November 30, 2025</time><p>This article is a technical counterpart of my previous post <a href=../finding-duplicated-code-with-tools-from-your-cs-course/>Finding duplicated code with tools from your CS course</a>. It is deliberately written in a terse manner, and I‚Äôm not going to hold your hand. Consider reading the previous post first and coming back here later.<p class=next-group><span aria-level=3 class=side-header role=heading><span>Introduction</span></span>Given a <eq><math><mi>Œª</mi></math></eq>-calculus term, suppose we want to find all of its <eq><math><mi>Œ±</mi></math></eq>-equivalent subterms. Terms <eq><math><msub><mi>t</mi><mn>1</mn></msub></math></eq> and <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq> are considered <eq><math><mi>Œ±</mi></math></eq>-equivalent (denoted as <eq><math><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq> in this article) if they are syntactically equal up to a bijection between their bound variables. For example, <eq><math><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>=</mo></mrow><mrow><mi>Œª</mi><mi>x</mi><mi>.</mi><mi>a</mi><mspace width=0.1667em></mspace><mi>x</mi></mrow></math></eq> and <eq><math><mrow><msub><mi>t</mi><mn>2</mn></msub><mo>=</mo></mrow><mrow><mi>Œª</mi><mi>y</mi><mi>.</mi><mi>a</mi><mspace width=0.1667em></mspace><mi>y</mi></mrow></math></eq> are <eq><math><mi>Œ±</mi></math></eq>-equivalent because the bijection <eq><math><mrow><mo form=prefix stretchy=false>{</mo><mi>x</mi><mo>‚Ü¶</mo><mi>y</mi><mo form=postfix stretchy=false>}</mo></mrow></math></eq> translates <eq><math><msub><mi>t</mi><mn>1</mn></msub></math></eq> to <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq>, and <eq><math><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>=</mo></mrow><mrow><mi>Œª</mi><mi>x</mi><mi>.</mi><mi>a</mi><mspace width=0.1667em></mspace><mi>x</mi></mrow></math></eq> and <eq><math><mrow><msub><mi>t</mi><mn>2</mn></msub><mo>=</mo></mrow><mrow><mi>Œª</mi><mi>x</mi><mi>.</mi><mi>b</mi><mspace width=0.1667em></mspace><mi>x</mi></mrow></math></eq> are not <eq><math><mi>Œ±</mi></math></eq>-equivalent because <eq><math><mi>a</mi></math></eq> and <eq><math><mi>b</mi></math></eq> are free in <eq><math><msub><mi>t</mi><mn>1</mn></msub></math></eq> and <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq> respectively.<p>Terms are <eq><math><mi>Œ±</mi></math></eq>-equivalent if and only if their <em>locally nameless</em> forms are syntactically equal. The locally nameless form of a term <eq><math><mi>t</mi></math></eq> represents variables free in <eq><math><mi>t</mi></math></eq> by name, and variables bound in <eq><math><mi>t</mi></math></eq> by de Bruijn index. For example, <eq><math><mrow><mi>Œª</mi><mi>x</mi><mi>.</mi><mi>a</mi><mspace width=0.1667em></mspace><mi>x</mi></mrow></math></eq> is represented as <eq><math><mrow><mi>Œª</mi><mi>.</mi><mi>a</mi><mspace width=0.1667em></mspace><mrow style="padding:0 0 0.1em 0;border-bottom:0.065em solid;"><mn>1</mn></mrow></mrow></math></eq>. While computing the locally nameless form of a single term is straightforward, efficiently computing forms of all subterms of a term is tricky, since whether a variable is free or bound depends on the term whose form is being computed.<p>This article describes:<ol><li>A linear-time algorithm for computing hashes of subterms up to <eq><math><mi>Œ±</mi></math></eq>-equivalence, i.e. hashes of their locally nameless forms. We prove a bound on the collision rate of non-<eq><math><mi>Œ±</mi></math></eq>-equivalent subterms.<li>A linear-time algorithm for validating the resulting hashes for lack of collisions. Together with 1., this produces a reliable classification algorithm with expected linear runtime.<li>An algorithm for computing <eq><math><mi>Œ±</mi></math></eq>-equivalence classes in <eq><math><mrow><mi class=mathcal>ùí™</mi><mo form=prefix stretchy=false>(</mo><mi>n</mi><mrow><mspace width=0.1667em></mspace><mi>log</mi><mo>‚Å°</mo><mspace width=0.1667em></mspace></mrow><mi>n</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> guaranteed time, as a deterministic alternative to 1.+2.</ol><p>Over the course of the article, we use Python-like pseudocode. A common pattern in the pseudocode is using <code>dict[...]</code> to associate temporary data with terms or variables. This should be read as using linear arrays addressed by unique term/variable indices, or alternatively ad-hoc fields in data types, as opposed to a hash table access.<p class=next-group><span aria-level=3 class=side-header role=heading><span>Prior art</span></span>Our first algorithm is an adaptation of the algorithm developed in:<blockquote><p>Krzysztof Maziarz, Tom Ellis, Alan Lawrence, Andrew Fitzgibbon, and Simon Peyton Jones. 2021. <a href=https://arxiv.org/abs/2105.02856>Hashing modulo alpha-equivalence</a>. In Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation (PLDI 2021). Association for Computing Machinery, New York, NY, USA, 960‚Äì973. <a href=https://doi.org/10.1145/3453483.3454088>https://doi.org/10.1145/3453483.3454088</a></blockquote><p>Maziarz et al.'s algorithm has <eq><math><mrow><mi class=mathcal>ùí™</mi><mo form=prefix stretchy=false>(</mo><mi>n</mi><mspace width=0.1667em></mspace><msup><mi>log</mi><mn>2</mn></msup><mo>‚Å°</mo><mspace width=0.1667em></mspace><mi>n</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> runtime, but can be straightforwardly adjusted to expected <eq><math><mrow><mi class=mathcal>ùí™</mi><mo form=prefix stretchy=false>(</mo><mi>n</mi><mrow><mspace width=0.1667em></mspace><mi>log</mi><mo>‚Å°</mo><mspace width=0.1667em></mspace></mrow><mi>n</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> time by replacing binary trees with hash tables. Crucially, this algorithm allows hashes to be computed <em>incrementally</em>. It achieves this by producing <em>e-summaries</em>, which represent the entire contents of a term up to <eq><math><mi>Œ±</mi></math></eq>-equivalence, and efficiently combining e-summaries in application terms. We believe this ‚Äúpurely functional‚Äù approach does not allow for faster algorithms, so our algorithm expects the entire expression to be provided upfront.<p>To the best of our knowledge, our algorithm for validating hashes is novel.<p>The third algorithm is an adaptation of:<blockquote><p>Lasse Blaauwbroek, Miroslav Ol≈°√°k, and Herman Geuvers. 2024. <a href=https://arxiv.org/abs/2401.02948>Hashing Modulo Context-Sensitive Œ±-Equivalence</a>. Proc. ACM Program. Lang. 8, PLDI, Article 229 (June 2024), 24 pages. <a href=https://doi.org/10.1145/3656459>https://doi.org/10.1145/3656459</a></blockquote><p>Our algorithm has the same asymptotic complexity as described in the paper, but is adjusted to non-context-sensitive <eq><math><mi>Œ±</mi></math></eq>-equivalence and simplified, which hopefully leads to easier intuitive understanding and faster practical performance. To guarantee deterministic <eq><math><mrow><mi class=mathcal>ùí™</mi><mo form=prefix stretchy=false>(</mo><mi>n</mi><mrow><mspace width=0.1667em></mspace><mi>log</mi><mo>‚Å°</mo><mspace width=0.1667em></mspace></mrow><mi>n</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> time, we replace hash consing with an approach similar to:<blockquote><p>Michalis Christou, Maxime Crochemore, Tom√°≈° Flouri, Costas S. Iliopoulos, Jan Janou≈°Ek, Bo≈ôIvoj Melichar, and Solon P. Pissis. 2012. Computing all subtree repeats in ordered trees. Inf. Process. Lett. 112, 24 (December, 2012), 958‚Äì962. <a href=https://doi.org/10.1016/j.ipl.2012.09.001>https://doi.org/10.1016/j.ipl.2012.09.001</a></blockquote><p class=next-group><span aria-level=3 class=side-header role=heading><span>Hashing</span></span>We start with a named form, where all variables are accessed by names. This ensures that the innermost terms are already in the locally nameless form. We then compute the locally nameless forms of other terms recursively:<section><eqn><math style="display:block math;"class=tml-display display=block><mtable columnalign="right left"displaystyle=true><mtr><mtd style="padding:0.7ex 0em 0.7ex 0em;"class=tml-right><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>x</mi><mo form=postfix stretchy=false>)</mo></mrow></mtd><mtd style="padding:0.7ex 0em 0.7ex 0em;"class=tml-left><mrow><mo>=</mo><mi>x</mi></mrow></mtd></mtr><mtr><mtd style="padding:0.7ex 0em 0.7ex 0em;"class=tml-right><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><msub><mi>t</mi><mn>1</mn></msub><msub><mi>t</mi><mn>2</mn></msub><mo form=postfix stretchy=false>)</mo></mrow></mtd><mtd style="padding:0.7ex 0em 0.7ex 0em;"class=tml-left><mrow><mo>=</mo><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><msub><mi>t</mi><mn>1</mn></msub><mo form=postfix stretchy=false>)</mo><mspace width=0.1667em></mspace><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><msub><mi>t</mi><mn>2</mn></msub><mo form=postfix stretchy=false>)</mo></mrow></mtd></mtr><mtr><mtd style="padding:0.7ex 0em 0.7ex 0em;"class=tml-right><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>Œª</mi><mi>x</mi><mi>.</mi><mi>t</mi><mo form=postfix stretchy=false>)</mo></mrow></mtd><mtd style="padding:0.7ex 0em 0.7ex 0em;"class=tml-left><mrow><mo>=</mo><mi>Œª</mi><mi>.</mi><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>t</mi><mo form=postfix stretchy=false>)</mo><mo form=prefix stretchy=false>[</mo><mi>x</mi><mo lspace=0.2222em rspace=0em>:</mo><mo lspace=0em>=</mo><mrow style="padding:0 0 0.1em 0;border-bottom:0.065em solid;"><mn>0</mn></mrow><mo form=postfix stretchy=false>]</mo></mrow></mtd></mtr></mtable></math></eqn></section><p><eq><math><mrow><mo form=prefix stretchy=false>[</mo><mi>x</mi><mo lspace=0.2222em rspace=0em>:</mo><mo lspace=0em>=</mo><mrow style="padding:0 0 0.1em 0;border-bottom:0.065em solid;"><mn>0</mn></mrow><mo form=postfix stretchy=false>]</mo></mrow></math></eq> denotes that the form of <eq><math><mrow><mi>Œª</mi><mi>x</mi><mi>.</mi><mi>t</mi></mrow></math></eq> is computed from the form of <eq><math><mi>t</mi></math></eq> by replacing mentions of <eq><math><mi>x</mi></math></eq> with de Bruijn indices. This replacement is the crux of the problem: while it can be easily performed on strings, the (possibly very long) strings then need to be rehashed on each iteration, since we want to compute the hash of each term.<p>However, some string hashes, most commonly rolling hashes, allow the hash to be recomputed efficiently if part of the string is changed. Adjusting <eq><math><mrow><mtext></mtext><mi>repr</mi></mrow></math></eq> to return such a hash allows the rewrite <eq><math><mrow><mo form=prefix stretchy=false>[</mo><mi>x</mi><mo lspace=0.2222em rspace=0em>:</mo><mo lspace=0em>=</mo><mrow style="padding:0 0 0.1em 0;border-bottom:0.065em solid;"><mn>0</mn></mrow><mo form=postfix stretchy=false>]</mo></mrow></math></eq> to be performed directly on the hash. Consider in particular the polynomial hash parameterized by a constant <eq><math><mi>b</mi></math></eq>, chosen randomly, and a prime number <eq><math><mi>p</mi></math></eq>:<section><eqn><math style="display:block math;"class=tml-display display=block><mrow><mrow><mtext></mtext><mi>hash</mi></mrow><mo form=prefix stretchy=false>(</mo><msub><mi>c</mi><mn>0</mn></msub><msub><mi>c</mi><mn>1</mn></msub><mo>‚Ä¶</mo><msub><mi>c</mi><mrow><mi>n</mi><mo>‚àí</mo><mn>1</mn></mrow></msub><mo form=postfix stretchy=false>)</mo><mo>=</mo><mrow><munder><mo movablelimits=false>‚àë</mo><mi>i</mi></munder></mrow><msub><mi>c</mi><mi>i</mi></msub><msup><mi>b</mi><mi>i</mi></msup><mo></mo><mspace width=1em></mspace><mrow><mtext></mtext><mi>mod</mi></mrow><mspace width=0.1667em></mspace><mspace width=0.1667em></mspace><mi>p</mi><mi>.</mi></mrow></math></eqn></section><p>A character at index <eq><math><mi>i</mi></math></eq> can be changed from <eq><math><mi>x</mi></math></eq> to <eq><math><mi>y</mi></math></eq> by adding <eq><math><mrow><mo form=prefix stretchy=false>(</mo><mi>y</mi><mo>‚àí</mo><mi>x</mi><mo form=postfix stretchy=false>)</mo><msup><mi>b</mi><mi>i</mi></msup></mrow></math></eq> to the hash value. The hash of <eq><math><mrow><mi>Œª</mi><mi>.</mi><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>t</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> and the ‚Äúpatch‚Äù replacing each mention of <eq><math><mi>x</mi></math></eq> with a de Bruijn index can be computed separately and then merged at the abstraction, since the offset of a given variable mention within the corresponding abstraction can be calculated efficiently, and patches can be merged by adding them together.<p>An implementation of the algorithm is reproduced below. To avoid handling parentheses, we implicitly translate terms to postfix notation, denoting calls with <code>!</code>.<pre><code class=language-python><div class=expansible-code><input id=expansible1 type=checkbox><div class=highlighted>range_of_expr: <span class=hljs-built_in>dict</span>[Expr, <span class=hljs-built_in>tuple</span>[<span class=hljs-built_in>int</span>, <span class=hljs-built_in>int</span>]] = {}
variable_nesting: <span class=hljs-built_in>dict</span>[VariableName, <span class=hljs-built_in>int</span>] = {}
variable_accesses: <span class=hljs-built_in>dict</span>[VariableName, <span class=hljs-built_in>list</span>[<span class=hljs-built_in>tuple</span>[<span class=hljs-built_in>int</span>, <span class=hljs-built_in>int</span>]]] = {}
current_location: <span class=hljs-built_in>int</span> = <span class=hljs-number>0</span>

<span class=hljs-keyword>def</span> <span class="hljs-title function_">collect_locations</span>(<span class=hljs-params>expr: Expr, nesting: <span class=hljs-built_in>int</span></span>):
    <span class=hljs-keyword>global</span> current_location
    start = current_location
    <span class=hljs-keyword>match</span> expr:
        <span class=hljs-keyword>case</span> Variable(x):
            <span class=hljs-comment># x</span>
            current_location += <span class=hljs-number>1</span>
            variable_accesses[x].append((start, nesting - variable_nesting[x]))
        <span class=hljs-keyword>case</span> Abstraction(x, body):
            <span class=hljs-comment># body, \</span>
            variable_nesting[x] = nesting
            variable_accesses[x] = []
            collect_locations(body, nesting + <span class=hljs-number>1</span>)
            current_location += <span class=hljs-number>1</span>
        <span class=hljs-keyword>case</span> Application(f, a):
            <span class=hljs-comment># f, a, !</span>
            collect_locations(f, nesting)
            collect_locations(a, nesting)
            current_location += <span class=hljs-number>1</span>
    end = current_location
    range_of_expr[expr] = (start, end)

collect_locations(root, <span class=hljs-number>0</span>)

powers_of_b: <span class=hljs-built_in>list</span>[<span class=hljs-built_in>int</span>] = [<span class=hljs-number>1</span>]

<span class=hljs-comment># Computes `h * b ** count % p` in amortized constant time.</span>
<span class=hljs-keyword>def</span> <span class="hljs-title function_">shift</span>(<span class=hljs-params>h: <span class=hljs-built_in>int</span>, count: <span class=hljs-built_in>int</span></span>) -> <span class=hljs-built_in>int</span>:
    <span class=hljs-keyword>while</span> <span class=hljs-built_in>len</span>(powers_of_b) <= count:
        powers_of_b.append(powers_of_b[-<span class=hljs-number>1</span>] * b % p)
    <span class=hljs-keyword>return</span> h * powers_of_b[count] % p

<span class=hljs-comment># Functions capable of hashing variable names, de Bruijn indices, and the characters \, ! without</span>
<span class=hljs-comment># collisions.</span>
<span class=hljs-keyword>def</span> <span class="hljs-title function_">hash_lambda</span>() -> <span class=hljs-built_in>int</span>: <span class=hljs-keyword>return</span> <span class=hljs-number>1</span>
<span class=hljs-keyword>def</span> <span class="hljs-title function_">hash_call</span>() -> <span class=hljs-built_in>int</span>: <span class=hljs-keyword>return</span> <span class=hljs-number>2</span>
<span class=hljs-keyword>def</span> <span class="hljs-title function_">hash_variable_name</span>(<span class=hljs-params>x: VariableName</span>) -> <span class=hljs-built_in>int</span>: <span class=hljs-keyword>return</span> x.int_id * <span class=hljs-number>2</span> + <span class=hljs-number>3</span>
<span class=hljs-keyword>def</span> <span class="hljs-title function_">hash_de_bruijn_index</span>(<span class=hljs-params>i: <span class=hljs-built_in>int</span></span>) -> <span class=hljs-built_in>int</span>: <span class=hljs-keyword>return</span> i * <span class=hljs-number>2</span> + <span class=hljs-number>4</span>

<span class=hljs-keyword>def</span> <span class="hljs-title function_">calculate_hashes</span>(<span class=hljs-params>expr: Expr</span>) -> <span class=hljs-built_in>int</span>:
    start, end = range_of_expr[expr]
    <span class=hljs-keyword>match</span> expr:
        <span class=hljs-keyword>case</span> Variable(x):
            h = hash_variable_name(x)
        <span class=hljs-keyword>case</span> Abstraction(x, body):
            h = calculate_hashes(body) + shift(hash_lambda(), end - start - <span class=hljs-number>1</span>)
            <span class=hljs-keyword>for</span> location, de_bruijn_index <span class=hljs-keyword>in</span> variable_accesses[x]:
                h += shift(
                    hash_de_bruijn_index(de_bruijn_index) - hash_variable_name(x),
                    location - start,
                )
                h %= p
        <span class=hljs-keyword>case</span> Application(f, a):
            h = (
                calculate_hashes(f)
                + shift(calculate_hashes(a), range_of_expr[a][<span class=hljs-number>0</span>] - start)
                + shift(hash_call(), end - start - <span class=hljs-number>1</span>)
            )
    h %= p
    <span class=hljs-built_in>print</span>(<span class=hljs-string>"The hash of"</span>, expr, <span class=hljs-string>"is"</span>, h)
    <span class=hljs-keyword>return</span> h

calculate_hashes(root)
</div><label for=expansible1>Expand</label></div></code></pre><p>The probabilistic guarantees of this scheme depend entirely on the choice of the hash. The collision probability of rolling hashes typically scales linearly with the length of the input. In this case, the length of the input exactly matches the number of subterms <eq><math><mi>n</mi></math></eq>, and each element of the input is a <eq><math><mrow><mrow><mi>log</mi><mo>‚Å°</mo><mspace width=0.1667em></mspace></mrow><mi>n</mi><mo>+</mo></mrow><mrow><mi class=mathcal>ùí™</mi><mo form=prefix stretchy=false>(</mo><mn>1</mn><mo form=postfix stretchy=false>)</mo></mrow></math></eq>-bit number (assuming binary logarithm from now on).<p>For polynomial hashes, the collision probability is <eq><math><mrow><mo>‚â§</mo></mrow><mrow><mfrac><mrow><mi>n</mi><mo>‚àí</mo><mn>1</mn></mrow><mi>p</mi></mfrac></mrow></math></eq>, assuming <eq><math><mi>b</mi></math></eq> is chosen randomly. If <eq><math><mi>b</mi></math></eq> is instead fixed and <eq><math><mi>p</mi></math></eq> is chosen randomly, the probability is <eq><math><mrow><mo>‚â§</mo></mrow><mrow><mi>C</mi><mfrac><mrow><mi>n</mi><mrow><mspace width=0.1667em></mspace><mi>log</mi><mo>‚Å°</mo><mspace width=0.1667em></mspace></mrow><mi>n</mi></mrow><mi>p</mi></mfrac></mrow></math></eq>, where <eq><math><mi>C</mi></math></eq> depends on how wide the range <eq><math><mi>p</mi></math></eq> is chosen from is. For Rabin fingerprints, the probability is <eq><math><mrow><mo>‚â≤</mo></mrow><mrow><mfrac><mrow><mi>n</mi><mrow><mspace width=0.1667em></mspace><mi>log</mi><mo>‚Å°</mo><mspace width=0.1667em></mspace></mrow><mi>n</mi></mrow><msup><mn>2</mn><mrow><mrow><mspace width=0.1667em></mspace><mi>deg</mi><mo>‚Å°</mo><mspace width=0.1667em></mspace></mrow><mi>p</mi><mo form=prefix stretchy=false>(</mo><mi>x</mi><mo form=postfix lspace=0em rspace=0em stretchy=false>)</mo></mrow></msup></mfrac></mrow></math></eq>.<p>Since there are <eq><math><mfrac><mrow><mi>n</mi><mo form=prefix stretchy=false>(</mo><mi>n</mi><mo>‚àí</mo><mn>1</mn><mo form=postfix lspace=0em rspace=0em stretchy=false>)</mo></mrow><mn>2</mn></mfrac></math></eq> possibly colliding pairs of terms, the probability of at least one collision among all terms is, for polynomial hashes, bounded from above by:<section><eqn><math style="display:block math;"class=tml-display display=block><mrow><mi>P</mi><mo>‚â§</mo><mfrac><mrow><mi>n</mi><mo>‚àí</mo><mn>1</mn></mrow><mi>p</mi></mfrac><mo>‚ãÖ</mo><mfrac><mrow><mi>n</mi><mo form=prefix stretchy=false>(</mo><mi>n</mi><mo>‚àí</mo><mn>1</mn><mo form=postfix lspace=0em rspace=0em stretchy=false>)</mo></mrow><mn>2</mn></mfrac><mo>‚â§</mo><mfrac><msup><mi>n</mi><mn>3</mn></msup><mrow><mn>2</mn><mi>p</mi></mrow></mfrac><mi>.</mi></mrow></math></eqn></section><p class=next-group><span aria-level=3 class=side-header role=heading><span>Verification</span></span>To verify that the computed hashes don‚Äôt produce collisions, we group terms by their hashes and validate that in each group of size <eq><math><mrow><mo>‚â•</mo></mrow><mrow><mn>2</mn></mrow></math></eq>, all terms are <eq><math><mi>Œ±</mi></math></eq>-equivalent. We first check that terms within each group have equal sizes (i.e. the number of subterms, denoted <eq><math><mrow><mo fence=true form=prefix>|</mo><mi>t</mi><mo fence=true form=postfix>|</mo></mrow></math></eq>), and then iterate over groups in order of increasing size. This ensures that while validating terms of size <eq><math><mi>n</mi></math></eq>, terms of sizes <eq><math><mrow><mi>m</mi><mo><</mo></mrow><mrow><mi>n</mi></mrow></math></eq> can be compared for <eq><math><mi>Œ±</mi></math></eq>-equivalence by hash.<p>We now introduce some terminology.<ul><li><p>We call subterms with non-unique hashes (i.e. subterms that are not alone in their groups) <em>pivots</em>.</p><li><p>We say an optimized predicate for <eq><math><mi>Œ±</mi></math></eq>-equivalence is <em>sound</em> if it implies <eq><math><mi>Œ±</mi></math></eq>-equivalence, and <em>complete</em> if it is implied by <eq><math><mi>Œ±</mi></math></eq>-equivalence.</p><li><p>For a term <eq><math><mi>t</mi></math></eq> and a subterm <eq><math><mi>u</mi></math></eq>, we define the <em>path</em> from <eq><math><mi>t</mi></math></eq> to <eq><math><mi>u</mi></math></eq> (written <eq><math><mrow><mi>t</mi><mo>‚áù</mo></mrow><mrow><mi>u</mi></mrow></math></eq>) as a (possibly empty) string of characters <eq><math><mo lspace=0em rspace=0em stretchy=false>‚Üì</mo></math></eq>, <eq><math><mo lspace=0em rspace=0em stretchy=false>‚Üô</mo></math></eq>, <eq><math><mo lspace=0em rspace=0em stretchy=false>‚Üò</mo></math></eq>, where <eq><math><mo lspace=0em rspace=0em stretchy=false>‚Üì</mo></math></eq> means ‚Äúproceed into the body of the abstraction‚Äù and <eq><math><mo lspace=0em rspace=0em stretchy=false>‚Üô</mo></math></eq>/<eq><math><mo lspace=0em rspace=0em stretchy=false>‚Üò</mo></math></eq> mean ‚Äúproceed into the function/argument of the application‚Äù respectively. For fixed <eq><math><mi>t</mi></math></eq>, valid paths map bijectively to subterms of <eq><math><mi>t</mi></math></eq>.</p><li><p>For a term <eq><math><mi>t</mi></math></eq> and a subterm <eq><math><mi>u</mi></math></eq>, we denote by <eq><math><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>u</mi><mi>/</mi><mi>t</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> a representation of <eq><math><mi>u</mi></math></eq> that encodes variable mentions as follows:</p> <ul><li>Variables bound in <eq><math><mi>u</mi></math></eq> use de Bruijn indices.<li>Variables free in <eq><math><mi>t</mi></math></eq> use names.<li>Variables bound in <eq><math><mi>t</mi></math></eq> but free in <eq><math><mi>u</mi></math></eq> use paths from <eq><math><mi>t</mi></math></eq> to the declaring abstraction.</ul> <p>Note that <eq><math><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>t</mi><mi>/</mi><mi>t</mi><mo form=postfix stretchy=false>)</mo><mo>=</mo></mrow><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>t</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq>. The act of writing <eq><math><mrow><mi>u</mi><mi>/</mi><mi>t</mi></mrow></math></eq> implicitly states that <eq><math><mi>u</mi></math></eq> is a subterm of <eq><math><mi>t</mi></math></eq> akin to <eq><math><mfrac><mi>x</mi><mi>y</mi></mfrac></math></eq> implying <eq><math><mrow><mi>y</mi><mo>‚â†</mo></mrow><mrow><mn>0</mn></mrow></math></eq> in arithmetic.</p><li><p>We write <eq><math><mrow><msub><mi>e</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>e</mi><mn>2</mn></msub></mrow></math></eq>, where each <eq><math><msub><mi>e</mi><mi>i</mi></msub></math></eq> is either <eq><math><msub><mi>u</mi><mi>i</mi></msub></math></eq> or <eq><math><mrow><msub><mi>u</mi><mi>i</mi></msub><mi>/</mi><msub><mi>t</mi><mi>i</mi></msub></mrow></math></eq> independently, if <eq><math><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><msub><mi>e</mi><mn>1</mn></msub><mo form=postfix stretchy=false>)</mo><mo>=</mo></mrow><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><msub><mi>e</mi><mn>2</mn></msub><mo form=postfix stretchy=false>)</mo></mrow></math></eq>. For example, <eq><math><mrow><mi>x</mi><mi>/</mi><mi>Œª</mi><mi>x</mi><mi>.</mi><mi>x</mi><mo>‚àº</mo></mrow><mrow><mi>y</mi><mi>/</mi><mi>Œª</mi><mi>y</mi><mi>.</mi><mi>y</mi></mrow></math></eq> even though <eq><math><mrow><mi>x</mi><mo>‚àºÃ∏</mo></mrow><mrow><mi>y</mi></mrow></math></eq>.</p></ul><p>We rely on the following propositions:<ol><li><p>If <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub></mrow></math></eq> and <eq><math><mrow><mrow><mo fence=true form=prefix>|</mo><msub><mi>t</mi><mn>1</mn></msub><mo fence=true form=postfix>|</mo></mrow><mo>=</mo></mrow><mrow><mrow><mo fence=true form=prefix>|</mo><msub><mi>t</mi><mn>2</mn></msub><mo fence=true form=postfix>|</mo></mrow></mrow></math></eq> are distinct terms, then <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub><mi>/</mi><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq>. Indeed, <eq><math><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><msub><mi>u</mi><mn>1</mn></msub><mo form=postfix stretchy=false>)</mo></mrow></math></eq> differs from <eq><math><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><msub><mi>u</mi><mn>1</mn></msub><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub><mo form=postfix stretchy=false>)</mo></mrow></math></eq> at mentions of variables that are free in <eq><math><msub><mi>u</mi><mn>1</mn></msub></math></eq> but bound in <eq><math><msub><mi>t</mi><mn>1</mn></msub></math></eq>. But since <eq><math><msub><mi>t</mi><mn>1</mn></msub></math></eq> and <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq> have the same size, they don‚Äôt share subterms, so <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub></mrow></math></eq> implies <eq><math><msub><mi>u</mi><mn>1</mn></msub></math></eq> doesn‚Äôt mention any variables bound in <eq><math><msub><mi>t</mi><mn>1</mn></msub></math></eq> but not <eq><math><msub><mi>u</mi><mn>1</mn></msub></math></eq>. Hence <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub><mi>/</mi><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq>.</p><li><p>If <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub><mi>/</mi><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq> and there is a <eq><math><mrow><msubsup><mi>u</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>1</mn></msub></mrow></math></eq> that isn‚Äôt a subterm of <eq><math><msub><mi>t</mi><mn>1</mn></msub></math></eq>, then <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub></mrow></math></eq>. Indeed, <eq><math><msubsup><mi>u</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq> cannot mention variables declared within <eq><math><msub><mi>t</mi><mn>1</mn></msub></math></eq>, so <eq><math><msub><mi>u</mi><mn>1</mn></msub></math></eq> can also only mention free variables declared outside <eq><math><msub><mi>t</mi><mn>1</mn></msub></math></eq>, hence <eq><math><msub><mi>u</mi><mn>2</mn></msub></math></eq> can also only mention free variables declared outside <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq>; thus <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>1</mn></msub><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub><mi>/</mi><msub><mi>t</mi><mn>2</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub></mrow></math></eq>.</p><li><p>If <eq><math><mrow><mi>u</mi><mo>‚àº</mo></mrow><mrow><msup><mi>u</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></mrow></math></eq>, then <eq><math><mrow><mi>u</mi><mi>/</mi><mi>t</mi><mo>‚àº</mo></mrow><mrow><msup><mi>u</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup><mi>/</mi><mi>t</mi></mrow></math></eq>. Indeed, <eq><math><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>u</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> differs from <eq><math><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>u</mi><mi>/</mi><mi>t</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> at variables that are free in <eq><math><mi>u</mi></math></eq>, but bound in <eq><math><mi>t</mi></math></eq>. Such variables are accessed by name in <eq><math><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>u</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq>, so by <eq><math><mrow><mi>u</mi><mo>‚àº</mo></mrow><mrow><msup><mi>u</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></mrow></math></eq> they must be accessed by the same name in <eq><math><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><msup><mi>u</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup><mo form=postfix stretchy=false>)</mo></mrow></math></eq> and correspond to the same declaring abstraction <eq><math><mi>a</mi></math></eq>. Since the same <eq><math><mi>t</mi></math></eq> is used in <eq><math><mrow><mi>u</mi><mi>/</mi><mi>t</mi></mrow></math></eq> and <eq><math><mrow><msup><mi>u</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup><mi>/</mi><mi>t</mi></mrow></math></eq>, the same path <eq><math><mrow><mi>t</mi><mo>‚áù</mo></mrow><mrow><mi>a</mi></mrow></math></eq> will be used in both <eq><math><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>u</mi><mi>/</mi><mi>t</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> and <eq><math><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><msup><mi>u</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup><mi>/</mi><mi>t</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq>.</p><li><p>If <eq><math><mrow><mi>u</mi><mi>/</mi><mi>t</mi><mo>‚àº</mo></mrow><mrow><msup><mi>u</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup><mi>/</mi><mi>t</mi></mrow></math></eq>, then <eq><math><mrow><mi>u</mi><mo>‚àº</mo></mrow><mrow><msup><mi>u</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></mrow></math></eq>. Indeed, <eq><math><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>u</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> differs from <eq><math><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>u</mi><mi>/</mi><mi>t</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> at variables that are free in <eq><math><mi>u</mi></math></eq>, but bound in <eq><math><mi>t</mi></math></eq>. Since such variables are accessed by path in <eq><math><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>u</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq>, by <eq><math><mrow><mi>u</mi><mo>‚àº</mo></mrow><mrow><msup><mi>u</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></mrow></math></eq> they must be accessed by the same path in <eq><math><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><msup><mi>u</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup><mo form=postfix stretchy=false>)</mo></mrow></math></eq>. Since the same <eq><math><mi>t</mi></math></eq> is used in <eq><math><mrow><mi>u</mi><mi>/</mi><mi>t</mi></mrow></math></eq> and <eq><math><mrow><msup><mi>u</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup><mi>/</mi><mi>t</mi></mrow></math></eq>, this path denotes the same abstraction <eq><math><mi>a</mi></math></eq> in both cases, and so <eq><math><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>u</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> and <eq><math><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><msup><mi>u</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup><mo form=postfix stretchy=false>)</mo></mrow></math></eq> will include the same name (namely, the name of <eq><math><mi>a</mi></math></eq>).</p><li><p>If <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub><mi>/</mi><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq>, <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msubsup><mi>u</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></mrow></math></eq>, and <eq><math><mrow><msub><mi>u</mi><mn>2</mn></msub><mo>‚àº</mo></mrow><mrow><msubsup><mi>u</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></mrow></math></eq>, then <eq><math><mrow><msubsup><mi>u</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msubsup><mi>u</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mi>/</mi><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq>. Indeed, by proposition 3 we have <eq><math><mrow><msubsup><mi>u</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>1</mn></msub><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub></mrow></math></eq> and <eq><math><mrow><msub><mi>u</mi><mn>2</mn></msub><mi>/</mi><msub><mi>t</mi><mn>2</mn></msub><mo>‚àº</mo></mrow><mrow><msubsup><mi>u</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mi>/</mi><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq>, from which the statement follows by transitivity.</p><li><p>If <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub><mi>/</mi><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq>, <eq><math><mrow><msubsup><mi>u</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msubsup><mi>u</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mi>/</mi><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq>, and <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msubsup><mi>u</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></mrow></math></eq>, then <eq><math><mrow><msub><mi>u</mi><mn>2</mn></msub><mo>‚àº</mo></mrow><mrow><msubsup><mi>u</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></mrow></math></eq>. Indeed, by proposition 3 we have <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msubsup><mi>u</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub></mrow></math></eq>, thus <eq><math><mrow><msub><mi>u</mi><mn>2</mn></msub><mi>/</mi><msub><mi>t</mi><mn>2</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>1</mn></msub><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msubsup><mi>u</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msubsup><mi>u</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mi>/</mi><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq>, from which by proposition 4 <eq><math><mrow><msub><mi>u</mi><mn>2</mn></msub><mo>‚àº</mo></mrow><mrow><msubsup><mi>u</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></mrow></math></eq>.</p><li><p>If <eq><math><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq> and <eq><math><mrow><mo form=prefix stretchy=false>(</mo><msub><mi>t</mi><mn>1</mn></msub><mo>‚áù</mo><msub><mi>u</mi><mn>1</mn></msub><mo form=postfix stretchy=false>)</mo><mo>=</mo></mrow><mrow><mo form=prefix stretchy=false>(</mo><msub><mi>t</mi><mn>2</mn></msub><mo>‚áù</mo><msub><mi>u</mi><mn>2</mn></msub><mo form=postfix stretchy=false>)</mo></mrow></math></eq>, then <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub><mi>/</mi><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq>. Indeed, <eq><math><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><msub><mi>u</mi><mn>1</mn></msub><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub><mo form=postfix stretchy=false>)</mo></mrow></math></eq> and <eq><math><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><msub><mi>u</mi><mn>2</mn></msub><mi>/</mi><msub><mi>t</mi><mn>2</mn></msub><mo form=postfix stretchy=false>)</mo></mrow></math></eq> are identical substrings of the string <eq><math><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><msub><mi>t</mi><mn>1</mn></msub><mo form=postfix stretchy=false>)</mo><mo>=</mo></mrow><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><msub><mi>t</mi><mn>2</mn></msub><mo form=postfix stretchy=false>)</mo></mrow></math></eq>.</p><li><p>If <eq><math><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq> and <eq><math><msub><mi>u</mi><mn>1</mn></msub></math></eq> is a subterm of <eq><math><msub><mi>t</mi><mn>1</mn></msub></math></eq>, there exists a subterm <eq><math><msub><mi>u</mi><mn>2</mn></msub></math></eq> of <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq> such that <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub><mi>/</mi><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq>. Indeed, by <eq><math><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq> the terms <eq><math><msub><mi>t</mi><mn>1</mn></msub></math></eq> and <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq> have identical tree structure, so the path <eq><math><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>‚áù</mo></mrow><mrow><msub><mi>u</mi><mn>1</mn></msub></mrow></math></eq> is valid in both <eq><math><msub><mi>t</mi><mn>1</mn></msub></math></eq> and <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq>. Rerooting it at <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq>, we obtain an identical path <eq><math><mrow><msub><mi>t</mi><mn>2</mn></msub><mo>‚áù</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub></mrow></math></eq>, and by proposition 7 <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub><mi>/</mi><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq>.</p><li><p>If a path <eq><math><mrow><mi>t</mi><mo>‚áù</mo></mrow><mrow><mi>p</mi></mrow></math></eq> does not contain any pivots except <eq><math><mi>t</mi></math></eq> and <eq><math><mi>p</mi></math></eq>, <eq><math><mrow><msup><mi>p</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup><mo>‚àº</mo></mrow><mrow><mi>p</mi></mrow></math></eq> is a distinct term from <eq><math><mi>p</mi></math></eq>, and a path <eq><math><mrow><mi>t</mi><mo>‚áù</mo></mrow><mrow><mi>u</mi><mo>‚áù</mo></mrow><mrow><msup><mi>p</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></mrow></math></eq> exists, where <eq><math><mi>u</mi></math></eq> is a pivot, then <eq><math><mi>p</mi></math></eq> is not a subterm of <eq><math><mi>u</mi></math></eq>. Indeed, <eq><math><mi>p</mi></math></eq> cannot be a strict subterm of <eq><math><mi>u</mi></math></eq> because <eq><math><mrow><mi>t</mi><mo>‚áù</mo></mrow><mrow><mi>p</mi></mrow></math></eq> would contain another pivot <eq><math><mi>u</mi></math></eq>. <eq><math><mrow><mi>p</mi><mo>=</mo></mrow><mrow><mi>u</mi></mrow></math></eq> is also impossible, since <eq><math><mrow><msup><mi>p</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup><mo>‚àº</mo></mrow><mrow><mi>p</mi></mrow></math></eq> would have to be a strict subterm of <eq><math><mi>p</mi></math></eq> due to <eq><math><mrow><mi>p</mi><mo>‚â†</mo></mrow><mrow><msup><mi>p</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></mrow></math></eq>, but a term can never be <eq><math><mi>Œ±</mi></math></eq>-equivalent to its strict subterm.</p></ol><p>To verify <eq><math><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq>, where <eq><math><msub><mi>t</mi><mn>1</mn></msub></math></eq> and <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq> are from the same group, we set <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mo>=</mo></mrow><mrow><msub><mi>t</mi><mn>1</mn></msub><mo separator=true>,</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub><mo>=</mo></mrow><mrow><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq> and assert <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub><mi>/</mi><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq> recursively. At each step, we repeatedly verify that <eq><math><msub><mi>u</mi><mn>1</mn></msub></math></eq> and <eq><math><msub><mi>u</mi><mn>2</mn></msub></math></eq> are subterms of the same ‚Äúkind‚Äù (variable/abstraction/application) and recurse, adjusting <eq><math><msub><mi>u</mi><mn>1</mn></msub></math></eq> and <eq><math><msub><mi>u</mi><mn>2</mn></msub></math></eq> accordingly. We apply two optimizations to ensure the time complexity is subquadratic. For every step except the first, if <eq><math><msub><mi>u</mi><mn>2</mn></msub></math></eq> is a pivot:<ul><li><p>If <eq><math><msub><mi>u</mi><mn>2</mn></msub></math></eq> has an <eq><math><mi>Œ±</mi></math></eq>-equivalent copy outside <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq>, we immediately assert <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub></mrow></math></eq> by hash and don‚Äôt recurse into <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub><mi>/</mi><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq>. This is sound by proposition 1 and complete by proposition 2.</p><li><p>Otherwise, we look for copies of <eq><math><msub><mi>u</mi><mn>2</mn></msub></math></eq> within <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq> (there must be at least one more copy). If this is the first copy we‚Äôve seen during the current comparison, we recurse into <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mi>/</mi><msub><mi>t</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub><mi>/</mi><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq> and record the mapping <eq><math><mrow><msub><mi>u</mi><mn>2</mn></msub><mo>‚Ü¶</mo></mrow><mrow><msub><mi>u</mi><mn>1</mn></msub></mrow></math></eq>. If there is an earlier copy <eq><math><msubsup><mi>u</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq> mapping to <eq><math><msubsup><mi>u</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq>, we assert <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msubsup><mi>u</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></mrow></math></eq> by hash and don‚Äôt recurse. This is sound by proposition 5 and complete by proposition 6.</p></ul><p>Note that in the latter case, if <eq><math><msub><mi>u</mi><mn>2</mn></msub></math></eq> is entered, it‚Äôs guaranteed to be the first copy in DFS order not only among visited terms, but among all terms. Indeed, suppose the earliest copy <eq><math><msubsup><mi>u</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq> was skipped because some of its ancestor pivots <eq><math><mi>p</mi></math></eq> wasn‚Äôt visited. There could be two reasons for that:<ul><li><p><eq><math><mi>p</mi></math></eq> has a copy <eq><math><msup><mi>p</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></math></eq> outside <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq>. By proposition 8, there exists <eq><math><msubsup><mi>u</mi><mn>2</mn><mrow><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></mrow></msubsup></math></eq> in <eq><math><msup><mi>p</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></math></eq> such that <eq><math><mrow><msubsup><mi>u</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mi>/</mi><mi>p</mi><mo>‚àº</mo></mrow><mrow><msubsup><mi>u</mi><mn>2</mn><mrow><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></mrow></msubsup><mi>/</mi><msup><mi>p</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></mrow></math></eq>. Since <eq><math><mrow><msubsup><mi>u</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub></mrow></math></eq> and <eq><math><msub><mi>u</mi><mn>2</mn></msub></math></eq> is not a subterm of <eq><math><mi>p</mi></math></eq>, by proposition 2 <eq><math><mrow><msubsup><mi>u</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mo>‚àº</mo></mrow><mrow><msubsup><mi>u</mi><mn>2</mn><mrow><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></mrow></msubsup></mrow></math></eq>. Since <eq><math><msubsup><mi>u</mi><mn>2</mn><mrow><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></mrow></msubsup></math></eq> is outside <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq> and <eq><math><mrow><msub><mi>u</mi><mn>2</mn></msub><mo>‚àº</mo></mrow><mrow><msubsup><mi>u</mi><mn>2</mn><mrow><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></mrow></msubsup></mrow></math></eq>, <eq><math><msub><mi>u</mi><mn>2</mn></msub></math></eq> could not be entered.</p><li><p><eq><math><mi>p</mi></math></eq> has an earlier copy <eq><math><msup><mi>p</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></math></eq> inside <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq>. Repeat the process from the previous paragraph, finding <eq><math><mrow><msubsup><mi>u</mi><mn>2</mn><mrow><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></mrow></msubsup><mo>‚àº</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub></mrow></math></eq>. This <eq><math><msubsup><mi>u</mi><mn>2</mn><mrow><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></mrow></msubsup></math></eq> is earlier than <eq><math><msubsup><mi>u</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq>, so <eq><math><msubsup><mi>u</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq> could not be the earliest copy of <eq><math><msub><mi>u</mi><mn>2</mn></msub></math></eq>.</p></ul><p>An implementation of this algorithm follows.<pre><code class=language-python><span class=hljs-keyword>def</span> <span class="hljs-title function_">compare</span>(<span class=hljs-params>u1: Term, t1: Term, u2: Term, t2: Term, h21: <span class=hljs-built_in>dict</span>[<span class=hljs-built_in>int</span>, <span class=hljs-built_in>int</span>]</span>) -> <span class=hljs-built_in>bool</span>:
    <span class=hljs-keyword>if</span> (u2 <span class=hljs-keyword>is</span> <span class=hljs-keyword>not</span> t2) <span class=hljs-keyword>and</span> (u2 <span class=hljs-keyword>is</span> a pivot):
        <span class=hljs-keyword>if</span> there <span class=hljs-keyword>is</span> <span class=hljs-built_in>any</span> term alpha-equivalent to u2 outside t2:
            <span class=hljs-keyword>return</span> <span class=hljs-built_in>hash</span>[u1] == <span class=hljs-built_in>hash</span>[u2]
        <span class=hljs-keyword>if</span> <span class=hljs-built_in>hash</span>[u2] <span class=hljs-keyword>in</span> h21:
            <span class=hljs-keyword>return</span> h21[<span class=hljs-built_in>hash</span>[u2]] == <span class=hljs-built_in>hash</span>[u1]
        h21[<span class=hljs-built_in>hash</span>[u2]] = <span class=hljs-built_in>hash</span>[u1]

    <span class=hljs-keyword>match</span> (u1, u2):
        <span class=hljs-keyword>case</span> (Variable(x1), Variable(x2)):
            x1 = (x1 <span class=hljs-keyword>as</span> de Bruijn index) <span class=hljs-keyword>if</span> x1 defined within t1 <span class=hljs-keyword>else</span> (x1 <span class=hljs-keyword>as</span> name)
            x2 = (x2 <span class=hljs-keyword>as</span> de Bruijn index) <span class=hljs-keyword>if</span> x2 defined within t2 <span class=hljs-keyword>else</span> (x2 <span class=hljs-keyword>as</span> name)
            <span class=hljs-keyword>return</span> x1 == x2
        <span class=hljs-keyword>case</span> (Application(u11, u12), Application(u21, u22)):
            <span class=hljs-keyword>return</span> compare(u11, t1, u21, t2, h21) <span class=hljs-keyword>and</span> compare(u12, t1, u22, t2, h21)
        <span class=hljs-keyword>case</span> (Abstraction(_, v1), Abstraction(_, v2)):
            <span class=hljs-keyword>return</span> compare(v1, t1, v2, t2, h21)
        <span class=hljs-keyword>case</span> _:
            <span class=hljs-keyword>return</span> <span class=hljs-literal>False</span>

<span class=hljs-keyword>def</span> <span class="hljs-title function_">verify_hashes</span>():
    <span class=hljs-comment># Not implemented: validate that, within each class, all terms have the same size.</span>
    <span class=hljs-comment># Not implemented: sort classes by increasing size of terms.</span>
    <span class=hljs-keyword>for</span> class_members <span class=hljs-keyword>in</span> classes:
        t1 = class_members[<span class=hljs-number>0</span>]
        <span class=hljs-keyword>for</span> t2 <span class=hljs-keyword>in</span> class_members[<span class=hljs-number>1</span>:]:
            <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> compare(t1, t1, t2, t2, {}):
                <span class=hljs-keyword>return</span> <span class=hljs-literal>False</span>
    <span class=hljs-keyword>return</span> <span class=hljs-literal>True</span>
</code></pre><p>It turns out that this algorithm takes linear time. We will now prove this.<p>The pair <eq><math><mrow><mo form=prefix stretchy=false>(</mo><msub><mi>u</mi><mn>2</mn></msub><mo separator=true>,</mo><msub><mi>t</mi><mn>2</mn></msub><mo form=postfix stretchy=false>)</mo></mrow></math></eq> uniquely determines a particular invocation of <code>compare</code>. Split such invocations into two categories depending on whether the path <eq><math><mrow><msub><mi>t</mi><mn>2</mn></msub><mo>‚áù</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub></mrow></math></eq> contains any pivots except <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq> and possibly <eq><math><msub><mi>u</mi><mn>2</mn></msub></math></eq>. For visited pairs without such pivots, <eq><math><msub><mi>u</mi><mn>2</mn></msub></math></eq> determines <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq> almost uniquely: if <eq><math><msub><mi>u</mi><mn>2</mn></msub></math></eq> is not a pivot, <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq> is the closest pivot ancestor; otherwise it‚Äôs either such an ancestor or <eq><math><msub><mi>u</mi><mn>2</mn></msub></math></eq> itself. This means that the number of visited pairs without pivots inbetween is <eq><math><mrow><mo>‚â§</mo></mrow><mrow><mn>2</mn><mi>n</mi><mo>=</mo></mrow><mrow><mi class=mathcal>ùí™</mi><mo form=prefix stretchy=false>(</mo><mi>n</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq>. We will now prove that the number of visited pairs with pivots is also linear with amortized analysis.<p>Consider any path <eq><math><mrow><msub><mi>t</mi><mn>2</mn></msub><mo>‚áù</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub></mrow></math></eq> that does contain an additional pivot. Call the highest such pivot <eq><math><mi>p</mi></math></eq>, so that <eq><math><mrow><msub><mi>t</mi><mn>2</mn></msub><mo>‚áù</mo></mrow><mrow><mi>p</mi></mrow></math></eq> is non-empty and pivot-free except for <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq> and <eq><math><mi>p</mi></math></eq>, and <eq><math><mrow><mi>p</mi><mo>‚áù</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub></mrow></math></eq> is non-empty. Since <eq><math><mrow><mi>p</mi><mo>‚áù</mo></mrow><mrow><msub><mi>u</mi><mn>2</mn></msub></mrow></math></eq> is non-empty, the pivot <eq><math><mi>p</mi></math></eq> must have been recursed into, which only happens if <eq><math><mi>p</mi></math></eq> has no copies outside <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq> and is the earliest copy within <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq>. Call the immediately next copy in DFS order <eq><math><msup><mi>p</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></math></eq>. Since <eq><math><mrow><msup><mi>p</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup><mo>‚àº</mo></mrow><mrow><mi>p</mi></mrow></math></eq>, <eq><math><msup><mi>p</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></math></eq> and <eq><math><mi>p</mi></math></eq> have the same tree structure and we can find <eq><math><msubsup><mi>u</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq> such that <eq><math><mrow><mo form=prefix stretchy=false>(</mo><msup><mi>p</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup><mo>‚áù</mo><msubsup><mi>u</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mo form=postfix stretchy=false>)</mo><mo>=</mo></mrow><mrow><mo form=prefix stretchy=false>(</mo><mi>p</mi><mo>‚áù</mo><msub><mi>u</mi><mn>2</mn></msub><mo form=postfix stretchy=false>)</mo></mrow></math></eq>. We ‚Äúpay‚Äù for entering the pair <eq><math><mrow><mo form=prefix stretchy=false>(</mo><msub><mi>u</mi><mn>2</mn></msub><mo separator=true>,</mo><msub><mi>t</mi><mn>2</mn></msub><mo form=postfix stretchy=false>)</mo></mrow></math></eq> with <eq><math><msubsup><mi>u</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq> and will now demonstrate that all visited pairs pay with different terms, which implies linearity.<p>Suppose that there are two pairs that pay with the same <eq><math><msup><mi>u</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></math></eq>: <eq><math><mrow><mo form=prefix stretchy=false>(</mo><msub><mi>u</mi><mn>1</mn></msub><mo separator=true>,</mo><msub><mi>t</mi><mn>1</mn></msub><mo form=postfix stretchy=false>)</mo></mrow></math></eq> with highest pivot <eq><math><msub><mi>p</mi><mn>1</mn></msub></math></eq> with next copy <eq><math><msubsup><mi>p</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq>, and <eq><math><mrow><mo form=prefix stretchy=false>(</mo><msub><mi>u</mi><mn>2</mn></msub><mo separator=true>,</mo><msub><mi>t</mi><mn>2</mn></msub><mo form=postfix stretchy=false>)</mo></mrow></math></eq> with highest pivot <eq><math><msub><mi>p</mi><mn>2</mn></msub></math></eq> with next copy <eq><math><msubsup><mi>p</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq>. <eq><math><msup><mi>u</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></math></eq> is a subterm of all of <eq><math><mrow><msub><mi>t</mi><mn>1</mn></msub><mo separator=true>,</mo></mrow><mrow><msub><mi>t</mi><mn>2</mn></msub><mo separator=true>,</mo></mrow><mrow><msubsup><mi>p</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mo separator=true>,</mo></mrow><mrow><msubsup><mi>p</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></mrow></math></eq>, so there is a linear order on these four terms. Without loss of generality, assume <eq><math><msub><mi>t</mi><mn>1</mn></msub></math></eq> is an ancestor of <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq>. There are three linear orders matching <eq><math><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>‚â∫</mo></mrow><mrow><msub><mi>t</mi><mn>2</mn></msub></mrow></math></eq>, <eq><math><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>‚â∫</mo></mrow><mrow><msubsup><mi>p</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></mrow></math></eq>, <eq><math><mrow><msub><mi>t</mi><mn>2</mn></msub><mo>‚â∫</mo></mrow><mrow><msubsup><mi>p</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></mrow></math></eq> (note that we aren‚Äôt assuming that all terms in this order are distinct):<ol><li><p><eq><math><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>‚â∫</mo></mrow><mrow><msub><mi>t</mi><mn>2</mn></msub><mo>‚â∫</mo></mrow><mrow><msubsup><mi>p</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mo>‚â∫</mo></mrow><mrow><msubsup><mi>p</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></mrow></math></eq>. By proposition 9, <eq><math><msub><mi>p</mi><mn>2</mn></msub></math></eq> is not a subterm of <eq><math><msubsup><mi>p</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq>. By proposition 8, there is <eq><math><mi>q</mi></math></eq> such that <eq><math><mrow><msubsup><mi>p</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mi>/</mi><msubsup><mi>p</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mo>‚àº</mo></mrow><mrow><mi>q</mi><mi>/</mi><msub><mi>p</mi><mn>1</mn></msub></mrow></math></eq>. Since <eq><math><mrow><msub><mi>p</mi><mn>2</mn></msub><mo>‚àº</mo></mrow><mrow><msubsup><mi>p</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></mrow></math></eq> and <eq><math><msub><mi>p</mi><mn>2</mn></msub></math></eq> is not a subterm of <eq><math><msubsup><mi>p</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq>, by proposition 2 <eq><math><mrow><mi>q</mi><mo>‚àº</mo></mrow><mrow><msubsup><mi>p</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></mrow></math></eq>. By proposition 9, <eq><math><msub><mi>p</mi><mn>1</mn></msub></math></eq> is not a subterm of <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq>, thus <eq><math><mi>q</mi></math></eq> is not a subterm of <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq>. This means that <eq><math><msub><mi>p</mi><mn>2</mn></msub></math></eq> could not be entered from <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq>, since it has a copy <eq><math><mi>q</mi></math></eq> outside <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq>.</p><li><p><eq><math><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>‚â∫</mo></mrow><mrow><msub><mi>t</mi><mn>2</mn></msub><mo>‚â∫</mo></mrow><mrow><msubsup><mi>p</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mo>‚â∫</mo></mrow><mrow><msubsup><mi>p</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></mrow></math></eq>. By proposition 9, <eq><math><msub><mi>p</mi><mn>1</mn></msub></math></eq> is not a subterm of <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq> or <eq><math><msubsup><mi>p</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq>. Since <eq><math><msub><mi>p</mi><mn>1</mn></msub></math></eq> is earlier than <eq><math><msubsup><mi>p</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq> in DFS order, <eq><math><msub><mi>p</mi><mn>1</mn></msub></math></eq> is also earlier than <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq>. By proposition 8, there is <eq><math><mi>q</mi></math></eq> such that <eq><math><mrow><msubsup><mi>p</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mi>/</mi><msubsup><mi>p</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mo>‚àº</mo></mrow><mrow><mi>q</mi><mi>/</mi><msub><mi>p</mi><mn>2</mn></msub></mrow></math></eq>. Since <eq><math><mrow><msub><mi>p</mi><mn>1</mn></msub><mo>‚àº</mo></mrow><mrow><msubsup><mi>p</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></mrow></math></eq> and <eq><math><msub><mi>p</mi><mn>1</mn></msub></math></eq> is not a subterm of <eq><math><msubsup><mi>p</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq>, by proposition 2 <eq><math><mrow><mi>q</mi><mo>‚àº</mo></mrow><mrow><msubsup><mi>p</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></mrow></math></eq>. Since <eq><math><mi>q</mi></math></eq> is in <eq><math><msub><mi>t</mi><mn>2</mn></msub></math></eq>, it is also later than <eq><math><msub><mi>p</mi><mn>1</mn></msub></math></eq> in DFS order. Since <eq><math><msub><mi>p</mi><mn>2</mn></msub></math></eq> is earlier than <eq><math><msubsup><mi>p</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq>, <eq><math><mi>q</mi></math></eq> is earlier than <eq><math><msubsup><mi>p</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq>. Thus <eq><math><mrow><mi>q</mi><mo>‚àº</mo></mrow><mrow><msub><mi>p</mi><mn>1</mn></msub></mrow></math></eq> is between <eq><math><msub><mi>p</mi><mn>1</mn></msub></math></eq> and <eq><math><msubsup><mi>p</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq> in DFS order, so <eq><math><msubsup><mi>p</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq> cannot be the immediately next copy of <eq><math><msub><mi>p</mi><mn>1</mn></msub></math></eq>.</p><li><p><eq><math><mrow><msub><mi>t</mi><mn>1</mn></msub><mo>‚â∫</mo></mrow><mrow><msubsup><mi>p</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mo>‚â∫</mo></mrow><mrow><msub><mi>t</mi><mn>2</mn></msub><mo>‚â∫</mo></mrow><mrow><msubsup><mi>p</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></mrow></math></eq>. By proposition 8, there are <eq><math><mi>q</mi></math></eq> and <eq><math><msup><mi>q</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></math></eq> such that <eq><math><mrow><msub><mi>p</mi><mn>2</mn></msub><mi>/</mi><msubsup><mi>p</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mo>‚àº</mo></mrow><mrow><mi>q</mi><mi>/</mi><msub><mi>p</mi><mn>1</mn></msub></mrow></math></eq> and <eq><math><mrow><msubsup><mi>p</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mi>/</mi><msubsup><mi>p</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mo>‚àº</mo></mrow><mrow><msup><mi>q</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup><mi>/</mi><msub><mi>p</mi><mn>1</mn></msub></mrow></math></eq>. By proposition 6, <eq><math><mrow><mi>q</mi><mo>‚àº</mo></mrow><mrow><msup><mi>q</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></mrow></math></eq>. Since <eq><math><msub><mi>p</mi><mn>2</mn></msub></math></eq> is earlier than <eq><math><msubsup><mi>p</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq> in DFS order, <eq><math><mrow><mo form=prefix stretchy=false>(</mo><msubsup><mi>p</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mo>‚áù</mo><msub><mi>p</mi><mn>2</mn></msub><mo form=postfix stretchy=false>)</mo><mo>=</mo></mrow><mrow><mo form=prefix stretchy=false>(</mo><msub><mi>p</mi><mn>1</mn></msub><mo>‚áù</mo><mi>q</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq>, and <eq><math><mrow><mo form=prefix stretchy=false>(</mo><msubsup><mi>p</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mo>‚áù</mo><msubsup><mi>p</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mo form=postfix stretchy=false>)</mo><mo>=</mo></mrow><mrow><mo form=prefix stretchy=false>(</mo><msub><mi>p</mi><mn>1</mn></msub><mo>‚áù</mo><msup><mi>q</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup><mo form=postfix stretchy=false>)</mo></mrow></math></eq>, <eq><math><mi>q</mi></math></eq> is earlier than <eq><math><msup><mi>q</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></math></eq> in DFS order. Together with <eq><math><mrow><mi>q</mi><mo>‚àº</mo></mrow><mrow><msup><mi>q</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></mrow></math></eq>, this implies <eq><math><msup><mi>q</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></math></eq> could not be entered from <eq><math><msub><mi>t</mi><mn>1</mn></msub></math></eq>. However, the path <eq><math><mrow><msubsup><mi>p</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup><mo>‚áù</mo></mrow><mrow><msup><mi>u</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></mrow></math></eq> passes through <eq><math><msubsup><mi>p</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq>, so the rerooted path <eq><math><mrow><msub><mi>p</mi><mn>1</mn></msub><mo>‚áù</mo></mrow><mrow><msub><mi>u</mi><mn>1</mn></msub></mrow></math></eq> passes through <eq><math><msup><mi>q</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></math></eq>, and thus <eq><math><msup><mi>q</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></math></eq> has to be entered for <eq><math><msub><mi>u</mi><mn>1</mn></msub></math></eq> to be reached.</p></ol><p>This proves that the mapping <eq><math><mrow><mo form=prefix stretchy=false>(</mo><msub><mi>t</mi><mn>2</mn></msub><mo separator=true>,</mo><msub><mi>u</mi><mn>2</mn></msub><mo form=postfix stretchy=false>)</mo><mo>‚Ü¶</mo></mrow><mrow><msup><mi>u</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></mrow></math></eq> is injective, and thus this part of the algorithm takes at most linear time, which proves the linear complexity of the entire algorithm.<p>Notes:<ol><li><p>The algorithm is linear even under the presence of collisions. The mapping <eq><math><mrow><mo form=prefix stretchy=false>(</mo><msub><mi>t</mi><mn>2</mn></msub><mo separator=true>,</mo><msub><mi>u</mi><mn>2</mn></msub><mo form=postfix stretchy=false>)</mo><mo>‚Ü¶</mo></mrow><mrow><msup><mi>u</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></mrow></math></eq> will be defined over a smaller set of pairs than with perfect hashes, since the algorithm will abort at some point, but will stay injective.</p><li><p>The arguments <eq><math><mrow><msub><mi>u</mi><mn>1</mn></msub><mo separator=true>,</mo></mrow><mrow><msub><mi>t</mi><mn>1</mn></msub></mrow></math></eq> to <code>compare</code> are not taken into consideration during the proof. <code>compare</code> can be transformed to <code>serialize</code>, which lists non-entered terms as either hash values or backrefs, followed by an assertion that the serialized strings of all terms within a group are equal. This still takes linear time because the total string length is linear. This algorithm can resolve hash collisions locally by splitting groups, but is more complex and requires more memory.</p><li><p>The only reason a <code>serialize</code>-based algorithm needs to be pre-fed with hashes is to determine which terms are pivots ‚Äì the exact hashes or even collisions between pivots are inconsequential. Pivots mostly matter because of the assumption that the path <eq><math><mrow><mi>t</mi><mo>‚áù</mo></mrow><mrow><mi>p</mi></mrow></math></eq> does not contain other pivots. Hashing is an overkill, but we are not aware of any algorithm for detecting pivots without it.</p></ol><p class=next-group><span aria-level=3 class=side-header role=heading><span>Classes</span></span>The high-level overview of our deterministic algorithm for computing equivalence classes is as follows.<p>We start with the root term <eq><math><mi>t</mi></math></eq> and generate an auxiliary forest <eq><math><mi>F</mi></math></eq> of terms, where some variable accesses use names and others use indices, such that for each non-unique subterm <eq><math><mi>u</mi></math></eq> of <eq><math><mi>t</mi></math></eq> (i.e. a subterm that has an <eq><math><mi>Œ±</mi></math></eq>-equivalent copy in <eq><math><mi>t</mi></math></eq>), there is a subtree <eq><math><msup><mi>u</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></math></eq> within <eq><math><mi>F</mi></math></eq> that syntactically matches the locally nameless form of <eq><math><mi>u</mi></math></eq>. For example, for <eq><math><mrow><mi>t</mi><mo>=</mo></mrow><mrow><mo form=prefix stretchy=false>(</mo><mi>Œª</mi><mi>x</mi><mi>.</mi><mi>x</mi><mspace width=0.1667em></mspace><mi>x</mi><mo form=postfix stretchy=false>)</mo><mo form=prefix stretchy=false>(</mo><mi>Œª</mi><mi>y</mi><mi>.</mi><mi>y</mi><mspace width=0.1667em></mspace><mi>y</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq>, <eq><math><mi>F</mi></math></eq> might contain three root terms: <eq><math><mrow><mo form=prefix stretchy=false>(</mo><mi>Œª</mi><mi>.</mi><mrow style="padding:0 0 0.1em 0;border-bottom:0.065em solid;"><mn>1</mn></mrow><mspace width=0.1667em></mspace><mrow style="padding:0 0 0.1em 0;border-bottom:0.065em solid;"><mn>1</mn></mrow><mo form=postfix stretchy=false>)</mo><mo form=prefix stretchy=false>(</mo><mi>Œª</mi><mi>.</mi><mrow style="padding:0 0 0.1em 0;border-bottom:0.065em solid;"><mn>1</mn></mrow><mspace width=0.1667em></mspace><mrow style="padding:0 0 0.1em 0;border-bottom:0.065em solid;"><mn>1</mn></mrow><mo form=postfix stretchy=false>)</mo></mrow></math></eq>, <eq><math><mi>x</mi></math></eq>, and <eq><math><mi>y</mi></math></eq>. Two distinct terms <eq><math><msub><mi>u</mi><mn>1</mn></msub></math></eq>, <eq><math><msub><mi>u</mi><mn>2</mn></msub></math></eq> are <eq><math><mi>Œ±</mi></math></eq>-equivalent if and only if they both have <eq><math><msubsup><mi>u</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq>, <eq><math><msubsup><mi>u</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq>, and the corresponding subtrees <eq><math><msubsup><mi>u</mi><mn>1</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq>, <eq><math><msubsup><mi>u</mi><mn>2</mn><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msubsup></math></eq> are equal. After <eq><math><mi>F</mi></math></eq> is built, we apply a general-purpose algorithm to compute syntactic equivalence classes of subtrees of <eq><math><mi>F</mi></math></eq>, and then lift those classes back to <eq><math><mi>t</mi></math></eq>.<p>The algorithms we propose build <eq><math><mi>F</mi></math></eq> in <eq><math><mrow><mi class=mathcal>ùí™</mi><mo form=prefix stretchy=false>(</mo><mi>n</mi><mrow><mspace width=0.1667em></mspace><mi>log</mi><mo>‚Å°</mo><mspace width=0.1667em></mspace></mrow><mi>n</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> time, ensure <eq><math><mi>F</mi></math></eq> has <eq><math><mrow><mi class=mathcal>ùí™</mi><mo form=prefix stretchy=false>(</mo><mi>n</mi><mrow><mspace width=0.1667em></mspace><mi>log</mi><mo>‚Å°</mo><mspace width=0.1667em></mspace></mrow><mi>n</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> nodes, and compute syntactic equivalence classes in <eq><math><mrow><mi class=mathcal>ùí™</mi><mo form=prefix stretchy=false>(</mo><mrow><mo fence=true form=prefix>|</mo><mi>F</mi><mo fence=true form=postfix>|</mo></mrow><mo form=postfix stretchy=false>)</mo><mo>=</mo></mrow><mrow><mi class=mathcal>ùí™</mi><mo form=prefix stretchy=false>(</mo><mi>n</mi><mrow><mspace width=0.1667em></mspace><mi>log</mi><mo>‚Å°</mo><mspace width=0.1667em></mspace></mrow><mi>n</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq>.<p>Our algorithm for building <eq><math><mi>F</mi></math></eq> is recursive. It receives a term <eq><math><mi>t</mi></math></eq> in a locally nameless representation (initially just the root term) and guarantees that all of its non-unique subterms will have locally nameless forms in <eq><math><mi>F</mi></math></eq> on exit.<p>We start by adding an exact copy <eq><math><msup><mi>t</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></math></eq> of <eq><math><mi>t</mi></math></eq> to <eq><math><mi>F</mi></math></eq>. We map <eq><math><mrow><mi>u</mi><mo>‚Ü¶</mo></mrow><mrow><msup><mi>u</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></mrow></math></eq> for all <em>locally closed</em> subterms <eq><math><mi>u</mi></math></eq> of <eq><math><mi>t</mi></math></eq>, i.e. subterms that only access variables free in <eq><math><mi>t</mi></math></eq> or bound in <eq><math><mi>u</mi></math></eq>; this includes <eq><math><mi>t</mi></math></eq> itself, mapping <eq><math><mrow><mi>t</mi><mo>‚Ü¶</mo></mrow><mrow><msup><mi>t</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></mrow></math></eq>. Among non-locally-closed subterms, we recognize that ‚Äúlarge‚Äù subterms of size <eq><math><mrow><mrow><mo fence=true form=prefix>|</mo><mi>u</mi><mo fence=true form=postfix>|</mo></mrow><mo>‚â•</mo></mrow><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac><mrow><mo fence=true form=prefix>|</mo><mi>t</mi><mo fence=true form=postfix>|</mo></mrow></mrow></math></eq> are guaranteed to be unique and don‚Äôt have to be mapped, since their <eq><math><mi>Œ±</mi></math></eq>-equivalent copies could only be located within <eq><math><mi>t</mi></math></eq>, but there isn‚Äôt enough space within <eq><math><mi>t</mi></math></eq> for another subterm of matching size. This leaves ‚Äúsmall‚Äù non-locally-closed subterms. To cover them, we adjust variable mentions so that the top-level subterms of this kind are in the locally nameless representation and recurse.<pre><code class=language-python><div class=expansible-code><input id=expansible2 type=checkbox><div class=highlighted>size: <span class=hljs-built_in>dict</span>[Term, <span class=hljs-built_in>int</span>] = {}
max_index: <span class=hljs-built_in>dict</span>[Term, <span class=hljs-built_in>int</span>] = {}
forest: <span class=hljs-built_in>list</span>[Term] = []
term_to_node: <span class=hljs-built_in>dict</span>[Term, Term] = {}

<span class=hljs-keyword>def</span> <span class="hljs-title function_">build_forest</span>(<span class=hljs-params>t: Term</span>) -> <span class=hljs-built_in>int</span>:
    t_prime = deep_copy(t)
    forest.append(t_prime)
    compute_term_properties(t)
    recurse(t, t_prime, size[t])

<span class=hljs-keyword>def</span> <span class="hljs-title function_">compute_term_properties</span>(<span class=hljs-params>t: Term</span>):
    <span class=hljs-keyword>match</span> t:
        <span class=hljs-keyword>case</span> Variable(x):
            size[t] = <span class=hljs-number>1</span>
            <span class=hljs-keyword>if</span> x <span class=hljs-keyword>is</span> a de Bruijn index:
                max_index[t] = x
            <span class=hljs-keyword>else</span>:  <span class=hljs-comment># x is a variable name</span>
                max_index[t] = -<span class=hljs-number>1</span>
        <span class=hljs-keyword>case</span> Abstraction(x, u):
            compute_term_properties(u)
            size[t] = <span class=hljs-number>1</span> + size[u]
            max_index[t] = max_index[u] - <span class=hljs-number>1</span>
        <span class=hljs-keyword>case</span> Application(t1, t2):
            compute_term_properties(t1)
            compute_term_properties(t2)
            size[t] = <span class=hljs-number>1</span> + size[t1] + size[t2]
            max_index[t] = <span class=hljs-built_in>max</span>(max_index[t1], max_index[t2])

<span class=hljs-keyword>def</span> <span class="hljs-title function_">recurse</span>(<span class=hljs-params>t: Term, t_prime: Term, root_size: <span class=hljs-built_in>int</span></span>):
    <span class=hljs-keyword>if</span> max_index[t] < <span class=hljs-number>0</span>:  <span class=hljs-comment># locally closed</span>
        term_to_node[t] = t_prime
    <span class=hljs-keyword>else</span>:
        <span class=hljs-keyword>if</span> <span class=hljs-number>2</span> * size[t] < root_size:  <span class=hljs-comment># small</span>
            build_forest(t)
            <span class=hljs-keyword>return</span>

    <span class=hljs-keyword>match</span> (t, t_prime):
        <span class=hljs-keyword>case</span> (Abstraction(x, u), Abstraction(_, u_prime)):
            replace_mentions(x)  <span class=hljs-comment># not shown: replace all mentions of x in t with names</span>
            recurse(u, u_prime, root_size)
        <span class=hljs-keyword>case</span> (Application(u1, u2), Application(u1_prime, u2_prime)):
            recurse(u1, u1_prime, root_size)
            recurse(u2, u2_prime, root_size)

build_forest(root_t)
</div><label for=expansible2>Expand</label></div></code></pre><p>Since <eq><math><mrow><mo fence=true form=prefix>|</mo><mi>t</mi><mo fence=true form=postfix>|</mo></mrow></math></eq> is at worst halved during each recursive invocation, there are at most <eq><math><mrow><mrow><mi>log</mi><mo>‚Å°</mo><mspace width=0.1667em></mspace></mrow><mi>n</mi></mrow></math></eq> levels of recursion. Excluding recursion, each invocation of <code>build_forest</code> takes <eq><math><mrow><mi class=mathcal>ùí™</mi><mo form=prefix stretchy=false>(</mo><mrow><mo fence=true form=prefix>|</mo><mi>t</mi><mo fence=true form=postfix>|</mo></mrow><mo form=postfix stretchy=false>)</mo></mrow></math></eq> time, which can be amortized as <eq><math><mrow><mi class=mathcal>ùí™</mi><mo form=prefix stretchy=false>(</mo><mn>1</mn><mo form=postfix stretchy=false>)</mo></mrow></math></eq> per subterm <eq><math><mi>u</mi></math></eq> of <eq><math><mi>t</mi></math></eq>. Since each <eq><math><mi>u</mi></math></eq> only takes part in <eq><math><mrow><mi class=mathcal>ùí™</mi><mo form=prefix stretchy=false>(</mo><mrow><mi>log</mi><mo>‚Å°</mo><mspace width=0.1667em></mspace></mrow><mi>n</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> recursive invocations, the total time complexity is <eq><math><mrow><mi class=mathcal>ùí™</mi><mo form=prefix stretchy=false>(</mo><mi>n</mi><mrow><mspace width=0.1667em></mspace><mi>log</mi><mo>‚Å°</mo><mspace width=0.1667em></mspace></mrow><mi>n</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq>, implying <eq><math><mrow><mrow><mo fence=true form=prefix>|</mo><mi>F</mi><mo fence=true form=postfix>|</mo></mrow><mo>=</mo></mrow><mrow><mi class=mathcal>ùí™</mi><mo form=prefix stretchy=false>(</mo><mi>n</mi><mrow><mspace width=0.1667em></mspace><mi>log</mi><mo>‚Å°</mo><mspace width=0.1667em></mspace></mrow><mi>n</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq>.<p>To calculate syntactic equivalence classes of subterms of <eq><math><mi>F</mi></math></eq>, we partition subterms by subtree size and iterate over groups in order of increasing size. Within each group, the equivalence classes of direct descendants of terms are already known, so each term can be associated with a short finite vector, such that syntactically equal terms have equal vectors. Further partitioning terms within the group by vectors using a radix sort-like approach produces subgroups corresponding to equivalence classes.<pre><code class=language-python><div class=expansible-code><input id=expansible3 type=checkbox><div class=highlighted><span class=hljs-meta>@dataclass</span>
<span class=hljs-keyword>class</span> <span class="hljs-title class_">SizeGroup</span>:
    <span class=hljs-comment># variable accesses are not stored explicitly</span>
    abstractions: <span class=hljs-built_in>list</span>[Term]
    applications: <span class=hljs-built_in>list</span>[Term]

by_size: <span class=hljs-built_in>list</span>[SizeGroup] = [SizeGroup([], []) <span class=hljs-keyword>for</span> _ <span class=hljs-keyword>in</span> <span class=hljs-built_in>range</span>(n + <span class=hljs-number>1</span>)]
node_classes: <span class=hljs-built_in>dict</span>[Term, <span class=hljs-built_in>int</span>] = {}
next_class: <span class=hljs-built_in>int</span> = n_variables * <span class=hljs-number>2</span>  <span class=hljs-comment># leave space to easily number variable accesses</span>

<span class=hljs-keyword>def</span> <span class="hljs-title function_">populate_size_groups</span>(<span class=hljs-params>t: Term</span>) -> <span class=hljs-built_in>int</span>:
    <span class=hljs-keyword>match</span> t:
        <span class=hljs-keyword>case</span> Variable(x):
            <span class=hljs-comment># Populate classes of leaf nodes immediately.</span>
            <span class=hljs-keyword>if</span> x <span class=hljs-keyword>is</span> a de Bruijn index:
                node_classes[t] = x
            <span class=hljs-keyword>else</span>:  <span class=hljs-comment># x is a variable name, assuming an integer from 0 to `n_variables - 1`</span>
                node_classes[t] = n_variables + x
            <span class=hljs-keyword>return</span> <span class=hljs-number>1</span>
        <span class=hljs-keyword>case</span> Abstraction(_, u):
            size = <span class=hljs-number>1</span> + populate_size_groups(u)
            by_size[size].abstractions.append(t)
            <span class=hljs-keyword>return</span> size
        <span class=hljs-keyword>case</span> Application(t1, t2):
            size = <span class=hljs-number>1</span> + populate_size_groups(t1) + populate_size_groups(t2)
            by_size[size].applications.append(t)
            <span class=hljs-keyword>return</span> size

<span class=hljs-keyword>for</span> t <span class=hljs-keyword>in</span> forest:
    populate_size_groups(t)

temporary_storage: <span class=hljs-built_in>list</span>[<span class=hljs-built_in>list</span>[Term]] = []

<span class=hljs-keyword>def</span> <span class="hljs-title function_">group_by</span>(<span class=hljs-params>nodes: <span class=hljs-built_in>list</span>[Term], key: <span class=hljs-type>Callable</span>[[Term], <span class=hljs-built_in>int</span>]</span>) -> <span class=hljs-built_in>list</span>[<span class=hljs-built_in>list</span>[Term]]:
    present_keys: <span class=hljs-built_in>list</span>[<span class=hljs-built_in>int</span>] = []
    <span class=hljs-keyword>for</span> t <span class=hljs-keyword>in</span> nodes:
        k = key(t)
        <span class=hljs-keyword>while</span> k >= <span class=hljs-built_in>len</span>(temporary_storage):  <span class=hljs-comment># amortized O(|F|)</span>
            temporary_storage.append([])
        <span class=hljs-keyword>if</span> <span class=hljs-keyword>not</span> temporary_storage[k]:
            present_keys.append(k)
        temporary_storage[k].append(t)
    result = [temporary_storage[k] <span class=hljs-keyword>for</span> k <span class=hljs-keyword>in</span> present_keys]
    <span class=hljs-keyword>for</span> k <span class=hljs-keyword>in</span> present_keys:
        temporary_storage[k] = []
    <span class=hljs-keyword>return</span> result

<span class=hljs-keyword>for</span> group <span class=hljs-keyword>in</span> by_size:
    <span class=hljs-keyword>for</span> subgroup <span class=hljs-keyword>in</span> group_by(group.abstractions, <span class=hljs-keyword>lambda</span> t: node_classes[t.body]):
        <span class=hljs-keyword>for</span> t <span class=hljs-keyword>in</span> subgroup:
            node_classes[t] = next_class
        next_class += <span class=hljs-number>1</span>

    <span class=hljs-keyword>for</span> subgroup1 <span class=hljs-keyword>in</span> group_by(group.applications, <span class=hljs-keyword>lambda</span> t: node_classes[t.function]):
        <span class=hljs-keyword>for</span> subgroup2 <span class=hljs-keyword>in</span> group_by(subgroup1, <span class=hljs-keyword>lambda</span> t: node_classes[t.argument]):
            <span class=hljs-keyword>for</span> t <span class=hljs-keyword>in</span> subgroup2:
                node_classes[t] = next_class
            next_class += <span class=hljs-number>1</span>
</div><label for=expansible3>Expand</label></div></code></pre><p>Term classes can then be populated from node classes.<pre><code class=language-python>term_classes: <span class=hljs-built_in>dict</span>[Term, <span class=hljs-built_in>int</span>] = {}

<span class=hljs-keyword>def</span> <span class="hljs-title function_">populate_term_classes</span>(<span class=hljs-params>t: Term</span>):
    <span class=hljs-keyword>if</span> t <span class=hljs-keyword>in</span> term_to_node:
        term_classes[t] = node_classes[term_to_node[t]]
    <span class=hljs-keyword>else</span>:  <span class=hljs-comment># guaranteed to be unique (non-locally-closed and "big")</span>
        term_classes[t] = next_class
        next_class += <span class=hljs-number>1</span>

    <span class=hljs-keyword>match</span> t:
        <span class=hljs-keyword>case</span> Abstraction(_, u):
            populate_term_classes(u)
        <span class=hljs-keyword>case</span> Application(t1, t2):
            populate_term_classes(t1)
            populate_term_classes(t2)

populate_term_classes(root_t)
</code></pre></div></section><footer><div class=viewport-container><h2>Made with my own bare hands (why.)</h2></div></footer><script>window.addEventListener("keydown", e => {
				if (e.key === "Enter") {
					if (e.ctrlKey) {
						window.open("https://github.com/purplesyringa/site/edit/master/blog/faster-comparison-modulo-alpha-equivalence/index.md", "_blank");
					} else if (
						e.target.type === "checkbox"
						&& e.target.parentNode
						&& e.target.parentNode.className === "expansible-code"
					) {
						e.target.click();
					}
				}
			});</script>