<!doctypehtml><meta charset=utf-8><meta content=width=device-width,initial-scale=1 name=viewport><title>У base64 есть неподвижная точка | purplesyringa's blog</title><link href=../../../all.css rel=stylesheet><link href=../../../blog.css rel=stylesheet><link href=../../../vendor/Temml-Local.css rel=stylesheet><link crossorigin href=https://fonts.googleapis.com/css2?family=Noto+Sans:ital,wght@0,100..900;1,100..900&family=Roboto+Mono:ital,wght@0,100..700;1,100..700&family=Roboto:ital,wght@0,400;0,700;1,400;1,700&family=Slabo+27px&display=swap rel=stylesheet><link media="screen and (prefers-color-scheme: dark"href=../../../vendor/atom-one-dark.min.css rel=stylesheet><link media="screen and (prefers-color-scheme: light"href=../../../vendor/atelier-cave-light.min.css rel=stylesheet><body><header><div class=viewport-container><div class=media><a href=https://github.com/purplesyringa><img src=../../../images/github-mark-white.svg></a></div><h1><a href=/>purplesyringa</a></h1><nav><a href=../../..>about</a><a class=current href=../../../blog/>blog</a><a href=../../../sink/>kitchen sink</a></nav></div></header><section><div class=viewport-container><h2>У base64 есть неподвижная точка</h2><time>3 августа, 2024</time><p><em>Пост написан по мотивам <a href=https://www.reddit.com/r/compsci/comments/18234a/the_base64_encoder_has_a_fixed_point/>давнего треда на Reddit</a>.</em><pre><code class=language-shell><span class="hljs-meta prompt_">$ </span><span class=language-bash>&LT/dev/urandom <span class=hljs-built_in>base64</span> | <span class=hljs-built_in>base64</span> | <span class=hljs-built_in>base64</span> | <span class=hljs-built_in>base64</span> | <span class=hljs-built_in>base64</span> | <span class=hljs-built_in>base64</span> | <span class=hljs-built_in>base64</span> | <span class=hljs-built_in>base64</span> | <span class=hljs-built_in>base64</span> \
     | <span class=hljs-built_in>base64</span> | <span class=hljs-built_in>base64</span> | <span class=hljs-built_in>base64</span> | <span class=hljs-built_in>base64</span> | <span class=hljs-built_in>base64</span> | <span class=hljs-built_in>base64</span> | <span class=hljs-built_in>base64</span> | <span class=hljs-built_in>base64</span> | <span class=hljs-built_in>base64</span> | <span class=hljs-built_in>base64</span> \
     | <span class=hljs-built_in>base64</span> | <span class=hljs-built_in>head</span> -1</span>
Vm0wd2QyUXlVWGxWV0d4V1YwZDRWMVl3WkRSV01WbDNXa1JTVjAxV2JETlhhMUpUVmpBeFYySkVU
<span class="hljs-meta prompt_">
$ </span><span class=language-bash>&LT/dev/urandom <span class=hljs-built_in>base64</span> | <span class=hljs-built_in>base64</span> | <span class=hljs-built_in>base64</span> | <span class=hljs-built_in>base64</span> | <span class=hljs-built_in>base64</span> | <span class=hljs-built_in>base64</span> | <span class=hljs-built_in>base64</span> | <span class=hljs-built_in>base64</span> | <span class=hljs-built_in>base64</span> \
     | <span class=hljs-built_in>base64</span> | <span class=hljs-built_in>base64</span> | <span class=hljs-built_in>base64</span> | <span class=hljs-built_in>base64</span> | <span class=hljs-built_in>base64</span> | <span class=hljs-built_in>base64</span> | <span class=hljs-built_in>base64</span> | <span class=hljs-built_in>base64</span> | <span class=hljs-built_in>base64</span> | <span class=hljs-built_in>base64</span> \
     | <span class=hljs-built_in>base64</span> | <span class=hljs-built_in>head</span> -1</span>
Vm0wd2QyUXlVWGxWV0d4V1YwZDRWMVl3WkRSV01WbDNXa1JTVjAxV2JETlhhMUpUVmpBeFYySkVU
</code></pre><h3>Завязка</h3><p>Мне нравятся p-адики. Я их не понимаю и никогда особо не изучала, матанализ я знаю разве что на уровне действительных/комплексных чисел. Но, как в меме с distracted boyfriend, я не могу их не уважать: по сравнению со сложностью представления действительных чисел, p-адики просто рай.<p>Вот, например, многие непрерывные функции обладают таким свойством. Если длина общего префикса чисел <eq><math><mi>a</mi></math></eq> и <eq><math><mi>b</mi></math></eq> стремится к бесконечности, то и длина общего префикса <eq><math><mrow><mi>f</mi><mo form=prefix stretchy=false>(</mo><mi>a</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> и <eq><math><mrow><mi>f</mi><mo form=prefix stretchy=false>(</mo><mi>b</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> стремится к бесконечности. Это не всегда так: например, для <eq><math><mrow><mi>f</mi><mo form=prefix stretchy=false>(</mo><mi>x</mi><mo form=postfix stretchy=false>)</mo><mo>=</mo></mrow><mrow><mi>x</mi><mo>+</mo></mrow><mrow><mn>1</mn><mo>−</mo></mrow><mrow><msqrt><mn>2</mn></msqrt></mrow></math></eq> для <eq><math><mi>a</mi></math></eq>, стремящегося к <eq><math><msqrt><mn>2</mn></msqrt></math></eq> снизу, и <eq><math><mi>b</mi></math></eq>, стремящегося к <eq><math><msqrt><mn>2</mn></msqrt></math></eq> сверху, условие выполняться будет, а следствие – нет.<p>На практике такая интерпретация все равно полезна. Во-первых, с ее помощью можно быстро проверять гипотезы и на глаз что-то оценивать. А во-вторых, эвристикой она является только для действительных чисел, а вот в p-адиках она берется за определение.<p>Похожим образом можно смотреть на сужающие отображения. Для большинства аргументов <eq><math><mrow><mi>f</mi><mo form=prefix stretchy=false>(</mo><mi>a</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> и <eq><math><mrow><mi>f</mi><mo form=prefix stretchy=false>(</mo><mi>b</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> имеют более длинный общий префикс, чем <eq><math><mi>a</mi></math></eq> и <eq><math><mi>b</mi></math></eq>? Вероятно, отображение сужающее. Ну, как вероятно – в p-адиках это тоже определение.<p>Короче говоря, p-адики – это такой промежуточный мир между числами и строками. Поэтому, когда я вижу какие-то строки и отображения на строках, которые выглядят как-то интересно и как будто бы сходятся, я радуюсь, что я не одинока и что есть теория, которая примерно таким и занимается. Далеко не всегда ее методы применимы в общем случае, но по крайней мере идеи почерпать обычно можно.<h3>base64</h3><p>В программировании сужающие отображения встречаются на удивление часто, только мы их называем encoding’ами. Base64, например, относится к этой категории: первые <eq><math><mi>n</mi></math></eq> бит входа однозначно определяют как минимум первые <eq><math><mrow><mo form=prefix stretchy=false>⌊</mo><mi>n</mi><mi>/</mi><mn>6</mn><mo form=postfix stretchy=false>⌋</mo><mo>⋅</mo></mrow><mrow><mn>8</mn></mrow></math></eq> бит выхода, и при <eq><math><mrow><mi>n</mi><mo>≥</mo></mrow><mrow><mn>18</mn></mrow></math></eq> второе всегда больше первого. Получается, если вы возьмете 18-битное число, дополните его мусором и начнете итеративно применять к нему base64, на каждом шаге вы будете получать все больше и больше фиксированных бит.<p>При этом, поскольку первый бит выхода всегда <code>0</code>, получается такая картина: если начать со строки с нулем известных бит и применять к ней base64 итеративно, то сначала мы получим 1 известный бит, потому случится что-то нам непонятное, а потом сработает правило <eq><math><mrow><mi>n</mi><mo>≥</mo></mrow><mrow><mn>18</mn></mrow></math></eq>, и число известных бит будет опять точно расти. Возникает вопрос: можно ли эту “дырку” между <eq><math><mrow><mi>n</mi><mo>=</mo></mrow><mrow><mn>1</mn></mrow></math></eq> и <eq><math><mrow><mi>n</mi><mo>=</mo></mrow><mrow><mn>18</mn></mrow></math></eq> заклеить? Да, можно, если отслеживать не только количество известных бит, но и интервал их значений. К сожалению, это требует опоры на конкретный алфавит base64. Руками это делать неудобно и муторно, обойдемся питоном:<pre><code class=language-python><div class=expansible-code><input id=expansible1 type=checkbox><div class=highlighted>ALPHABET = <span class=hljs-string>"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"</span>

studied_bits = <span class=hljs-number>0</span>
bit_range_min = <span class=hljs-string>""</span>
bit_range_max = <span class=hljs-string>""</span>

<span class=hljs-keyword>for</span> _ <span class=hljs-keyword>in</span> <span class=hljs-built_in>range</span>(<span class=hljs-number>8</span>):
    next_studied_bits = <span class=hljs-number>0</span>
    next_bit_range_min = <span class=hljs-string>""</span>
    next_bit_range_max = <span class=hljs-string>""</span>
    had_non_equal_before = <span class=hljs-literal>False</span>
    <span class=hljs-keyword>for</span> offset <span class=hljs-keyword>in</span> <span class=hljs-built_in>range</span>(<span class=hljs-number>0</span>, studied_bits + <span class=hljs-number>1</span>, <span class=hljs-number>6</span>):
        min_sixlet = <span class=hljs-built_in>int</span>(bit_range_min[offset:offset + <span class=hljs-number>6</span>].ljust(<span class=hljs-number>6</span>, <span class=hljs-string>"0"</span>), <span class=hljs-number>2</span>)
        max_sixlet = <span class=hljs-built_in>int</span>(bit_range_max[offset:offset + <span class=hljs-number>6</span>].ljust(<span class=hljs-number>6</span>, <span class=hljs-string>"1"</span>), <span class=hljs-number>2</span>)
        mid_max_sixlet = <span class=hljs-number>63</span> <span class=hljs-keyword>if</span> had_non_equal_before <span class=hljs-keyword>else</span> max_sixlet
        mid_min_sixlet = <span class=hljs-number>0</span> <span class=hljs-keyword>if</span> had_non_equal_before <span class=hljs-keyword>else</span> min_sixlet
        min_octet = <span class=hljs-built_in>bin</span>(<span class=hljs-built_in>min</span>(<span class=hljs-built_in>map</span>(<span class=hljs-built_in>ord</span>, ALPHABET[min_sixlet:mid_max_sixlet + <span class=hljs-number>1</span>])))[<span class=hljs-number>2</span>:].rjust(<span class=hljs-number>8</span>, <span class=hljs-string>"0"</span>)
        max_octet = <span class=hljs-built_in>bin</span>(<span class=hljs-built_in>max</span>(<span class=hljs-built_in>map</span>(<span class=hljs-built_in>ord</span>, ALPHABET[mid_min_sixlet:max_sixlet + <span class=hljs-number>1</span>])))[<span class=hljs-number>2</span>:].rjust(<span class=hljs-number>8</span>, <span class=hljs-string>"0"</span>)
        next_studied_bits += <span class=hljs-number>6</span>
        next_bit_range_min += min_octet
        next_bit_range_max += max_octet
        <span class=hljs-keyword>if</span> min_sixlet != max_sixlet:
            had_non_equal_before = <span class=hljs-literal>True</span>

    studied_bits = next_studied_bits
    bit_range_min = next_bit_range_min
    bit_range_max = next_bit_range_max

    <span class=hljs-built_in>print</span>(<span class=hljs-string>"Bits studied:"</span>, studied_bits)
    <span class=hljs-built_in>print</span>(<span class=hljs-string>"Range:"</span>, bit_range_min, <span class=hljs-string>"..="</span>, bit_range_max)
    prefix = <span class=hljs-number>0</span>
    <span class=hljs-keyword>while</span> prefix < studied_bits <span class=hljs-keyword>and</span> bit_range_min[prefix] == bit_range_max[prefix]:
        prefix += <span class=hljs-number>1</span>
    <span class=hljs-built_in>print</span>(<span class=hljs-string>"Common prefix:"</span>, bit_range_min[:prefix], <span class=hljs-string>"length"</span>, prefix)
    <span class=hljs-built_in>print</span>()
</div><label for=expansible1></label></div></code></pre><pre><code class=language-text><div class=expansible-code><input id=expansible2 type=checkbox><div class=highlighted>Bits studied: 6
Range: 00101011 ..= 01111010
Common prefix: 0 length 1

Bits studied: 12
Range: 0100101100101011 ..= 0110010101110110
Common prefix: 01 length 2

Bits studied: 18
Range: 010100110010101100101011 ..= 010110100101100001100010
Common prefix: 0101 length 4

Bits studied: 24
Range: 01010101001010110010101100101011 ..= 01010111011011000110100001101001
Common prefix: 010101 length 6

Bits studied: 30
Range: 0101011000110000001010110010101100101011 ..= 0101011001111010011110000110111101100001
Common prefix: 010101100 length 9

Bits studied: 36
Range: 010101100110101000101011001010110010101100101011 ..= 010101100110111001110000011110100110001001111010
Common prefix: 0101011001101 length 13

Bits studied: 42
Range: 01010110011011010011000000101011001010110010101100101011 ..= 01010110011011010111101001110111011001010110110101001010
Common prefix: 01010110011011010 length 17

Bits studied: 48
Range: 0101011001101101001100000010101100101011001010110010101100101011 ..= 0101011001101101001100010111101001100100011110100101011001110100
Common prefix: 01010110011011010011000 length 23
</div><label for=expansible2></label></div></code></pre><p>Итак, любая строка после восьмикратного применения к ней base64 будет начинаться с фиксированного префикса <code>01010110011011010011000</code> (<code>Vm?</code>, где <code>?</code> – <code>0</code> или <code>1</code>). Его длина достаточно большая для того, чтобы применить лемму о <eq><math><mrow><mi>n</mi><mo>≥</mo></mrow><mrow><mn>18</mn></mrow></math></eq> и сделать вывод, что каждый префикс <eq><math><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi><msup><mn>64</mn><mi>n</mi></msup><mo form=prefix stretchy=false>(</mo><mi>s</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> при достаточно большом <eq><math><mi>n</mi></math></eq> не зависит от <eq><math><mi>s</mi></math></eq>, причем длина этого префикса растет экспоненциально. Сильнее, чем так, сузиться сложно.<h3>Пределы</h3><p>Пусть от <eq><math><mi>s</mi></math></eq> префикс не зависит, но как он зависит от <eq><math><mi>n</mi></math></eq>? Вывод скрипта намекает, что есть некоторая одна длинная строка, к которой все стремится:<pre><code>0
01
0101
010101
010101100
0101011001101
01010110011011010
01010110011011010011000
</code></pre><p>Докажем это. Обозначим за <eq><math><mrow><mi>p</mi><mo form=prefix stretchy=false>(</mo><mi>s</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> максимальный гарантированный общий префикс среди всех строк <eq><math><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi><mn>64</mn><mo form=prefix stretchy=false>(</mo><mi>s</mi><mi>|</mi><mi>|</mi><mi>t</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq>. Обратите внимание, что это не то же самое, что операция перехода от одной строки из таблицы выше к следующей: таблица учитывала более строгие ограничения на исследуемые строки, чем префиксность. Например, <eq><math><mrow><mi>p</mi><mo form=prefix stretchy=false>(</mo><mn>0</mn><mo form=postfix stretchy=false>)</mo><mo>=</mo></mrow><mrow><mn>0</mn></mrow></math></eq>, а не <code>01</code>. Впрочем, <code>p(01010110011011010) = 01010110011011010011000</code> все еще верно, и этого нам хватит.<p>Доказательство будет по индукции. Пусть <eq><math><mi>s</mi></math></eq> – префикс <eq><math><mrow><mi>p</mi><mo form=prefix stretchy=false>(</mo><mi>s</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq>. Тогда, раз <eq><math><mrow><mi>p</mi><mo form=prefix stretchy=false>(</mo><mi>s</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> начинается с <eq><math><mi>s</mi></math></eq>, то и <eq><math><mrow><mi>p</mi><mo form=prefix stretchy=false>(</mo><mi>p</mi><mo form=prefix stretchy=false>(</mo><mi>s</mi><mo form=postfix stretchy=false>)</mo><mo form=postfix stretchy=false>)</mo></mrow></math></eq> начинается с <eq><math><mrow><mi>p</mi><mo form=prefix stretchy=false>(</mo><mi>s</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq>. <eq><math><mrow><mi>p</mi><mo form=prefix stretchy=false>(</mo><mi>s</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> по определению является префиксом в частности <eq><math><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi><mn>64</mn><mo form=prefix stretchy=false>(</mo><mi>p</mi><mo form=prefix stretchy=false>(</mo><mi>s</mi><mo form=postfix stretchy=false>)</mo><mo form=postfix stretchy=false>)</mo></mrow></math></eq> (ведь <eq><math><mrow><mi>p</mi><mo form=prefix stretchy=false>(</mo><mi>s</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> начинается с <eq><math><mi>s</mi></math></eq>). Аналогично, <eq><math><mrow><mi>p</mi><mo form=prefix stretchy=false>(</mo><mi>p</mi><mo form=prefix stretchy=false>(</mo><mi>s</mi><mo form=postfix stretchy=false>)</mo><mo form=postfix stretchy=false>)</mo></mrow></math></eq> является префиксом в частности <eq><math><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi><mn>64</mn><mo form=prefix stretchy=false>(</mo><mi>p</mi><mo form=prefix stretchy=false>(</mo><mi>s</mi><mo form=postfix stretchy=false>)</mo><mo form=postfix stretchy=false>)</mo></mrow></math></eq> (ведь <eq><math><mrow><mi>p</mi><mo form=prefix stretchy=false>(</mo><mi>s</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> начинается с <eq><math><mrow><mi>p</mi><mo form=prefix stretchy=false>(</mo><mi>s</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq>). Но более короткий префикс строки обязательно должен быть префиксом более длинного префикса той же строки, то есть <eq><math><mrow><mi>p</mi><mo form=prefix stretchy=false>(</mo><mi>s</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> – префикс <eq><math><mrow><mi>p</mi><mo form=prefix stretchy=false>(</mo><mi>p</mi><mo form=prefix stretchy=false>(</mo><mi>s</mi><mo form=postfix stretchy=false>)</mo><mo form=postfix stretchy=false>)</mo></mrow></math></eq>. Этот переход заканчивает доказательство.<h3>Свойства</h3><p>Теперь мы знаем, что предел существует и единственен. Как же он выглядит целиком?<pre><code class=language-python><span class=hljs-keyword>import</span> base64

n = <span class=hljs-number>23</span>
s = <span class=hljs-string>b"Vm0"</span>

<span class=hljs-keyword>for</span> _ <span class=hljs-keyword>in</span> <span class=hljs-built_in>range</span>(<span class=hljs-number>20</span>):
    n = n // <span class=hljs-number>6</span> * <span class=hljs-number>8</span>
    s = base64.b64encode(s)[:(n + <span class=hljs-number>7</span>) // <span class=hljs-number>8</span>]

<span class=hljs-built_in>print</span>(s[:n // <span class=hljs-number>8</span>].decode() + <span class=hljs-string>"..."</span>)
</code></pre><pre><code>Vm0wd2QyUXlVWGxWV0d4V1YwZDRWMVl3WkRSV01WbDNXa1JTVjAxV2JETlhhMUpUVmpBeFYySkVUbGhoTVVwVVZtcEJlRll5U2tW
VWJHaG9UVlZ3VlZadGNFSmxSbGw1VTJ0V1ZXSkhhRzlVVmxaM1ZsWmFkR05GU214U2JHdzFWVEowVjFaWFNraGhSemxWVm14YU0x
WnNXbUZrUjA1R1UyMTRVMkpIZHpGV1ZFb3dWakZhV0ZOcmFHaFNlbXhXVm0xNFlVMHhXbk5YYlVaclVqQTFSMVV5TVRSVk1rcEla
SHBHVjFaRmIzZFdha1poVjBaT2NtRkhhRk5sYlhoWFZtMHhORmxWTUhoWGJrNVlZbFZhY2xWcVFURlNNVlY1VFZSU1ZrMXJjRWxh
U0hCSFZqRmFSbUl6WkZkaGExcG9WakJhVDJOdFJraGhSazVzWWxob1dGWnRNSGhPUm14V1RVaG9XR0pyTlZsWmJGWmhZ...
</code></pre><p>Выглядит… случайно, как минимум ациклично. Это можно доказать в три шага.<p>Предположим, что эта предельная строка <eq><math><mi>s</mi></math></eq> “рациональная”, т.е. зацикливается с периодом ровно <eq><math><mi>k</mi></math></eq> с индекса <eq><math><mrow><mn>8</mn><mi>n</mi><mi>k</mi></mrow></math></eq> (или раньше). Тогда она циклится и с индекса <eq><math><mrow><mn>6</mn><mi>n</mi><mi>k</mi></mrow></math></eq> (ведь при раскодировании циклической строки получается циклическая) с тем же периодом <eq><math><mi>k</mi></math></eq> (ведь период строки не зависит от того, с какого места считать). Следовательно, <eq><math><mrow><mi>s</mi><mo form=prefix stretchy=false>[</mo><mn>8</mn><mi>n</mi><mi>k</mi><mo lspace=0.2222em rspace=0.2222em>:</mo><mo form=postfix stretchy=false>]</mo><mo>=</mo></mrow><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi><mn>64</mn><mo form=prefix stretchy=false>(</mo><mi>s</mi><mo form=prefix stretchy=false>[</mo><mn>6</mn><mi>n</mi><mi>k</mi><mo lspace=0.2222em rspace=0.2222em>:</mo><mo form=postfix stretchy=false>]</mo><mo form=postfix stretchy=false>)</mo><mo>=</mo></mrow><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi><mn>64</mn><mo form=prefix stretchy=false>(</mo><mi>s</mi><mo form=prefix stretchy=false>[</mo><mn>8</mn><mi>n</mi><mi>k</mi><mo lspace=0.2222em rspace=0.2222em>:</mo><mo form=postfix stretchy=false>]</mo><mo form=postfix stretchy=false>)</mo></mrow></math></eq>, то есть <eq><math><mrow><mi>s</mi><mo form=prefix stretchy=false>[</mo><mn>8</mn><mi>n</mi><mi>k</mi><mo lspace=0.2222em rspace=0.2222em>:</mo><mo form=postfix stretchy=false>]</mo></mrow></math></eq> – неподвижная точка base64; но такая точка одна, сама <eq><math><mi>s</mi></math></eq>. Значит, <eq><math><mi>s</mi></math></eq> на самом деле не просто “рациональная”, а циклическая строка.<p>Оценим теперь период <eq><math><mi>s</mi></math></eq>. Если <eq><math><mi>k</mi></math></eq> – минимальный период, то <eq><math><mrow><mn>8</mn><mi>k</mi><mi>/</mi><mo form=prefix stretchy=false>(</mo><mn>8</mn><mo separator=true>,</mo><mi>k</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> – также период. Поскольку <eq><math><mrow><mi>s</mi><mo>=</mo></mrow><mrow><mi>s</mi><mo form=prefix stretchy=false>[</mo><mn>8</mn><mi>k</mi><mi>/</mi><mo form=prefix stretchy=false>(</mo><mn>8</mn><mo separator=true>,</mo><mi>k</mi><mo form=postfix stretchy=false>)</mo><mo lspace=0.2222em rspace=0.2222em>:</mo><mo form=postfix stretchy=false>]</mo></mrow></math></eq>, <eq><math><mrow><mi>s</mi><mo>=</mo></mrow><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi><msup><mn>64</mn><mrow><mo lspace=0em rspace=0em>−</mo><mn>1</mn></mrow></msup><mo form=prefix stretchy=false>(</mo><mi>s</mi><mo form=postfix stretchy=false>)</mo><mo>=</mo></mrow><mrow><mi>b</mi><mi>a</mi><mi>s</mi><mi>e</mi><msup><mn>64</mn><mrow><mo lspace=0em rspace=0em>−</mo><mn>1</mn></mrow></msup><mo form=prefix stretchy=false>(</mo><mi>s</mi><mo form=prefix stretchy=false>[</mo><mn>8</mn><mi>k</mi><mi>/</mi><mo form=prefix stretchy=false>(</mo><mn>8</mn><mo separator=true>,</mo><mi>k</mi><mo form=postfix stretchy=false>)</mo><mo lspace=0.2222em rspace=0.2222em>:</mo><mo form=postfix stretchy=false>]</mo><mo form=postfix stretchy=false>)</mo><mo>=</mo></mrow><mrow><mi>s</mi><mo form=prefix stretchy=false>[</mo><mn>6</mn><mi>k</mi><mi>/</mi><mo form=prefix stretchy=false>(</mo><mn>8</mn><mo separator=true>,</mo><mi>k</mi><mo form=postfix stretchy=false>)</mo><mo lspace=0.2222em rspace=0.2222em>:</mo><mo form=postfix stretchy=false>]</mo></mrow></math></eq>, т.е. <eq><math><mrow><mn>6</mn><mi>k</mi><mi>/</mi><mo form=prefix stretchy=false>(</mo><mn>8</mn><mo separator=true>,</mo><mi>k</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> – период. Любой период делится на минимальный период, поэтому в частности <eq><math><mrow><mi>k</mi><mi>|</mi><mn>6</mn><mi>k</mi><mi>/</mi><mo form=prefix stretchy=false>(</mo><mn>8</mn><mo separator=true>,</mo><mi>k</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq>, откуда <eq><math><mrow><mo form=prefix stretchy=false>(</mo><mn>8</mn><mo separator=true>,</mo><mi>k</mi><mo form=postfix stretchy=false>)</mo><mi>|</mi><mn>6</mn></mrow></math></eq>, или, иными словами, <eq><math><mi>k</mi></math></eq> не кратно <eq><math><mn>4</mn></math></eq>.<p>Для дальнейшего перехода придется воспользоваться свойствами конкретного алфавита base64. Раз <eq><math><mi>s</mi></math></eq> начинается с <code>0101011001101101</code>, то и <eq><math><mrow><mi>s</mi><mo form=prefix stretchy=false>[</mo><mi>k</mi><mo lspace=0.2222em rspace=0.2222em>:</mo><mo form=postfix stretchy=false>]</mo></mrow></math></eq> начинается с <code>0101011001101101</code>. Разобьем эту строку по октетам. В зависимости от <eq><math><mrow><mi>k</mi><mo lspace=0.2222em rspace=0.2222em>mod</mo></mrow><mrow><mn>8</mn></mrow></math></eq> это разбиение может выглядеть одним из следующих способов:<ul><li><eq><math><mrow><mi>k</mi><mo lspace=0.2222em rspace=0.2222em>mod</mo></mrow><mrow><mn>8</mn><mo>=</mo></mrow><mrow><mn>0</mn></mrow></math></eq> – невозможно по предыдущему параграфу<li><eq><math><mrow><mi>k</mi><mo lspace=0.2222em rspace=0.2222em>mod</mo></mrow><mrow><mn>8</mn><mo>=</mo></mrow><mrow><mn>1</mn></mrow></math></eq> – <code>?0101011 00110110 1???????</code><li><eq><math><mrow><mi>k</mi><mo lspace=0.2222em rspace=0.2222em>mod</mo></mrow><mrow><mn>8</mn><mo>=</mo></mrow><mrow><mn>2</mn></mrow></math></eq> – <code>??010101 10011011 01??????</code><li><eq><math><mrow><mi>k</mi><mo lspace=0.2222em rspace=0.2222em>mod</mo></mrow><mrow><mn>8</mn><mo>=</mo></mrow><mrow><mn>3</mn></mrow></math></eq> – <code>???01010 11001101 101?????</code><li><eq><math><mrow><mi>k</mi><mo lspace=0.2222em rspace=0.2222em>mod</mo></mrow><mrow><mn>8</mn><mo>=</mo></mrow><mrow><mn>4</mn></mrow></math></eq> – невозможно по предыдущему параграфу<li><eq><math><mrow><mi>k</mi><mo lspace=0.2222em rspace=0.2222em>mod</mo></mrow><mrow><mn>8</mn><mo>=</mo></mrow><mrow><mn>5</mn></mrow></math></eq> – <code>?????010 10110011 01101???</code><li><eq><math><mrow><mi>k</mi><mo lspace=0.2222em rspace=0.2222em>mod</mo></mrow><mrow><mn>8</mn><mo>=</mo></mrow><mrow><mn>6</mn></mrow></math></eq> – <code>??????01 01011001 101101??</code><li><eq><math><mrow><mi>k</mi><mo lspace=0.2222em rspace=0.2222em>mod</mo></mrow><mrow><mn>8</mn><mo>=</mo></mrow><mrow><mn>7</mn></mrow></math></eq> – <code>???????0 10101100 1101101?</code></ul><p>В каждом из этих вариантов обязательно найдется октет с единицей в старшем бите, а в выводе base64 такого не бывает. Противоречие.<h3>Генерация</h3><p>Ацикличные последовательности помимо математических свойств интересны тем, что генерировать их с конечным объемом памяти в RAM-модели невозможно. С <eq><math><mrow><mi>O</mi><mo form=prefix stretchy=false>(</mo><mi>n</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> памяти генерировать мы уже умеем, для этого много ума не надо: бери да итерируй. Можно ли лучше?<p>Да, можно. Предложим алгоритм, возвращающий по числу <eq><math><mi>n</mi></math></eq> значения битов на позициях <eq><math><mrow><mi>n</mi><mo separator=true>,</mo></mrow><mrow><mi>n</mi><mo>+</mo></mrow><mrow><mn>1</mn><mo separator=true>,</mo></mrow><mrow><mo>…</mo></mrow><mrow><mo separator=true>,</mo></mrow><mrow><mi>n</mi><mo>+</mo></mrow><mrow><mn>23</mn></mrow></math></eq>. (Почему так много сейчас станет понятно.) Эти <eq><math><mn>24</mn></math></eq> бита каким-то образом содержатся в октетах с индексами границ, кратными <eq><math><mn>8</mn></math></eq>. В общем случае это будет четыре октета на некоторых позициях <eq><math><mrow><mo form=prefix stretchy=false>[</mo><mn>8</mn><mi>k</mi><mo separator=true>;</mo><mn>8</mn><mi>k</mi><mo>+</mo><mn>32</mn><mo form=postfix stretchy=false>)</mo></mrow></math></eq>, которые однозначно восстанавливаются из четырех сексетов на позициях <eq><math><mrow><mo form=prefix stretchy=false>[</mo><mn>6</mn><mi>k</mi><mo separator=true>;</mo><mn>6</mn><mi>k</mi><mo>+</mo><mn>24</mn><mo form=postfix stretchy=false>)</mo></mrow></math></eq>. А для того, чтобы узнать эти <eq><math><mn>24</mn></math></eq> бита, достаточно сделать рекурсивный вызов к тому же алгоритму. Осталось не забыть про базу рекурсии <eq><math><mrow><mi>n</mi><mo>=</mo></mrow><mrow><mn>0</mn></mrow></math></eq> с захардкоженным значением <code>010101100110110100110000</code>. На один такой запрос уходит <eq><math><mrow><mi>O</mi><mo form=prefix stretchy=false>(</mo><mrow><mi>log</mi><mo>⁡</mo><mspace width=0.1667em></mspace></mrow><mi>n</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> времени и столько же памяти. Суммарно для генерации строки длины <eq><math><mi>n</mi></math></eq> понадобится <eq><math><mrow><mi>O</mi><mo form=prefix stretchy=false>(</mo><mi>n</mi><mrow><mspace width=0.1667em></mspace><mi>log</mi><mo>⁡</mo><mspace width=0.1667em></mspace></mrow><mi>n</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> времени и <eq><math><mrow><mi>O</mi><mo form=prefix stretchy=false>(</mo><mrow><mi>log</mi><mo>⁡</mo><mspace width=0.1667em></mspace></mrow><mi>n</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> памяти.<p>Напоследок статистическое свойство. В <eq><math><mn>492</mn></math></eq>-символьной строке из примера выше символ <code>V</code> встречается <eq><math><mn>45</mn></math></eq> раз, а <code>f</code> не встречается ни разу. Почему? base64 переводит <code>010101</code> в <code>01010110</code> (<code>V</code>), по сути размножая ее на каждом шагу. А вот <code>f</code> получается из <code>011111</code>, который получиться может только из октетов <code>011111??</code>, <code>??????01 1111????</code>, <code>????0111 11??????</code>, <code>??011111</code>; ни один из вариантов не состоит исключительно из символов из алфавита base64, т.е. <code>f</code> не может появиться вот вообще никак.<p>Короче говоря, использовать эту строку как источник рандома не стоит. Но если хочется полюбоваться, вот ✨ ОНА ✨:<hr><pre><code>Vm0wd2QyUXlVWGxWV0d4V1YwZDRWMVl3WkRSV01WbDNXa1JTVjAxV2JETlhhMUpUVmpBeFYySkVUbGhoTVVwVVZtcEJlRll5U2tW
VWJHaG9UVlZ3VlZadGNFSmxSbGw1VTJ0V1ZXSkhhRzlVVmxaM1ZsWmFkR05GU214U2JHdzFWVEowVjFaWFNraGhSemxWVm14YU0x
WnNXbUZrUjA1R1UyMTRVMkpIZHpGV1ZFb3dWakZhV0ZOcmFHaFNlbXhXVm0xNFlVMHhXbk5YYlVaclVqQTFSMVV5TVRSVk1rcEla
SHBHVjFaRmIzZFdha1poVjBaT2NtRkhhRk5sYlhoWFZtMHhORmxWTUhoWGJrNVlZbFZhY2xWcVFURlNNVlY1VFZSU1ZrMXJjRWxh
U0hCSFZqRmFSbUl6WkZkaGExcG9WakJhVDJOdFJraGhSazVzWWxob1dGWnRNSGhPUm14V1RVaG9XR0pyTlZsWmJGWmhZMnhXY1ZG
VVJsTk5WbFkxVkZaU1UxWnJNWEpqUld4aFUwaENTRlpxUm1GU2JVbDZXa1prYUdFeGNHOVdha0poVkRKT2RGSnJhR2hTYXpWeldX
eG9iMWRHV25STlNHaFBVbTE0VjFSVmFHOVhSMHB5VGxac1dtSkdXbWhaTW5oWFkxWkdWVkpzVGs1V2JGa3hWa1phVTFVeFduSk5X
RXBxVWxkNGFGVXdhRU5UUmxweFVtMUdVMkpWYkRaWGExcHJZVWRGZUdOSE9WZGhhMHBvVmtSS1QyUkdTbkpoUjJoVFlYcFdlbGRY
ZUc5aU1XUkhWMjVTVGxOSGFGQlZiVEUwVmpGU1ZtRkhPVmhTTUhCNVZHeGFjMWR0U2tkWGJXaGFUVzVvV0ZreFdrZFdWa3B6Vkdz
MVYySkdhM2hXYTFwaFZURlZlRmR1U2s1WFJYQnhWV3hrTkdGR1ZYZGhSVTVVVW14d2VGVnRNVWRWTWtwV1lrUmFXR0V4Y0hKWlZX
UkdaVWRPU0U5V1pHaGhNSEJ2Vm10U1MxUXlVa2RUYmtwb1VqSm9WRmxZY0ZkbGJHUllaVWM1YVUxWFVraFdNalZUVkd4T1NHRkdR
bFppVkVVd1ZtcEdVMVp0UmtoUFZtaFRUVWhDTlZaSGVHRmpNV1IwVTJ0a1dHSlhhR0ZVVnpWdlYwWnJlRmRyWkZkV2EzQjZWa2R6
TVZZeVNrZGhNMmhYWVRGd2FGWlVSbFpsUm1SMVUyczFXRkpZUW5oV1YzaHJUa2RHUjFaWVpHaFNWVFZWVlcxNGQyVkdWblJOVldS
V1RXdHdWMWxyVW1GWFIwVjRZMGhLV2xaWFVrZGFWV1JQVTBVNVYxcEhhR2hOU0VKMlZtMTBVMU14VVhsVmEyUlVZbXR3YjFWcVNt
OVdSbXhaWTBaa2JHSkhVbGxhVldNMVlWVXhXRlZyYUZkTmFsWlVWa2Q0VDFOSFJrZFJiRnBwVmtWVmQxWnRjRWRWTVZwMFVtdG9V
Rlp0YUZSVVZXaERUbFphU0dWSFJtcE5WMUl3VlRKMGExZEhTbGhoUjBaVlZucFdkbFl3V25KbFJtUnlXa1prVjJFelFqWldhMlI2
VFZaWmVWTnJaR2hOTW1oWVdWUkdkMkZHV2xWU2JGcHNVbTFTTVZVeWN6RlhSa3BaVVc1b1YxWXphSEpVYTJSSFVqRmFXVnBIYUZO
V1ZGWldWbGN4TkdReVZrZFdibEpPVmxkU1YxUlhkSGRXTVd4eVZXMUdXRkl3VmpSWk1HaExWMnhhV0ZWclpHRldWMUpRVlRCVk5W
WXhjRWhoUjJoT1UwVktNbFp0TVRCVk1VMTRWVmhzVm1FeVVsVlpiWFIzWWpGV2NWTnRPVmRTYlhoYVdUQmFhMkpIU2toVmJHeGhW
bGROTVZsV1ZYaFhSbFp5WVVaa1RtRnNXbFZXYTJRMFZERk9TRkpyWkZKaVJuQndWbXRXVm1ReFduUmpSV1JXVFZad01GVnRkRzlW
UmxwMFlVWlNWVlpYYUVSVWJGcGhVMGRXU0ZKdGNFNVdNVWwzVmxSS01HRXhaRWhUYkdob1VqQmFWbFp1Y0Zka2JGbDNWMjVLYkZK
dFVubFhhMXByVmpKRmVsRnFXbGRoTWxJMlZGWmFXbVZXVG5KYVIyaE9UVzFvV1ZkV1VrZGtNa1pIVjJ4V1UySkdjSE5WYlRGVFRW
WlZlV042UmxoU2EzQmFWVmMxYjFZeFdYcGhTRXBWWVRKU1NGVnFSbUZYVm5CSVlVWk9WMVpHV2xkV2JHTjRUa2RSZVZaclpGZGli
RXBQVm14a1UxWXhVbGhrU0dSWFRWZDRlVlpYTVVkWFJrbDNWbXBTV2sxSGFFeFdNbmhoVjBaV2NscEhSbGRXTVVwUlZsUkNWazVX
V1hoalJXaG9VakpvVDFVd1ZrdE5iRnAwVFZSQ1ZrMVZNVFJXVm1oelZtMUZlVlZzVmxwaVdGSXpXV3BHVjJOV1RuUlBWbVJUWWxo
b1lWZFVRbUZoTWtwSVUydG9WbUpIZUdoV2JHUk9UVlpzVjFaWWFGaFNiRnA1V1ZWYWExUnRSbk5YYkZaWFlUSlJNRlpFUms5VFJr
cHlXa1pLYVZKdVFuZFdiWFJYVm0xUmVGZHVVbXBTVjFKWFZGWmFkMDFHVm5Sa1J6bFdVbXh3TUZsVldsTldWbHBZWVVWU1ZXSkdj
R2hWTUdSWFUwWktkR05GTlZkTlZXd3pWbXhTUzAxSFJYaGFSV2hVWWtkb2IxVnFRbUZXYkZwMVkwWmthMkpHYkROV01qVkxZa1pL
ZEZWdWJGaGhNWEJ5Vm1wS1JtVnNSbkZYYkdSb1RXeEpNbFpHV21GWGJWWlhWRzVLWVZJeWFFOVVWekZ2VjFaa1YxVnJaR3ROYTFw
SVZqSjRWMVV5U2tkalNFNVdZbFJHVkZSV1dsWmxWMDQyVW14b1UyRXpRbUZXVm1NeFlqRlplRmRZY0doVFJYQldXVlJLVTFOR1Zu
RlNiVVpZVm01Q1NWbFZXazlXTVZwSFYyeGtWMkpIVGpSVWEyUlNaVlphY2xwR1pHbGlSWEJRVm0xNGExVXhXWGhWYkdoclUwZFNX
RlJXWkRSbFZscFlUVlZrV0ZKcmJETldiWEJUVjJzeFNHRkZlRmROYm1ob1ZqQmFWMk5zY0VoU2JHUlhUVlZ3VWxac1VrTldhelZY
VjFob2FsSlhhRzlWYWtwdlZERlZkMVpyZEU1aVJuQXdWRlpTUTFack1WWk5WRkpYVm0xb2VsWnRNVVpsVmxaelZteHdhVmRHU1hw
WFYzQkhWakpPVjFSdVVsQldiVkpVV1d4b2IxbFdaRlZSYlVab1RXdHdTVlV5ZEc5V2JVcElaVWRvVjJKSFVrOVVWbHB6VmpGYVdX
RkdhRk5pUm5BMVYxWldZV0V4VW5SU2JrNVlZa1phV0ZsVVNsSk5SbHBGVW1zNVZGSnJjSGxYYTFwTFlWWktkVkZ1WkZkaVdGSllW
bTB4VW1WR1pIVlZiWEJUVmpGS1dGWkdXbUZrTURGSFZtNVNhMUo2YkZkVmJYaDNUVVpzVmxkc1RsZFdiSEJaV1ZWV1UxWlhTa2Rq
UjJoV1RVZFNXRlV3V2t0a1IwNUdUbFprVGxaWGQzcFdiWGhUVXpBeFNGSllhR0ZTVjJoVldXdGtiMkl4Vm5GUmJVWlhZa1p3TVZr
d1dtdGhNa3BIWWtST1YwMXFWa3haYTFwTFpFWldkV0pHYUdoTldFSjVWbTF3UzFKdFZuTlNia1pZWWtkU2IxUlhlRXBOYkZwSFYy
MUdXR0pXV2xoV1J6VkxXVlpKZVdGRk9WVldla1oyVmpGYWExWXhWbkphUjNST1lURndTVlpxU2pSV01WVjVVMnRrYWxORk5WZFpi
RkpIVmtaU1YxZHNXbXhXTURReVZXMTRiMVV5UlhwUmJVWlhWbTFOZUZscVJscGxSbVJaWTBkb1ZGSllRbGRYVmxKTFZURk9SMVp1
UmxOaVZWcFpWbTAxUTFOV2JGWlhhemxYVFZad1NGWXllR3RXTWtwSVZHcFNWV0V5VWxOYVZscGhZMnh3UjFwSGJHbFNXR...
</code></pre></div></section><footer><div class=viewport-container><h2>Made with my own bare hands (why.)</h2></div></footer>