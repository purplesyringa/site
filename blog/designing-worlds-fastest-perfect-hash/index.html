<!doctypehtml><html prefix="og: http://ogp.me/ns#"lang=en_US><meta charset=utf-8><meta content=width=device-width,initial-scale=1 name=viewport><title>h: Practical, efficient perfect hash functions | purplesyringa's blog</title><link href=../../favicon.ico?v=2 rel=icon><link href=../../all.css rel=stylesheet><link href=../../blog.css rel=stylesheet><link href=../../vendor/Temml-Local.css rel=stylesheet><link crossorigin href=https://fonts.googleapis.com/css2?family=Noto+Sans:ital,wght@0,100..900;1,100..900&family=Roboto+Mono:ital,wght@0,100..700;1,100..700&family=Roboto:ital,wght@0,400;0,700;1,400;1,700&family=Slabo+27px&display=swap rel=stylesheet><link href=../../fonts/webfont.css rel=stylesheet><link media="screen and (prefers-color-scheme: dark"href=../../vendor/atom-one-dark.min.css rel=stylesheet><link media="screen and (prefers-color-scheme: light"href=../../vendor/a11y-light.min.css rel=stylesheet><link title="Blog posts"href=../../blog/feed.rss rel=alternate type=application/rss+xml><meta content="h: Practical, efficient perfect hash functions"property=og:title><meta content=article property=og:type><meta content=https://purplesyringa.moe/blog/designing-worlds-fastest-perfect-hash/og.png property=og:image><meta content=https://purplesyringa.moe/blog/designing-worlds-fastest-perfect-hash/ property=og:url><meta content="I need a hash-table with integer keys. HashMap , right? Wrong. For plot reasons, I need it to perform at ridiculous speeds. So that’s how the journey towards the fastest perfect hash function started."property=og:description><meta content=en_US property=og:locale><meta content="purplesyringa's blog"property=og:site_name><meta content=summary_large_image name=twitter:card><meta content=https://purplesyringa.moe/blog/designing-worlds-fastest-perfect-hash/og.png name=twitter:image><script data-website-id=0da1961d-43f2-45cc-a8e2-75679eefbb69 defer src=https://zond.tei.su/script.js></script><body><header><div class=viewport-container><div class=media><a href=https://github.com/purplesyringa><img alt=GitHub src=../../images/github-mark-white.svg></a></div><h1><a href=/>purplesyringa</a></h1><nav><a href=../..>about</a><a class=current href=../../blog/>blog</a><a href=../../sink/>kitchen sink</a></nav></div></header><section><div class=viewport-container><h2>h: Practical, efficient perfect hash functions</h2><time>November 25, 2024</time><p>Hash tables are frequently used in programming. Often, they are mostly static and only require read-only access after building. At this point, we encounter a tradeoff between build time and access time.<p><a href=http://127.0.0.1:8000/blog/you-might-want-to-use-panics-for-error-handling/>For plot reasons</a>, I need a static hash table with integer keys with blazingly fast access times. <code>HashMap&LTu32, T></code> is quite slow, and, surprisingly, so is <a href=https://docs.rs/phf/latest/phf/>phf</a> – the default solution for this problem in the Rust ecosystem.<p>I tried to replace the hash functions in the official benchmarks with no-ops, and still got <eq><math><mn>5</mn></math></eq> ns per access – more than I’m willing to pay. In addition, the build time for <code>phf</code> sucks. Sure, I can spend some time preprocessing the table, but I’d like it to not take much more than a second to process a few million keys.<div class=aside-group><aside><p>I’m notorious for developing projects so that I can get a claim to their name rather than to make something good; that’s just a common side effect.<p><code>h</code> stands for hydrogen, because <code>h</code> is supposed to be as lightweight as reasonably possible on modern architectures. If you need a longer name, use <code>hPHF</code>, where <code>h</code> can either stand for hydrogen or “hybrid”, as the math behind <code>h</code> is based on taking the best from several known approaches to building PHFs.</aside><p class=next-group><span aria-level=3 class=side-header role=heading><span>h</span></span>So I made <a href=https://lib.rs/h>a better perfect hash: h</a>.</div><p>…<p class=next-group><span aria-level=3 class=side-header role=heading><span>Comparison</span></span>In my opinion, <code>h</code> is quite competitive. It’s not very mathematically rigorous at the moment, although I believe this can be fixed with enough effort.<p>The <code>phf</code> crate takes <eq><math><mn>4.3</mn></math></eq> seconds to build a PHF with <eq><math><msup><mn>10</mn><mn>6</mn></msup></math></eq> integer <eq><math><mn>32</mn></math></eq>-bit keys. (That’s with SipHash, which I couldn’t avoid because any faster lazy hashes I tried to throw at <code>phf</code> lead to hangs and infinite loops.) In comparison, <code>h</code> does that in <eq><math><mn>140</mn></math></eq> ms – <eq><math><mrow><mn>30</mn><mo>×</mo></mrow></math></eq> faster. (It scales worse than linearly for larger sizes due to cache effects, but still reasonably well.)<p><code>phf</code> takes <eq><math><mn>14.5</mn></math></eq> ns to resolve an element in a <eq><math><mn>26</mn></math></eq>-element hash map keyed by random <eq><math><mn>32</mn></math></eq>-bit integers generated with a proc macro. If you hack the code and replace the hash with the fastest one that works, the time falls down to <eq><math><mn>3.9</mn></math></eq> ns. In contrast, <code>h</code> takes <eq><math><mn>2.3</mn></math></eq> ns to resolve it with the map <em>generated in runtime</em>, i.e. without constant propagation, and <eq><math><mn>2.0</mn></math></eq> ns with compile time generation.<p>Unlike <code>phf</code> and <code>boomphf</code>, <code>h</code> is not a <em>minimal</em> PHF, but <em>a</em> PHF. This means that <code>h</code> wastes some memory in the hash table by design. In return, <code>h</code> takes less space for control information, so the overall memory use stays about the same for small objects and large datasets.<p>For the same reason, <code>h</code> is significantly less picky about the quality of the underlying imperfect hash than <code>phf</code>, which requires SipHash. This enables faster hashes like <code>wyhash</code> to be used.<p>Much like <code>phf</code>, the memory utilization is spread between two arrays, storing data and control information separately. The sizes of the arrays are, however, much more skewed than in <code>phf</code>, leading to better performance when only the smaller control array fits in cache.<p><code>boomphf</code> builds hash functions <eq><math><mn>2</mn></math></eq> – <eq><math><mrow><mn>3</mn><mo>×</mo></mrow></math></eq> faster than <code>h</code>, but its access time stays at around <eq><math><mn>40</mn></math></eq> ns per key regardless of the hash function. This can be easily explained: <code>boomphf</code> has variable-time access performance and requires quite a bit of pointer jumping. In contrast, <code>h</code> supports constant-time accesses and performs just one memory read apart from the accessed entry.<p>On large data, <code>h</code> takes about <eq><math><mrow><mn>5</mn><mo>×</mo></mrow></math></eq> more time to build than <code>HashMap</code>.<p class=next-group><span aria-level=3 class=side-header role=heading><span>Scope</span></span><code>h</code> does not support all key types, and manually implementing a custom <code>PortableHash</code> trait (similar to <code>Hash</code> from std) might be necessary.<p>Although <code>h</code> was originally tuned to small integer keys, it provides good performance with any keys. Even if the access time turns out to be similar to alternatives, <code>h</code> takes relatively little to build. This matters for hashing large data, programmatically generated data, and building in runtime.<p>Finally, <code>h</code> provides constant access time, which is important for real-time systems and predictable performance.<h2>Theory</h2><p class=next-group><span aria-level=3 class=side-header role=heading><span>Intro</span></span>If you’re interested, .<blockquote><p>I’m experimenting with writing styles. This is not as formal as I’d like it to be (I’m hoping to write a paper on this topic eventually), but I wanted this to be an introduction to PHF construction too. We’ll see how it goes.</blockquote><p class=next-group><span aria-level=3 class=side-header role=heading><span>PHFs</span></span><em>Perfect hash functions</em> are hash functions trained on a particular key set, with a lucky property that the hashes of these keys don’t collide.<p>For example, for the key set <eq><math><mrow><mo form=prefix stretchy=false>{</mo><mn>12534</mn><mo separator=true>,</mo><mn>12421</mn><mo separator=true>,</mo><mn>123567</mn><mo form=postfix stretchy=false>}</mo></mrow></math></eq>, <eq><math><mrow><mi>H</mi><mo form=prefix stretchy=false>(</mo><mi>x</mi><mo form=postfix stretchy=false>)</mo><mo>=</mo></mrow><mrow><mi>x</mi><mi>&</mi><mn>3</mn></mrow></math></eq> is a valid PHF, because the hashes of the set are <eq><math><mrow><mo form=prefix stretchy=false>{</mo><mn>3</mn><mo separator=true>,</mo><mn>2</mn><mo separator=true>,</mo><mn>1</mn><mo form=postfix stretchy=false>}</mo></mrow></math></eq> with no collisions. Note that collisions may arise if <em>other</em> unlisted keys are hashed: this is not considered a problem.<p>After the PHF is built, we can just put the metadata into an array like this:<pre><code class=language-rust><span class=hljs-keyword>let</span> <span class=hljs-variable>hashtable</span> = [
    <span class=hljs-literal>None</span>,
    <span class="hljs-title function_ invoke__">Some</span>((<span class=hljs-number>123567</span>, value <span class=hljs-keyword>for</span> <span class=hljs-number>123567</span>)),
    <span class="hljs-title function_ invoke__">Some</span>((<span class=hljs-number>12421</span>, value <span class=hljs-keyword>for</span> <span class=hljs-number>12421</span>)),
    <span class="hljs-title function_ invoke__">Some</span>((<span class=hljs-number>12534</span>, value <span class=hljs-keyword>for</span> <span class=hljs-number>12534</span>)),
];
</code></pre><p>…and access it like this:<pre><code class=language-rust><span class=hljs-keyword>fn</span> <span class="hljs-title function_">get</span>(key: <span class=hljs-type>u32</span>) <span class=hljs-punctuation>-></span> <span class=hljs-type>Option</span>&LTValue> {
    <span class=hljs-keyword>let</span> (stored_key, value) = hashtable[<span class="hljs-title function_ invoke__">hash</span>(key)]?;
    <span class=hljs-comment>// If the keys match, this key was present in the original keyset and we can return the value.</span>
    <span class=hljs-comment>// If the keys don't match, this is an unlisted key and we can return None.</span>
    (key == stored_key).<span class="hljs-title function_ invoke__">then_some</span>(value)
}
</code></pre><p class=next-group><span aria-level=3 class=side-header role=heading><span>Spooky math</span></span>The hash function clearly can’t be perfect for <em>all</em> keys, so it should depend on the key space. There’s many different key spaces, so there must be many different PHFs, and that means they have to store <em>data</em> that somehow corresponds to the key space. So a PHF is not just <em>code</em>, but also a set of <em>lookup-up tables</em>.<p>Most constant-time PHFs (and we do need constant time, because any unpredictable conditional jumps are fatal at this scale) use the following approach. Firstly, two <em>imperfect</em> random hash functions are chosen: <eq><math><mrow><mi>A</mi><mi>p</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>x</mi></mrow></math></eq> and <eq><math><mrow><mi>B</mi><mi>u</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>t</mi></mrow></math></eq>. <eq><math><mrow><mi>A</mi><mi>p</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>x</mi></mrow></math></eq> maps the key to its approximate hash (i.e. position in the hash table), while <eq><math><mrow><mi>B</mi><mi>u</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>t</mi></mrow></math></eq> maps the key to its bucket ID. For each bucket, a <em>displacement</em> value is stored in the look-up table, which is mixed with the approximate hash to obtain the final hash.<p>The idea is that while <eq><math><mrow><mi>A</mi><mi>p</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>x</mi></mrow></math></eq> hashes might collide, as long as the colliding keys are from different buckets, we can choose different displacements to avoid the collision. If a particular <eq><math><mrow><mo form=prefix stretchy=false>(</mo><mrow><mi>A</mi><mi>p</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>x</mi></mrow><mo separator=true>,</mo><mrow><mi>B</mi><mi>u</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>t</mi></mrow><mo form=postfix stretchy=false>)</mo></mrow></math></eq> combination still leads to collisions, we just choose another pair of imperfect hash functions and try again.<p>We control (and need to choose):<ul><li>The size of the hash space <eq><math><mi>M</mi></math></eq><li>The number of buckets <eq><math><mi>B</mi></math></eq><li>How the displacement is mixed into the hash<li>The displacement range<li><eq><math><mrow><mi>A</mi><mi>p</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>x</mi></mrow></math></eq> and <eq><math><mrow><mi>B</mi><mi>u</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>t</mi></mrow></math></eq></ul><p>Off we go.<p class=next-group><span aria-level=3 class=side-header role=heading><span>Hash space</span></span>We could round the number of keys to the next power of two and use that as the hash space size. This simplifies calculations, because taking a number modulo <eq><math><msup><mn>2</mn><mi>n</mi></msup></math></eq> is trivial. However, this wastes a lot of space in the hashtable. In my use case, the metadata is quite large, and storing a <code>Box&LTMetadata></code> is not an option, because indirections are slow.<p>Alternatively, we could equate the hash space size to the key space size. This is called a <em>minimal</em> PHF. Obviously, the probability of collision increases significantly as the number of free locations decreases, so building an mPHF is very slow compared to a non-minimal PHF.<div class=aside-group><aside><p>PTHash then transforms this almost-mPHF to an mPHF with a separate look-up table. That introduces a conditional branch and an indirection, which would leads to a major performance loss, so we have to bite the bullet and pay the <eq><math><mrow><mn>1</mn><mi>%</mi></mrow></math></eq> space increase.</aside><p>Finally, we could choose an in-between option. The authors of <a href=https://arxiv.org/pdf/2104.10402>PTHash</a> have found that using a <eq><math><mn>0.99</mn></math></eq> load factor (i.e. increasing the hash space size by <eq><math><mrow><mn>1</mn><mi>%</mi></mrow></math></eq>) significantly improves build time performance without increasing the memory use much, so that’s what we’re going to use.</div><p class=next-group><span aria-level=3 class=side-header role=heading><span>Bucket count</span></span>The number of buckets is a balance between memory consumption and build time. With <eq><math><mrow><mi>B</mi><mo>=</mo></mrow><mrow><mi>N</mi></mrow></math></eq>, the behavior is similar to cuckoo hashing, with all the space utilization problems. With <eq><math><mrow><mi>B</mi><mo>=</mo></mrow><mrow><mn>1</mn></mrow></math></eq>, the PHF degenerates to “use a random imperfect hash and hope for the best”.<p>This question is also tightly connected to the choice of <eq><math><mrow><mi>B</mi><mi>u</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>t</mi></mrow></math></eq> (which maps the key to its bucket). There are two common choices:<ul><li><a href=https://cmph.sourceforge.net/papers/esa09.pdf>CHD</a>: Choose a <em>uniform</em> <eq><math><mrow><mi>B</mi><mi>u</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>t</mi></mrow></math></eq>, with <eq><math><mn>5</mn></math></eq> keys per bucket on average (<eq><math><mrow><mi>B</mi><mo>=</mo></mrow><mrow><mfrac><mn>1</mn><mn>5</mn></mfrac><mi>N</mi></mrow></math></eq>)<li><a href=https://cmph.sourceforge.net/papers/fch92.pdf>FCH</a>: Choose a <em>significantly non-uniform</em> <eq><math><mrow><mi>B</mi><mi>u</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>t</mi></mrow></math></eq>, with <eq><math><mrow><mi>B</mi><mo>=</mo></mrow><mrow><mfrac><mrow><mn>6</mn><mi>N</mi></mrow><mrow><mspace width=0.1667em></mspace><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mspace width=0.1667em></mspace><mi>N</mi></mrow></mfrac></mrow></math></eq>.</ul><p>Using a non-uniform <eq><math><mrow><mi>B</mi><mi>u</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>t</mi></mrow></math></eq> sounds weird, but it’s actually intuitive when you think about it. To generate the bucket displacements, we’re going to process them in order. At the beginning of this process, the load factor is low, so almost every displacement works, but then it gets harder and harder. It is thus better to start with large buckets and work our way down to smaller buckets. Non-uniformity helps use this relation to reduce the number of buckets without sacrificing build time.<p>However, non-uniformity is hard to come by in practice. Usually, it’s achieved by computing a uniform hash and then skewing it artificially. This scaling takes time, which we have little of, so we’ll have to use the CHD approach.<p class=next-group><span aria-level=3 class=side-header role=heading><span>Mix function</span></span>There are many approaches to displacing the hash. As the approximate hash is uniformly random, the displacement itself does not necessarily have to be random. This means that we can just try adding <eq><math><mrow><mn>0</mn><mo separator=true>,</mo></mrow><mrow><mn>1</mn><mo separator=true>,</mo></mrow><mrow><mn>2</mn><mo separator=true>,</mo></mrow><mrow><mo>…</mo></mrow></math></eq> to the approximate hash, or maybe XOR it in.<p>While <eq><math><mo lspace=0em rspace=0em>+</mo></math></eq> and <eq><math><mo lspace=0em rspace=0em>⊕︎</mo></math></eq> (i.e. XOR) seem similar, they actually differ in several characteristics:<ul><li>Space utilization (better for <eq><math><mo lspace=0em rspace=0em>⊕︎</mo></math></eq>)<li>Build success probability (better for <eq><math><mo lspace=0em rspace=0em>+</mo></math></eq> for small load factors or <eq><math><mo lspace=0em rspace=0em>⊕︎</mo></math></eq> for large load factors)<li>Build time (better for <eq><math><mo lspace=0em rspace=0em>+</mo></math></eq>)</ul><p>For approximate hash <eq><math><mi>h</mi></math></eq> and displacement <eq><math><mi>d</mi></math></eq>, we can either have <eq><math><mrow><mi>h</mi><mo>⊕︎</mo></mrow><mrow><mi>d</mi></mrow></math></eq> or <eq><math><mrow><mi>h</mi><mo>+</mo></mrow><mrow><mi>d</mi></mrow></math></eq> as the final hash, and the former is clearly less in the general case. For large <eq><math><mi>h</mi></math></eq> and small <eq><math><mi>d</mi></math></eq>, this is not a big problem, but for smaller hash tables, using <eq><math><mo lspace=0em rspace=0em>⊕︎</mo></math></eq> reduces the hash table size.<p>The question of success rate is tangentially related to collision rate in open addressing vs closed addressing in hash tables. With <eq><math><mo lspace=0em rspace=0em>+</mo></math></eq>, buckets effectively partially overlap, just like in open addressing, while with <eq><math><mo lspace=0em rspace=0em>⊕︎</mo></math></eq>, they either match completely or don’t intersect at all, just like in closed addressing. In typical hash tables, we’re only interested in the <em>expected</em> collisions, while in PHFs, any collisions that can’t be resolved by displacements are fatal. It’s a well-known fact (I hope so, anyway; I don’t want to burden you with a proof here) that open addressing is more lax in this regard.<p>As for the build time, we’ll discover why the mix function matters later.<p class=next-group><span aria-level=3 class=side-header role=heading><span>Displacements</span></span>How many different displacements do we need to try, i.e. what is the largest <eq><math><mi>d</mi></math></eq> we can expect, and what datatype should we use? There’s quite a bit of math here; feel free to skip it if that’s not your kind of thing.<p>For bucket of size <eq><math><mi>b</mi></math></eq> and current load factor is <eq><math><mi>α</mi></math></eq>, we can expect a success rate of <eq><math><mrow><mo form=prefix stretchy=false>(</mo><mn>1</mn><mo>−</mo><mi>α</mi><msup><mo form=postfix stretchy=false>)</mo><mi>b</mi></msup></mrow></math></eq> per displacement. Bucket sizes are distributed according to the Poisson distribution, so <eq><math><mrow><mi>α</mi><mo>≈</mo></mrow><mrow><mn>1.01</mn><mo>−</mo></mrow><mrow><mi>Q</mi><mo form=prefix stretchy=false>(</mo><mi>b</mi><mo separator=true>,</mo><mn>5</mn><mo form=postfix stretchy=false>)</mo></mrow></math></eq>, thus the success rate is <eq><math><mrow><mo form=prefix stretchy=false>(</mo><mi>Q</mi><mo form=prefix stretchy=false>(</mo><mi>b</mi><mo separator=true>,</mo><mn>5</mn><mo form=postfix stretchy=false>)</mo><mo>+</mo><mn>0.01</mn><msup><mo form=postfix stretchy=false>)</mo><mi>b</mi></msup></mrow></math></eq>. This peaks at around <eq><math><mrow><mn>1</mn><mi>/</mi><mn>400</mn></mrow></math></eq>, indicating an expected number of <eq><math><mn>400</mn></math></eq> displacements until success. This is the result for <em>one</em> bucket; the probability for <em>all</em> bucket displacements to be small is lower. In practice, I have found that using <eq><math><mn>16</mn></math></eq>-bit displacements works for sizes up to several million with high probability, which suffices for my usecase.<h2>Implementation</h2><p class=next-group><span aria-level=3 class=side-header role=heading><span>Hash functions</span></span>Now we need to design <eq><math><mrow><mi>A</mi><mi>p</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>x</mi></mrow></math></eq> and <eq><math><mrow><mi>B</mi><mi>u</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>t</mi></mrow></math></eq>, the functions for mapping keys to approximate hashes and for mapping keys to buckets.<p>Assume that we already have a fast <eq><math><mn>64</mn></math></eq>-bit hash function <eq><math><mrow><mi>U</mi><mi>n</mi><mi>i</mi><mi>f</mi><mi>o</mi><mi>r</mi><mi>m</mi></mrow></math></eq> with much entropy in the top bits. This is the only place that needs to be done separately for different kinds of data. I’ll omit this section, as it’s irrelevant to the PHF itself.<p>Now here’s a problem. Say we’ve got a “uniform” <eq><math><mn>64</mn></math></eq>-bit number, but <eq><math><mrow><mi>A</mi><mi>p</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>x</mi></mrow></math></eq> needs to output a number between <eq><math><mn>0</mn></math></eq> and <eq><math><mrow><mi>M</mi><mo>=</mo></mrow><mrow><mn>1.01</mn><mi>N</mi></mrow></math></eq>, which isn’t necessarily a power of two, so we’ll need to perform another calculation to scale the uniform hash. Scale, you say? That’s just fixed-point multiplication: <eq><math><mrow><mo form=prefix stretchy=false>(</mo><mi>h</mi><mo>×</mo><mi>M</mi><mo form=postfix stretchy=false>)</mo><mo rspace=0em>></mo></mrow><mrow><mo lspace=0em>></mo></mrow><mrow><mn>64</mn></mrow></math></eq> maps <eq><math><mrow><mi>h</mi><mo>∈</mo></mrow><mrow><mo form=prefix stretchy=false>[</mo><mn>0</mn><mo separator=true>;</mo><msup><mn>2</mn><mn>64</mn></msup><mo form=postfix stretchy=false>)</mo></mrow></math></eq> to <eq><math><mrow><mo form=prefix stretchy=false>[</mo><mn>0</mn><mo separator=true>;</mo><mi>M</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq>, which is precisely what we need.<p>What about <eq><math><mrow><mi>B</mi><mi>u</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>t</mi></mrow></math></eq>? I’d rather avoid yet another multiplication, so we’ll have to bite the bullet and round the bucket count to a power of two (buckets take little space per key, so that’s okay). We can then use the <em>lower</em> half of the <eq><math><mrow><mn>64</mn><mo>×</mo></mrow><mrow><mn>64</mn></mrow></math></eq> multiplication, shifted to the right, as a bucket index.<p>On x86-64, multiplication takes 3 ticks to produce the low half, and 4 ticks to produce the high half. In parallel, a 1-tick shift can be performed to get the bucket index. So that’s, uh, a good hash with a 4 tick latency:<pre><code class=language-rust><span class=hljs-keyword>struct</span> <span class="hljs-title class_">Precomputed</span> {
    hash_space: <span class=hljs-type>u64</span>,
    bucket_shift: <span class=hljs-type>u64</span>,
}

<span class=hljs-keyword>struct</span> <span class="hljs-title class_">Hash</span> {
    approx: <span class=hljs-type>u64</span>,
    bucket: <span class=hljs-type>u64</span>,
}

<span class=hljs-keyword>fn</span> <span class="hljs-title function_">hash</span>(h: <span class=hljs-type>u64</span>, precomputed: Precomputed) <span class=hljs-punctuation>-></span> Hash {
    <span class=hljs-keyword>let</span> <span class=hljs-variable>product</span> = h <span class=hljs-keyword>as</span> <span class=hljs-type>u128</span> * precomputed.hash_space <span class=hljs-keyword>as</span> <span class=hljs-type>u128</span>; <span class=hljs-comment>// 3 ticks</span>
    Hash {
        approx: (product >> <span class=hljs-number>64</span>) <span class=hljs-keyword>as</span> <span class=hljs-type>u64</span>, <span class=hljs-comment>// 1 tick</span>
        bucket: (product <span class=hljs-keyword>as</span> <span class=hljs-type>u64</span>) >> precomputed.bucket_shift, <span class=hljs-comment>// 1 tick (computed concurrently)</span>
    }
}
</code></pre><p>Nevermind the <code>mov</code>s; these will go away after inlining:<pre><code class=language-x86asm><span class=hljs-symbol>hash:</span>
    <span class=hljs-keyword>mov</span>     <span class=hljs-built_in>rcx</span>, <span class=hljs-built_in>rdx</span>
    <span class=hljs-keyword>mov</span>     <span class=hljs-built_in>rax</span>, <span class=hljs-built_in>rsi</span>
    <span class=hljs-keyword>mul</span>     <span class=hljs-built_in>rdi</span>
    <span class=hljs-keyword>mov</span>     <span class=hljs-built_in>rsi</span>, <span class=hljs-built_in>rax</span>
    <span class=hljs-keyword>shr</span>     <span class=hljs-built_in>rsi</span>, <span class=hljs-built_in>cl</span>
    <span class=hljs-keyword>mov</span>     <span class=hljs-built_in>rax</span>, <span class=hljs-built_in>rdx</span>
    <span class=hljs-keyword>mov</span>     <span class=hljs-built_in>rdx</span>, <span class=hljs-built_in>rsi</span>
    <span class=hljs-keyword>ret</span>
</code></pre><p>Now all we have to do is compute the final hash with <eq><math><mrow><mrow><mtext></mtext><mi>mix</mi></mrow><mo form=prefix stretchy=false>(</mo><mrow><mi>A</mi><mi>p</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>x</mi></mrow><mo separator=true>,</mo><mrow><mi>D</mi><mi>i</mi><mi>s</mi><mi>p</mi></mrow><mo form=prefix stretchy=false>[</mo><mrow><mi>B</mi><mi>u</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>t</mi></mrow><mo form=postfix stretchy=false>]</mo><mo form=postfix stretchy=false>)</mo></mrow></math></eq>.<h2>Generation</h2><p class=next-group><span aria-level=3 class=side-header role=heading><span>The what?</span></span>Okay, now how do we <em>generate</em> the table in the first place? We need to decide on:<ul><li><code>hash_space</code><li><code>bucket_shift</code><li>The displacement LUT</ul><p>None of these are as simple as they look like.<p class=next-group><span aria-level=3 class=side-header role=heading><span>Hash space</span></span>This looks trivial: just round <eq><math><mrow><mn>1.01</mn><mi>n</mi></mrow></math></eq> up. But there’s three pitfalls here.<p>The easier one is that multiplying by an even number shifts entropy to the left, so there might not be enough entropy left for <eq><math><mrow><mi>B</mi><mi>u</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>t</mi></mrow></math></eq>. Thus <code>hash_space</code> needs to be odd.<p>The medium one is that due to a limited displacement range, <eq><math><mrow><mn>1.01</mn><mi>n</mi></mrow></math></eq> might not be enough. This effect is exacerbated by large table sizes. Therefore, we try different <code>hash_space</code> values out: <eq><math><mrow><mn>1.01</mn><mi>n</mi><mo separator=true>,</mo></mrow><mrow><mn>1.02</mn><mi>n</mi><mo separator=true>,</mo></mrow><mrow><mn>1.03</mn><mi>n</mi><mo separator=true>,</mo></mrow><mrow><mo>…</mo></mrow></math></eq>, and increase the starting value based on the the number of elements. If we reach a power-of-two <code>hash_space</code> value, we’re in luck: although we’re now wasting memory, multiplication by <code>hash_space</code> has just become a shift, reducing latency by 2 ticks; this in turn allows us to try better <eq><math><mrow><mi>U</mi><mi>n</mi><mi>i</mi><mi>f</mi><mi>o</mi><mi>r</mi><mi>m</mi></mrow></math></eq> functions.<p>The harder one is that while <eq><math><mrow><mi>A</mi><mi>p</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>x</mi></mrow></math></eq> can be in-bounds, <eq><math><mrow><mrow><mtext></mtext><mi>mix</mi></mrow><mo form=prefix stretchy=false>(</mo><mrow><mi>A</mi><mi>p</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>x</mi></mrow><mo separator=true>,</mo><mrow><mi>D</mi><mi>i</mi><mi>s</mi><mi>p</mi></mrow><mo form=prefix stretchy=false>[</mo><mrow><mi>B</mi><mi>u</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>t</mi></mrow><mo form=postfix stretchy=false>]</mo><mo form=postfix stretchy=false>)</mo></mrow></math></eq> can be out-of-bounds. For example, for hash table size <eq><math><mn>5</mn></math></eq>, a key with approximate hash <eq><math><mn>4</mn></math></eq> and displacement <eq><math><mn>2</mn></math></eq> has final index <eq><math><mn>6</mn></math></eq> (for both <eq><math><mo lspace=0em rspace=0em>+</mo></math></eq> and <eq><math><mo lspace=0em rspace=0em>⊕︎</mo></math></eq> mixing functions). Handling this case as wrap-around is a performance hazard, and forbidding such out-of-bounds accesses decreases the probability of a successful build. The solution is to keep the output space of <eq><math><mrow><mi>A</mi><mi>p</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>x</mi></mrow></math></eq> (i.e. <code>hash_space</code>) limited to <eq><math><mrow><mn>1.01</mn><mi>n</mi></mrow></math></eq> (or another multiple of <eq><math><mi>n</mi></math></eq>), but pad the resulting hash table to the right such that all possible accesses are in-bounds.<p>There’s a conundrum here. Do we make <em>accesses to existing elements</em> in-bounds, or do we legalize <em>all accesses</em>? If accessed keys are guaranteed to be present in the hashmap, the former suffices; if we need to add an existence check (like in the first example in this post), we need to do the latter. My case calls for access verification, so we’ll need to make all accesses sound, increasing the hash table size to <em>[Insert incomprehensible math warning]</em> <eq><math><mrow><mn>1</mn><mo>+</mo></mrow><mrow><munderover><mi>max</mi><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>B</mi><mo>−</mo><mn>1</mn></mrow></munderover><mo>⁡</mo><mspace width=0.1667em></mspace></mrow><mrow><munderover><mi>max</mi><mrow><mi>x</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>M</mi><mo>−</mo><mn>1</mn></mrow></munderover><mo>⁡</mo><mspace width=0.1667em></mspace></mrow><mrow><mrow><mtext></mtext><mi>mix</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>x</mi><mo separator=true>,</mo><msub><mrow><mi>D</mi><mi>i</mi><mi>s</mi><mi>p</mi></mrow><mi>i</mi></msub><mo form=postfix stretchy=false>)</mo></mrow></math></eq>.<p>For the <eq><math><mo lspace=0em rspace=0em>+</mo></math></eq> mixing function, this is just <eq><math><mrow><mi>M</mi><mo>+</mo></mrow><mrow><munderover><mi>max</mi><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>B</mi><mo>−</mo><mn>1</mn></mrow></munderover><mo>⁡</mo><mspace width=0.1667em></mspace></mrow><mrow><msub><mrow><mi>D</mi><mi>i</mi><mi>s</mi><mi>p</mi></mrow><mi>i</mi></msub></mrow></math></eq>. For <eq><math><mo lspace=0em rspace=0em>⊕︎</mo></math></eq>, a tighter boundary is possible; I’m a nerd, so we’re going to solve this Leetcode problem now. Skip to the next section if you despise that sort of thing.<p>We’re looking for a way to calculate <eq><math><mrow><munderover><mi>max</mi><mrow><mi>x</mi><mo>=</mo><mn>0</mn></mrow><mi>X</mi></munderover><mo>⁡</mo><mspace width=0.1667em></mspace></mrow><mrow><mi>x</mi><mo>⊕︎</mo></mrow><mrow><mi>Y</mi></mrow></math></eq> in <eq><math><mrow><mi class=mathcal>𝒪</mi><mo form=prefix stretchy=false>(</mo><mn>1</mn><mo form=postfix stretchy=false>)</mo></mrow></math></eq> for different <eq><math><mi>Y</mi></math></eq> values. I won’t bore you with details, but it works like this:<pre><code class=language-rust><span class=hljs-keyword>fn</span> <span class="hljs-title function_">max_xor</span>(x: <span class=hljs-type>usize</span>, y: <span class=hljs-type>usize</span>) <span class=hljs-punctuation>-></span> <span class=hljs-type>usize</span> {
    <span class=hljs-keyword>let</span> <span class=hljs-variable>bound</span> = (x & y).<span class="hljs-title function_ invoke__">checked_ilog2</span>().<span class="hljs-title function_ invoke__">unwrap_or</span>(<span class=hljs-number>0</span>);
    x | y | ((<span class=hljs-number>1</span> << bound) - <span class=hljs-number>1</span>)
}
</code></pre><div class=aside-group><aside><p>Hint: try to compute the largest <eq><math><mrow><mi>x</mi><mo>⊕︎</mo></mrow><mrow><mi>Y</mi></mrow></math></eq> bit by bit, from high to low. If <eq><math><mi>X</mi></math></eq> and <eq><math><mi>Y</mi></math></eq> have different bits at some position, the resulting bit can easily be <eq><math><mn>1</mn></math></eq>, which is the largest possible value. However, when both <eq><math><mi>X</mi></math></eq> and <eq><math><mi>Y</mi></math></eq> have a <eq><math><mn>1</mn></math></eq> bit, we can decrease <eq><math><mi>X</mi></math></eq> so that this bit is <eq><math><mn>0</mn></math></eq> and all the following bits are inverses of <eq><math><mi>Y</mi></math></eq>.</aside><p>Proving this is left as an exercise to the reader. I have no intuition for why this function is symmetric; if you figure it out, please let me know. Anyway; this function is monotonous in <eq><math><mi>X</mi></math></eq> (by definition) and symmetric (by implementation), so it’s monotonous in <eq><math><mi>Y</mi></math></eq>, so instead of substituting several displacements, we can just substitute the largest one, i.e. the hash table size is <eq><math><mrow><mn>1</mn><mo>+</mo></mrow><mrow><mrow><mrow><mi mathvariant=normal>m</mi></mrow><mrow><mi mathvariant=normal>a</mi></mrow><mrow><mi mathvariant=normal>x</mi></mrow><mi>_</mi><mrow><mi mathvariant=normal>x</mi></mrow><mrow><mi mathvariant=normal>o</mi></mrow><mrow><mi mathvariant=normal>r</mi></mrow></mrow><mrow><mo fence=true form=prefix>(</mo><mi>M</mi><mo>−</mo><mn>1</mn><mo separator=true>,</mo><munderover><mi>max</mi><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>B</mi><mo>−</mo><mn>1</mn></mrow></munderover><mo>⁡</mo><mspace width=0.1667em></mspace><msub><mrow><mi>D</mi><mi>i</mi><mi>s</mi><mi>p</mi></mrow><mi>i</mi></msub><mo fence=true form=postfix>)</mo></mrow></mrow></math></eq>.</div><p class=next-group><span aria-level=3 class=side-header role=heading><span>Bucket shift</span></span>I lied, this one’s actually simple. A good change of pace. Do you feel relieved? Please feel relieved.<p>If you still remember, we compute <eq><math><mrow><mi>B</mi><mi>u</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>t</mi></mrow></math></eq> of a key as <code>(product as u64) >> bucket_shift</code>, so <code>bucket_shift</code> is just <eq><math><mrow><mn>64</mn><mo>−</mo></mrow><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mspace width=0.1667em></mspace></mrow><mrow><mi>B</mi></mrow></math></eq>, and the bucket count is <eq><math><mrow><mfrac><mn>1</mn><mn>5</mn></mfrac><mi>N</mi></mrow></math></eq> (shamelessly stolen from CHD), rounded up to a power of two.<p class=next-group><span aria-level=3 class=side-header role=heading><span>Displacements</span></span>Displacements are a core part of PHFs, so this part’s more typical. We split keys into buckets according to <eq><math><mrow><mi>B</mi><mi>u</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>t</mi></mrow></math></eq>, sort the buckets in order of decreasing size, and assign displacements to buckets in order. We try displacements <eq><math><mrow><mn>0</mn><mo separator=true>,</mo></mrow><mrow><mn>1</mn><mo separator=true>,</mo></mrow><mrow><mn>2</mn><mo separator=true>,</mo></mrow><mrow><mo>…</mo></mrow><mrow><mo separator=true>,</mo></mrow><mrow><msup><mn>2</mn><mn>16</mn></msup><mo>−</mo></mrow><mrow><mn>1</mn></mrow></math></eq>; the first applicable displacement (s.t. the elements don’t collide with already assigned ones) is used. If no displacement works, we restart the algorithm with different hash functions.<p>The basic idea of what we’re trying to do is this:<pre><code class=language-rust><div class=expansible-code><input id=expansible1 type=checkbox><div class=highlighted><span class=hljs-keyword>struct</span> <span class="hljs-title class_">Phf</span> {
    hash_space: <span class=hljs-type>u64</span>,
    bucket_shift: <span class=hljs-type>u64</span>,
    displacements: <span class=hljs-type>Vec</span><<span class=hljs-type>u16</span>>,
}

<span class=hljs-keyword>fn</span> <span class="hljs-title function_">try_generate_phf</span>(keys: &[<span class=hljs-type>u64</span>]) <span class=hljs-punctuation>-></span> <span class=hljs-type>Option</span>&LTPhf> {
    <span class=hljs-comment>// Hash space. <span class=hljs-doctag>TODO:</span> Increase on failure.</span>
    <span class=hljs-keyword>let</span> <span class=hljs-variable>hash_space</span> = (keys.<span class="hljs-title function_ invoke__">len</span>() + keys.<span class="hljs-title function_ invoke__">len</span>().<span class="hljs-title function_ invoke__">div_ceil</span>(<span class=hljs-number>100</span>)) | <span class=hljs-number>1</span>;

    <span class=hljs-comment>// Number of buckets</span>
    <span class=hljs-keyword>let</span> <span class=hljs-variable>b</span> = (keys.<span class="hljs-title function_ invoke__">len</span>().<span class="hljs-title function_ invoke__">div_ceil</span>(<span class=hljs-number>5</span>) + <span class=hljs-number>1</span>).<span class="hljs-title function_ invoke__">next_power_of_two</span>();

    <span class=hljs-comment>// Split keys into buckets</span>
    <span class=hljs-keyword>let</span> <span class=hljs-variable>bucket_shift</span> = <span class=hljs-number>64</span> - b.<span class="hljs-title function_ invoke__">ilog2</span>();
    <span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>keys_per_bucket</span> = <span class=hljs-built_in>vec!</span>[<span class=hljs-type>Vec</span>::<span class="hljs-title function_ invoke__">new</span>(); b];
    <span class=hljs-keyword>for</span> <span class=hljs-variable>key</span> <span class=hljs-keyword>in</span> keys {
        <span class=hljs-comment>// <span class=hljs-doctag>TODO:</span> Apply Uniform to key.</span>
        <span class=hljs-keyword>let</span> <span class=hljs-variable>bucket</span> = key.<span class="hljs-title function_ invoke__">wrapping_mul</span>(hash_space <span class=hljs-keyword>as</span> <span class=hljs-type>u64</span>) >> bucket_shift;
        keys_per_bucket[bucket <span class=hljs-keyword>as</span> <span class=hljs-type>usize</span>].<span class="hljs-title function_ invoke__">push</span>(*key);
    }

    <span class=hljs-comment>// Reserve space for elements, plus 2^16 - 1 for out-of-bounds displacements</span>
    <span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>free</span> = <span class=hljs-built_in>vec!</span>[<span class=hljs-literal>true</span>; hash_space + <span class=hljs-type>u16</span>::MAX <span class=hljs-keyword>as</span> <span class=hljs-type>usize</span>];

    <span class=hljs-comment>// We'll fill this per-bucket array during the course of the algorithm</span>
    <span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>displacements</span> = <span class=hljs-built_in>vec!</span>[<span class=hljs-number>0</span>; b];

    <span class=hljs-comment>// Handle buckets in order of decreasing size</span>
    <span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>bucket_order</span>: <span class=hljs-type>Vec</span><<span class=hljs-type>usize</span>> = (<span class=hljs-number>0</span>..b).<span class="hljs-title function_ invoke__">collect</span>();
    bucket_order.<span class="hljs-title function_ invoke__">sort_unstable_by_key</span>(|bucket| core::cmp::<span class="hljs-title function_ invoke__">Reverse</span>(keys_per_bucket[*bucket].<span class="hljs-title function_ invoke__">len</span>()));
    <span class=hljs-keyword>for</span> <span class=hljs-variable>bucket</span> <span class=hljs-keyword>in</span> bucket_order {
        <span class=hljs-comment>// Compute all Approx values preemptively</span>
        <span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>approx_for_bucket</span>: <span class=hljs-type>Vec</span><<span class=hljs-type>u64</span>> = keys_per_bucket[bucket]
            .<span class="hljs-title function_ invoke__">drain</span>(..)
            .<span class="hljs-title function_ invoke__">map</span>(|key| ((key <span class=hljs-keyword>as</span> <span class=hljs-type>u128</span> * hash_space <span class=hljs-keyword>as</span> <span class=hljs-type>u128</span>) >> <span class=hljs-number>64</span>) <span class=hljs-keyword>as</span> <span class=hljs-type>u64</span>)
            .<span class="hljs-title function_ invoke__">collect</span>();

        <span class=hljs-comment>// Ensure that Approx values don't collide inside the bucket</span>
        approx_for_bucket.<span class="hljs-title function_ invoke__">sort_unstable</span>();
        <span class=hljs-keyword>if</span> approx_for_bucket
            .<span class="hljs-title function_ invoke__">windows</span>(<span class=hljs-number>2</span>)
            .<span class="hljs-title function_ invoke__">any</span>(|window| window[<span class=hljs-number>0</span>] == window[<span class=hljs-number>1</span>])
        {
            <span class=hljs-keyword>return</span> <span class=hljs-literal>None</span>;
        }

        <span class=hljs-comment>// Find non-colliding displacement. On failure, return None.</span>
        <span class=hljs-keyword>let</span> <span class=hljs-variable>displacement</span> = (<span class=hljs-number>0</span>..=<span class=hljs-type>u16</span>::MAX).<span class="hljs-title function_ invoke__">find</span>(|displacement| {
            approx_for_bucket.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">all</span>(|approx| *<span class=hljs-keyword>unsafe</span> {
                free.<span class="hljs-title function_ invoke__">get_unchecked</span>(<span class="hljs-title function_ invoke__">mix</span>(*approx, *displacement) <span class=hljs-keyword>as</span> <span class=hljs-type>usize</span>)
            })
        })?;

        <span class=hljs-comment>// Place the bucket</span>
        displacements[bucket] = displacement;
        <span class=hljs-keyword>for</span> <span class=hljs-variable>approx</span> <span class=hljs-keyword>in</span> approx_for_bucket {
            *<span class=hljs-keyword>unsafe</span> { free.<span class="hljs-title function_ invoke__">get_unchecked_mut</span>(<span class="hljs-title function_ invoke__">mix</span>(approx, displacement) <span class=hljs-keyword>as</span> <span class=hljs-type>usize</span>) } = <span class=hljs-literal>false</span>;
        }
    }

    <span class="hljs-title function_ invoke__">Some</span>(Phf {
        hash_space: hash_space <span class=hljs-keyword>as</span> <span class=hljs-type>u64</span>,
        bucket_shift,
        displacements,
    })
}
</div><label for=expansible1>Expand</label></div></code></pre><div class=aside-group><aside><p>The reason I’m not saying any specific numbers is that the per-key performance depends on how well the data fits in cache. Different sizes lead to different performance characteristics; make sure to benchmark your usecases. During this optimization stage, all I can provide without lying is approximate relative numbers.</aside><p>This code works, but quite slow. Luckily, there’s opportunities for optimization.</div><h2>Faster bucket logic</h2><p class=next-group><span aria-level=3 class=side-header role=heading><span>Allocations & cache</span></span>There’s two obvious problems with this code.<p>One problem is that <code>keys_per_bucket</code> is a two-dimensional array containing <eq><math><mi>B</mi></math></eq> vectors. Most of these vectors are non-empty, and calling <code>malloc</code> approximately <eq><math><mi>B</mi></math></eq> times is really slow. Even if we reduce this to one allocation, we’re still going to jump all over the memory, polluting the cache.<p>To fix both of these, we need to find another approach. Most cache-oblivious algorithms use the same old trick: sorting data with a cache-friendly algorithm and reading it in order is faster than reading it out of order. So we’re going to sort the keys by bucket, <code>group_by</code> the result into buckets, and then split this sequence into per-size bucket lists.<pre><code class=language-rust><div class=expansible-code><input id=expansible2 type=checkbox><div class=highlighted><span class=hljs-comment>// Sort keys by bucket using a cache-friendly algorithm</span>
<span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>sorted_by_bucket</span> = keys.<span class="hljs-title function_ invoke__">to_vec</span>();
radsort::<span class="hljs-title function_ invoke__">sort_by_key</span>(&<span class=hljs-keyword>mut</span> sorted_by_bucket, |key| <span class="hljs-title function_ invoke__">key_to_bucket</span>(*key));

<span class=hljs-comment>// We'll store per-size bucket lists here</span>
<span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>buckets_by_size</span>: <span class=hljs-type>Vec</span><<span class=hljs-type>Vec</span><(<span class=hljs-type>u64</span>, <span class=hljs-type>usize</span>)>> = <span class=hljs-type>Vec</span>::<span class="hljs-title function_ invoke__">new</span>();

<span class=hljs-comment>// A manual group_by implementation</span>
<span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>left</span> = <span class=hljs-number>0</span>;
<span class=hljs-keyword>while</span> left < keys.<span class="hljs-title function_ invoke__">len</span>() {
    <span class=hljs-keyword>let</span> <span class=hljs-variable>bucket</span> = <span class="hljs-title function_ invoke__">key_to_bucket</span>(sorted_by_bucket[left]);

    <span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>right</span> = left;
    <span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>product</span>;
    <span class=hljs-keyword>while</span> right < keys.<span class="hljs-title function_ invoke__">len</span>() && {
        <span class=hljs-comment>// Keep going while the key has the same bucket as the previous one</span>
        product = sorted_by_bucket[right] <span class=hljs-keyword>as</span> <span class=hljs-type>u128</span> * hash_space <span class=hljs-keyword>as</span> <span class=hljs-type>u128</span>;
        bucket == product <span class=hljs-keyword>as</span> <span class=hljs-type>u64</span> >> bucket_shift
    } {
        <span class=hljs-comment>// Replace the key with its Approx value in-place for future use. We have already computed</span>
        <span class=hljs-comment>// the product, so this is cheap.</span>
        sorted_by_bucket[right] = (product >> <span class=hljs-number>64</span>) <span class=hljs-keyword>as</span> <span class=hljs-type>u64</span>;
        right += <span class=hljs-number>1</span>;
    }
    left = right;

    <span class=hljs-comment>// Add bucket to its per-size list</span>
    <span class=hljs-keyword>let</span> <span class=hljs-variable>size</span> = right - left;
    <span class=hljs-keyword>if</span> buckets_by_size.<span class="hljs-title function_ invoke__">len</span>() <= size {
        buckets_by_size.<span class="hljs-title function_ invoke__">resize</span>(size + <span class=hljs-number>1</span>, <span class=hljs-type>Vec</span>::<span class="hljs-title function_ invoke__">new</span>());
    }
    buckets_by_size[size].<span class="hljs-title function_ invoke__">push</span>((bucket, left));
}
</div><label for=expansible2>Expand</label></div></code></pre><p>Iterating over the buckets is then as simple as:<pre><code class=language-rust><span class=hljs-keyword>for</span> (size, buckets) <span class=hljs-keyword>in</span> buckets_by_size.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>().<span class="hljs-title function_ invoke__">rev</span>() {
    <span class=hljs-keyword>for</span> &(bucket, start) <span class=hljs-keyword>in</span> buckets {
        <span class=hljs-keyword>let</span> <span class=hljs-variable>approx_for_bucket</span> = &<span class=hljs-keyword>mut</span> sorted_by_bucket[start..start + size];
        ...
    }
}
</code></pre><p>This alone increases performance almost twofold. <code>radsort</code> might not be the best radix sort implementation, but it’s the only one I found that supports stateful <code>sort_by_key</code>, so we’ll have to live with it.<p class=next-group><span aria-level=3 class=side-header role=heading><span>Displacements (XOR)</span></span>The second problem is this quadratic loop:<pre><code class=language-rust><span class=hljs-comment>// Find non-colliding displacement. On failure, return None.</span>
<span class=hljs-keyword>let</span> <span class=hljs-variable>displacement</span> = (<span class=hljs-number>0</span>..=<span class=hljs-type>u16</span>::MAX).<span class="hljs-title function_ invoke__">find</span>(|displacement| {
    approx_for_bucket.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">all</span>(|approx| *<span class=hljs-keyword>unsafe</span> {
        free.<span class="hljs-title function_ invoke__">get_unchecked</span>(<span class="hljs-title function_ invoke__">mix</span>(*approx, *displacement) <span class=hljs-keyword>as</span> <span class=hljs-type>usize</span>)
    })
})?;
</code></pre><p>The average displacement is quite large, so the outer loop can perform quite a few iterations. Meanwhile, the inner loop iterates through a small subset of indices all across the memory, which doesn’t even always fit in L2.<p>Luckily, this is easy to fix by simultaneously computing the predicate for <em>multiple</em> values of <code>displacement</code>, as if by unrolling the loop. But hey, <eq><math><mrow><mrow><mi>A</mi><mi>p</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>x</mi></mrow><mo>⊕︎</mo></mrow><mrow><mn>0</mn><mo separator=true>,</mo></mrow><mrow><mo>…</mo></mrow><mrow><mo separator=true>,</mo></mrow><mrow><mrow><mi>A</mi><mi>p</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>x</mi></mrow><mo>⊕︎</mo></mrow><mrow><mn>7</mn></mrow></math></eq> exactly covers an 8-aligned slice of <code>free</code>, which means <code>free</code> can cheaply be turned into a bitset!<p>Well… sort of. It <em>looks</em> like it should be as simple as<pre><code class=language-rust><div class=expansible-code><input id=expansible3 type=checkbox><div class=highlighted><span class=hljs-comment>// SAFETY: `free` must be a bitset large enough to fit `approx ^ displacement`.</span>
<span class=hljs-keyword>unsafe</span> <span class=hljs-keyword>fn</span> <span class="hljs-title function_">find_valid_displacement</span>(approx_for_bucket: &[<span class=hljs-type>u64</span>], free: &[<span class=hljs-type>u8</span>]) <span class=hljs-punctuation>-></span> <span class=hljs-type>Option</span><<span class=hljs-type>u16</span>> {
    <span class=hljs-comment>// Outer unrolled loop</span>
    <span class=hljs-keyword>for</span> <span class=hljs-variable>displacement_base</span> <span class=hljs-keyword>in</span> (<span class=hljs-number>0</span>..=<span class=hljs-type>u16</span>::MAX).<span class="hljs-title function_ invoke__">step_by</span>(<span class=hljs-number>8</span>) {
        <span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>global_bit_mask</span> = <span class=hljs-type>u8</span>::MAX;

        <span class=hljs-comment>// Iterate over keys</span>
        <span class=hljs-keyword>for</span> <span class=hljs-variable>approx</span> <span class=hljs-keyword>in</span> approx_for_bucket {
            <span class=hljs-keyword>let</span> <span class=hljs-variable>approx</span> = *approx <span class=hljs-keyword>as</span> <span class=hljs-type>usize</span>;
            <span class=hljs-comment>// Inner unrolled loop, aka bitmask logic</span>
            <span class=hljs-keyword>let</span> <span class=hljs-variable>bit_mask</span> =
                *<span class=hljs-keyword>unsafe</span> { free.<span class="hljs-title function_ invoke__">get_unchecked</span>((approx ^ displacement_base <span class=hljs-keyword>as</span> <span class=hljs-type>usize</span>) / <span class=hljs-number>8</span>) };
            global_bit_mask &= bit_mask;
        }

        <span class=hljs-comment>// Find the first applicable displacement (i.e. such that all `free` values are 1)</span>
        <span class=hljs-keyword>if</span> global_bit_mask != <span class=hljs-number>0</span> {
            <span class=hljs-keyword>let</span> <span class=hljs-variable>displacement_offset</span> = global_bit_mask.<span class="hljs-title function_ invoke__">trailing_zeros</span>() <span class=hljs-keyword>as</span> <span class=hljs-type>u16</span>;
            <span class=hljs-keyword>return</span> <span class="hljs-title function_ invoke__">Some</span>(displacement_base + displacement_offset);
        }
    }

    <span class=hljs-literal>None</span>
}
</div><label for=expansible3>Expand</label></div></code></pre><p>But that’s actually wrong. We <em>want</em> to SIMDify the computation of<ul><li><code>free[approx[0] ^ 0] && free[approx[1] ^ 0] && free[approx[2] ^ 0] && ...</code><li><code>free[approx[0] ^ 1] && free[approx[1] ^ 1] && free[approx[2] ^ 1] && ...</code><li>…<li><code>free[approx[0] ^ 7] && free[approx[1] ^ 7] && free[approx[2] ^ 7] && ...</code></ul><p>Which we rewrite as<ul><li><code>free[approx[0] / 8][(approx[0] & 7) ^ 0] && ...</code><li><code>free[approx[0] / 8][(approx[0] & 7) ^ 1] && ...</code><li>…<li><code>free[approx[0] / 8][(approx[0] & 7) ^ 7] && ...</code></ul><p>But note that the bit index <eq><math><mn>0</mn></math></eq> to <eq><math><mn>7</mn></math></eq> needs to be XORed with <code>approx</code>, while in our code, we just directly access bits <eq><math><mn>0</mn></math></eq> to <eq><math><mn>7</mn></math></eq> without consideration for the low three bits of <code>approx</code>. If we want this scheme to work, we need to <em>shuffle bits inside a byte</em> by XORing <em>the bit index</em> (rather than the bits themselves) with <code>approx & 7</code>:<ul><li>If <code>approx & 7 == 0</code>, the shuffle order is <eq><math><mrow><mn>01234567</mn><mo>→</mo></mrow><mrow><mn>01234567</mn></mrow></math></eq>.<li>If <code>approx & 7 == 1</code>, the shuffle order is <eq><math><mrow><mn>01234567</mn><mo>→</mo></mrow><mrow><mn>10325476</mn></mrow></math></eq>.<li>If <code>approx & 7 == 2</code>, the shuffle order is <eq><math><mrow><mn>01234567</mn><mo>→</mo></mrow><mrow><mn>23016745</mn></mrow></math></eq>.<li>If <code>approx & 7 == 3</code>, the shuffle order is <eq><math><mrow><mn>01234567</mn><mo>→</mo></mrow><mrow><mn>32107654</mn></mrow></math></eq>.<li>…<li>If <code>approx & 7 == 7</code>, the shuffle order is <eq><math><mrow><mn>01234567</mn><mo>→</mo></mrow><mrow><mn>76543210</mn></mrow></math></eq>.</ul><p>You get the idea. The most performant way to compute this is with a LUT:<pre><code class=language-rust><div class=expansible-code><input id=expansible4 type=checkbox><div class=highlighted><span class=hljs-keyword>const</span> BIT_INDEX_XOR_LUT: [[<span class=hljs-type>u8</span>; <span class=hljs-number>256</span>]; <span class=hljs-number>8</span>] = {
    <span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>lut</span> = [[<span class=hljs-number>0</span>; <span class=hljs-number>256</span>]; <span class=hljs-number>8</span>];
    <span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>xor</span> = <span class=hljs-number>0</span>;
    <span class=hljs-comment>// For loops are unsupported in const, smh my head</span>
    <span class=hljs-keyword>while</span> xor < <span class=hljs-number>8</span> {
        <span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>bit_mask</span> = <span class=hljs-number>0</span>;
        <span class=hljs-keyword>while</span> bit_mask < <span class=hljs-number>256</span> {
            <span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>bit_index</span> = <span class=hljs-number>0</span>;
            <span class=hljs-keyword>while</span> bit_index < <span class=hljs-number>8</span> {
                lut[xor][bit_mask] |= ((bit_mask <span class=hljs-keyword>as</span> <span class=hljs-type>u8</span> >> bit_index) & <span class=hljs-number>1</span>) << (bit_index ^ xor);
                bit_index += <span class=hljs-number>1</span>;
            }
            bit_mask += <span class=hljs-number>1</span>;
        }
        xor += <span class=hljs-number>1</span>;
    }
    lut
};

global_bit_mask &= BIT_INDEX_XOR_LUT[approx % <span class=hljs-number>8</span>][bit_mask <span class=hljs-keyword>as</span> <span class=hljs-type>usize</span>];
</div><label for=expansible4>Expand</label></div></code></pre><p>This again brings build time down twofold. Unfortunately, increasing the performance further is a lot harder. Increasing the step to 16 bits would either require a 2 MiB LUT, which is not really a good idea for many reasons, or introduce conditionals into the <code>global_bit_mask &= ...</code> calculation – hardly a positive change.<p class=next-group><span aria-level=3 class=side-header role=heading><span>Displacements (+)</span></span>So that’s it for <eq><math><mo lspace=0em rspace=0em>⊕︎</mo></math></eq>. What about <eq><math><mo lspace=0em rspace=0em>+</mo></math></eq>?<p>We’re in luck: bits <eq><math><mrow><mrow><mi>A</mi><mi>p</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>x</mi></mrow><mo>+</mo></mrow><mrow><mn>0</mn></mrow></math></eq> to <eq><math><mrow><mrow><mi>A</mi><mi>p</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>x</mi></mrow><mo>+</mo></mrow><mrow><mn>7</mn></mrow></math></eq> can be extracted simply by performing an unaligned 16-bit read, followed by a bit shift. But we don’t have to limit ourselves to validating <eq><math><mn>8</mn></math></eq> displacements at once: we can easily validate <eq><math><mn>57</mn></math></eq> displacements at once!<pre><code class=language-rust><div class=expansible-code><input id=expansible5 type=checkbox><div class=highlighted><span class=hljs-comment>// SAFETY: `free` must be large enough to fit `approx + displacement + 8`.</span>
<span class=hljs-keyword>unsafe</span> <span class=hljs-keyword>fn</span> <span class="hljs-title function_">find_valid_displacement</span>(approx_for_bucket: &[<span class=hljs-type>u64</span>], free: &[<span class=hljs-type>u8</span>]) <span class=hljs-punctuation>-></span> <span class=hljs-type>Option</span><<span class=hljs-type>u16</span>> {
    <span class=hljs-comment>// Outer unrolled loop</span>
    <span class=hljs-keyword>for</span> <span class=hljs-variable>displacement_base_index</span> <span class=hljs-keyword>in</span> <span class=hljs-number>0</span>..<span class=hljs-type>u16</span>::MAX / <span class=hljs-number>57</span> {
        <span class=hljs-comment>// We don't iterate through a few of the top 65536 displacements, but that's noise</span>
        <span class=hljs-keyword>let</span> <span class=hljs-variable>displacement_base</span> = displacement_base_index * <span class=hljs-number>57</span>;

        <span class=hljs-comment>// Can't trust bits farther than the first 57, because we shift out up to 7 bits, shifting</span>
        <span class=hljs-comment>// in meaningless zeros</span>
        <span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>global_bit_mask</span> = (<span class=hljs-number>1</span> << <span class=hljs-number>57</span>) - <span class=hljs-number>1</span>;

        <span class=hljs-comment>// Iterate over keys</span>
        <span class=hljs-keyword>for</span> <span class=hljs-variable>approx</span> <span class=hljs-keyword>in</span> approx_for_bucket {
            <span class=hljs-comment>// Inner unrolled loop, aka bitmask logic</span>
            <span class=hljs-keyword>let</span> <span class=hljs-variable>start</span> = *approx <span class=hljs-keyword>as</span> <span class=hljs-type>usize</span> + displacement_base <span class=hljs-keyword>as</span> <span class=hljs-type>usize</span>;
            <span class=hljs-keyword>let</span> <span class=hljs-variable>bit_mask</span> = <span class=hljs-keyword>unsafe</span> { free.<span class="hljs-title function_ invoke__">as_ptr</span>().<span class="hljs-title function_ invoke__">add</span>(start / <span class=hljs-number>8</span>).cast::<<span class=hljs-type>u64</span>>().<span class="hljs-title function_ invoke__">read_unaligned</span>() }
                >> (start % <span class=hljs-number>8</span>);
            global_bit_mask &= bit_mask;
        }

        <span class=hljs-keyword>if</span> global_bit_mask != <span class=hljs-number>0</span> {
            <span class=hljs-keyword>let</span> <span class=hljs-variable>displacement_offset</span> = global_bit_mask.<span class="hljs-title function_ invoke__">trailing_zeros</span>() <span class=hljs-keyword>as</span> <span class=hljs-type>u16</span>;
            <span class=hljs-keyword>return</span> <span class="hljs-title function_ invoke__">Some</span>(displacement_base + displacement_offset);
        }
    }

    <span class=hljs-literal>None</span>
}
</div><label for=expansible5>Expand</label></div></code></pre><p>This is approximately twice as fast as the XOR logic.</div></section><footer><div class=viewport-container><h2>Made with my own bare hands (why.)</h2></div></footer><script>window.addEventListener("keydown", e => {
				if (e.key === "Enter") {
					if (e.ctrlKey) {
						window.open("https://github.com/purplesyringa/site/edit/master/blog/designing-worlds-fastest-perfect-hash/index.md", "_blank");
					} else if (
						e.target.type === "checkbox"
						&& e.target.parentNode
						&& e.target.parentNode.className === "expansible-code"
					) {
						e.target.click();
					}
				}
			});</script>