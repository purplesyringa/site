<!doctypehtml><html prefix="og: http://ogp.me/ns#"lang=en_US><meta charset=utf-8><meta content=width=device-width,initial-scale=1 name=viewport><title>The road to world's fastest perfect hash | purplesyringa's blog</title><link href=../../favicon.ico?v=2 rel=icon><link href=../../all.css rel=stylesheet><link href=../../blog.css rel=stylesheet><link href=../../vendor/Temml-Local.css rel=stylesheet><link crossorigin href=https://fonts.googleapis.com/css2?family=Noto+Sans:ital,wght@0,100..900;1,100..900&family=Roboto+Mono:ital,wght@0,100..700;1,100..700&family=Roboto:ital,wght@0,400;0,700;1,400;1,700&family=Slabo+27px&display=swap rel=stylesheet><link href=../../fonts/webfont.css rel=stylesheet><link media="screen and (prefers-color-scheme: dark"href=../../vendor/atom-one-dark.min.css rel=stylesheet><link media="screen and (prefers-color-scheme: light"href=../../vendor/a11y-light.min.css rel=stylesheet><link title="Blog posts"href=../../blog/feed.rss rel=alternate type=application/rss+xml><meta content="The road to world's fastest perfect hash"property=og:title><meta content=article property=og:type><meta content=https://purplesyringa.moe/blog/designing-worlds-fastest-perfect-hash/og.png property=og:image><meta content=https://purplesyringa.moe/blog/designing-worlds-fastest-perfect-hash/ property=og:url><meta content="I need a hash-table with integer keys. HashMap , right? Wrong. For plot reasons, I need it to perform at ridiculous speeds. So that’s how the journey towards the fastest perfect hash function started."property=og:description><meta content=en_US property=og:locale><meta content="purplesyringa's blog"property=og:site_name><meta content=summary_large_image name=twitter:card><meta content=https://purplesyringa.moe/blog/designing-worlds-fastest-perfect-hash/og.png name=twitter:image><script data-website-id=0da1961d-43f2-45cc-a8e2-75679eefbb69 defer src=https://zond.tei.su/script.js></script><body><header><div class=viewport-container><div class=media><a href=https://github.com/purplesyringa><img alt=GitHub src=../../images/github-mark-white.svg></a></div><h1><a href=/>purplesyringa</a></h1><nav><a href=../..>about</a><a class=current href=../../blog/>blog</a><a href=../../sink/>kitchen sink</a></nav></div></header><section><div class=viewport-container><h2>The road to world's fastest perfect hash</h2><time>November 15, 2024</time><p>I need a hash-table with integer keys. <code>HashMap&LTu32, T></code>, right? Wrong. <em>For plot reasons</em>, I need it to perform at ridiculous speeds. So that’s how the journey towards the fastest perfect hash function started.<p class=next-group><span aria-level=3 class=side-header role=heading><span>Setting the stage</span></span>Okay, so a little bit of context is necessary.<p>I’m working with a file containing structured data, and I need to attach metadata to some of the entries. Entries don’t have any natural keys, so I have to use the file offset as the key. I’m allowed to spend a long time preprocessing the file, but after that, mapping the offset to the metadata needs to be near-instantaneous.<p class=next-group><span aria-level=3 class=side-header role=heading><span>PHFs</span></span>Problems like this are typically solved is by using <em>perfect hash functions</em>. These are hash functions trained on a particular key set, with a lucky property that the hashes of these keys don’t collide.<p>For example, for the key set <eq><math><mrow><mo form=prefix stretchy=false>{</mo><mn>12534</mn><mo separator=true>,</mo><mn>12421</mn><mo separator=true>,</mo><mn>123567</mn><mo form=postfix stretchy=false>}</mo></mrow></math></eq>, <eq><math><mrow><mi>H</mi><mo form=prefix stretchy=false>(</mo><mi>x</mi><mo form=postfix stretchy=false>)</mo><mo>=</mo></mrow><mrow><mi>x</mi><mi>&</mi><mn>3</mn></mrow></math></eq> is a valid PHF, because the hashes of the set are <eq><math><mrow><mo form=prefix stretchy=false>{</mo><mn>3</mn><mo separator=true>,</mo><mn>2</mn><mo separator=true>,</mo><mn>1</mn><mo form=postfix stretchy=false>}</mo></mrow></math></eq> with no collisions. Note that collisions may arise if <em>other</em> unlisted keys are hashed: this is not considered a problem.<p>After the PHF is built, we can just put the metadata into an array like this:<pre><code class=language-rust><span class=hljs-keyword>let</span> <span class=hljs-variable>hashtable</span> = [
    <span class=hljs-literal>None</span>,
    <span class="hljs-title function_ invoke__">Some</span>((<span class=hljs-number>123567</span>, value <span class=hljs-keyword>for</span> <span class=hljs-number>123567</span>)),
    <span class="hljs-title function_ invoke__">Some</span>((<span class=hljs-number>12421</span>, value <span class=hljs-keyword>for</span> <span class=hljs-number>12421</span>)),
    <span class="hljs-title function_ invoke__">Some</span>((<span class=hljs-number>12534</span>, value <span class=hljs-keyword>for</span> <span class=hljs-number>12534</span>)),
];
</code></pre><p>…and access it like this:<pre><code class=language-rust><span class=hljs-keyword>fn</span> <span class="hljs-title function_">get</span>(key: <span class=hljs-type>u32</span>) <span class=hljs-punctuation>-></span> <span class=hljs-type>Option</span>&LTValue> {
    <span class=hljs-keyword>let</span> (stored_key, value) = hashtable[<span class="hljs-title function_ invoke__">hash</span>(key)]?;
    <span class=hljs-comment>// If the keys match, this key was present in the original keyset and we can return the value.</span>
    <span class=hljs-comment>// If the keys don't match, this is an unlisted key and we can return None.</span>
    (key == stored_key).<span class="hljs-title function_ invoke__">then_some</span>(value)
}
</code></pre><div class=aside-group><aside><p>Okay, I’m overreacting. These crates aren’t really tuned towards my usecase, and they shine when used for string keys. But that doesn’t help <em>me</em>.</aside><p>There’s just one problem: all the classical PHFs are damn slow for my usecase! The <a href=https://docs.rs/phf/latest/phf/>phf</a> and <a href=https://docs.rs/boomphf/latest/boomphf/>boomphf</a> crates both take <code>14 ns</code> per access, perhaps because they use wyhash for internal hashing. We have 4 GHz CPUs these days, and these crates can’t even hash 100M integers per second!</div><p>Are you pondering what I’m pondering? We’re going to design a <eq><math><mrow><mn>10</mn><mo>×</mo></mrow></math></eq> faster PHF.<h2>Theory</h2><p class=next-group><span aria-level=3 class=side-header role=heading><span>Spooky math</span></span>The hash function clearly can’t be perfect for <em>all</em> keys, so it should depend on the key space. There’s many different key spaces, so there must be many different PHFs, and that means they have to store <em>data</em> that somehow corresponds to the key space. So a PHF is not just <em>code</em>, but also a set of <em>lookup-up tables</em>.<p>Most constant-time PHFs (and we do need constant time, because any unpredictable conditional jumps are going to hurt performance) use the following approach. Firstly, two <em>imperfect</em> random hash functions are chosen: <eq><math><mrow><mi>A</mi><mi>p</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>x</mi></mrow></math></eq> and <eq><math><mrow><mi>B</mi><mi>u</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>t</mi></mrow></math></eq>. <eq><math><mrow><mi>A</mi><mi>p</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>x</mi></mrow></math></eq> maps the key to its approximate hash (i.e. position in the hash table), while <eq><math><mrow><mi>B</mi><mi>u</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>t</mi></mrow></math></eq> maps the key to its bucket ID. For each bucket, a <em>displacement</em> value is stored in the look-up table, which is mixed with the approximate hash to obtain the final hash.<p>The idea is that while <eq><math><mrow><mi>A</mi><mi>p</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>x</mi></mrow></math></eq> hashes might collide, as long as the colliding keys are from different buckets, we can choose different displacements to avoid the collision. If a particular <eq><math><mrow><mo form=prefix stretchy=false>(</mo><mrow><mi>A</mi><mi>p</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>x</mi></mrow><mo separator=true>,</mo><mrow><mi>B</mi><mi>u</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>t</mi></mrow><mo form=postfix stretchy=false>)</mo></mrow></math></eq> combination still leads to collisions, we just choose another pair of imperfect hash functions and try again.<p>We control (and need to choose):<ul><li>The size of the hash space <eq><math><mi>M</mi></math></eq><li>The number of buckets <eq><math><mi>B</mi></math></eq><li>How the displacement is mixed into the hash<li>The displacement range<li><eq><math><mrow><mi>A</mi><mi>p</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>x</mi></mrow></math></eq> and <eq><math><mrow><mi>B</mi><mi>u</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>t</mi></mrow></math></eq></ul><p>Off we go.<p class=next-group><span aria-level=3 class=side-header role=heading><span>Hash space</span></span>We could round the number of keys to the next power of two and use that as the hash space size. This simplifies calculations, because taking a number modulo <eq><math><msup><mn>2</mn><mi>n</mi></msup></math></eq> is trivial. However, this wastes a lot of space in the hashtable. In my use case, the metadata is quite large, and storing a <code>Box&LTMetadata></code> is not an option, because indirections are slow.<p>Alternatively, we could equate the hash space size to the key space size. This is called a <em>minimal</em> PHF. Obviously, the probability of collision increases significantly as the number of free locations decreases, so building an mPHF is very slow compared to a non-minimal PHF.<div class=aside-group><aside><p>PTHash then transforms this almost-mPHF to an mPHF with a separate look-up table. That introduces a conditional branch and an indirection, which would leads to a major performance loss, so we have to bite the bullet and pay the <eq><math><mrow><mn>1</mn><mi>%</mi></mrow></math></eq> space increase.</aside><p>Finally, we could choose an in-between option. The authors of <a href=https://arxiv.org/pdf/2104.10402>PTHash</a> have found that using a <eq><math><mn>0.99</mn></math></eq> load factor (i.e. increasing the hash space size by <eq><math><mrow><mn>1</mn><mi>%</mi></mrow></math></eq>) significantly improves build time performance without increasing the memory use much, so that’s what we’re going to use.</div><p class=next-group><span aria-level=3 class=side-header role=heading><span>Bucket count</span></span>The number of buckets is a balance between memory consumption and build time. With <eq><math><mrow><mi>B</mi><mo>=</mo></mrow><mrow><mi>N</mi></mrow></math></eq>, the behavior is similar to cuckoo hashing, with all the space utilization problems. With <eq><math><mrow><mi>B</mi><mo>=</mo></mrow><mrow><mn>1</mn></mrow></math></eq>, the PHF degenerates to “use a random imperfect hash and hope for the best”.<p>This question is also tightly connected to the choice of <eq><math><mrow><mi>B</mi><mi>u</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>t</mi></mrow></math></eq> (which maps the key to its bucket). There are two common choices:<ul><li><a href=https://cmph.sourceforge.net/papers/esa09.pdf>CHD</a>: Choose a <em>uniform</em> <eq><math><mrow><mi>B</mi><mi>u</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>t</mi></mrow></math></eq>, with <eq><math><mn>5</mn></math></eq> keys per bucket on average (<eq><math><mrow><mi>B</mi><mo>=</mo></mrow><mrow><mfrac><mn>1</mn><mn>5</mn></mfrac><mi>N</mi></mrow></math></eq>)<li><a href=https://cmph.sourceforge.net/papers/fch92.pdf>FCH</a>: Choose a <em>significantly non-uniform</em> <eq><math><mrow><mi>B</mi><mi>u</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>t</mi></mrow></math></eq>, with <eq><math><mrow><mi>B</mi><mo>=</mo></mrow><mrow><mfrac><mrow><mn>6</mn><mi>N</mi></mrow><mrow><mspace width=0.1667em></mspace><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mspace width=0.1667em></mspace><mi>N</mi></mrow></mfrac></mrow></math></eq>.</ul><p>Using a non-uniform <eq><math><mrow><mi>B</mi><mi>u</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>t</mi></mrow></math></eq> sounds weird, but it’s actually intuitive when you think about it. To generate the bucket displacements, we’re going to process them in order. At the beginning of this process, the load factor is low, so almost every displacement works, but then it gets harder and harder. It is thus better to start with large buckets and work our way down to smaller buckets. Non-uniformity helps use this relation to reduce the number of buckets without sacrificing build time.<p>However, non-uniformity is hard to come by in practice. Usually, it’s achieved by computing a uniform hash and then skewing it artificially. This scaling takes time, which we have little of, so we’ll have to use the CHD approach.<p class=next-group><span aria-level=3 class=side-header role=heading><span>Mix function</span></span>There are many approaches to displacing the hash. As the approximate hash is uniformly random, the displacement itself does not necessarily have to be random. This means that we can just try adding <eq><math><mrow><mn>0</mn><mo separator=true>,</mo></mrow><mrow><mn>1</mn><mo separator=true>,</mo></mrow><mrow><mn>2</mn><mo separator=true>,</mo></mrow><mrow><mo>…</mo></mrow></math></eq> to the approximate hash, or maybe XOR it in.<p>While <eq><math><mo lspace=0em rspace=0em>+</mo></math></eq> and <eq><math><mo lspace=0em rspace=0em>⊕︎</mo></math></eq> (i.e. XOR) seem similar, they actually differ in several characteristics:<ul><li>Space utilization (better for <eq><math><mo lspace=0em rspace=0em>⊕︎</mo></math></eq>)<li>Build success probability (better for <eq><math><mo lspace=0em rspace=0em>+</mo></math></eq>)<li>Build time (better for <eq><math><mo lspace=0em rspace=0em>+</mo></math></eq>)</ul><p>For approximate hash <eq><math><mi>h</mi></math></eq> and displacement <eq><math><mi>d</mi></math></eq>, we can either have <eq><math><mrow><mi>h</mi><mo>⊕︎</mo></mrow><mrow><mi>d</mi></mrow></math></eq> or <eq><math><mrow><mi>h</mi><mo>+</mo></mrow><mrow><mi>d</mi></mrow></math></eq> as the final hash, and the former is clearly less in the general case. For large <eq><math><mi>h</mi></math></eq> and small <eq><math><mi>d</mi></math></eq>, this is not a big problem, but for smaller hash tables, using <eq><math><mo lspace=0em rspace=0em>⊕︎</mo></math></eq> reduces the hash table size.<p>The question of success rate is tangentially related to collision rate in open addressing vs closed addressing in hash tables. With <eq><math><mo lspace=0em rspace=0em>+</mo></math></eq>, buckets effectively partially overlap, just like in open addressing, while with <eq><math><mo lspace=0em rspace=0em>⊕︎</mo></math></eq>, they either match completely or don’t intersect at all, just like in closed addressing. In typical hash tables, we’re only interested in the <em>expected</em> collisions, while in PHFs, any collisions that can’t be resolved by displacements are fatal. It’s a well-known fact (I hope so, anyway; I don’t want to burden you with a proof here) that open addressing is more lax in this regard.<p>As for the build time, we’ll discover why the mix function matters later.<p class=next-group><span aria-level=3 class=side-header role=heading><span>Displacements</span></span>How many different displacements do we need to try, i.e. what is the largest <eq><math><mi>d</mi></math></eq> we can expect, and what datatype should we use? There’s quite a bit of math here; feel free to skip it if that’s not your kind of thing.<p>For bucket of size <eq><math><mi>b</mi></math></eq> and current load factor is <eq><math><mi>α</mi></math></eq>, we can expect a success rate of <eq><math><mrow><mo form=prefix stretchy=false>(</mo><mn>1</mn><mo>−</mo><mi>α</mi><msup><mo form=postfix stretchy=false>)</mo><mi>b</mi></msup></mrow></math></eq> per displacement. Bucket sizes are distributed according to the Poisson distribution, so <eq><math><mrow><mi>α</mi><mo>≈</mo></mrow><mrow><mn>1.01</mn><mo>−</mo></mrow><mrow><mi>Q</mi><mo form=prefix stretchy=false>(</mo><mi>b</mi><mo separator=true>,</mo><mn>5</mn><mo form=postfix stretchy=false>)</mo></mrow></math></eq>, thus the success rate is <eq><math><mrow><mo form=prefix stretchy=false>(</mo><mi>Q</mi><mo form=prefix stretchy=false>(</mo><mi>b</mi><mo separator=true>,</mo><mn>5</mn><mo form=postfix stretchy=false>)</mo><mo>+</mo><mn>0.01</mn><msup><mo form=postfix stretchy=false>)</mo><mi>b</mi></msup></mrow></math></eq>. This peaks at around <eq><math><mrow><mn>1</mn><mi>/</mi><mn>400</mn></mrow></math></eq>, indicating an expected number of <eq><math><mn>400</mn></math></eq> displacements until success. This is the result for <em>one</em> bucket; the probability for <em>all</em> bucket displacements to be small is lower. In practice, I have found that using <eq><math><mn>16</mn></math></eq>-bit displacements works for sizes up to several million with high probability, which suffices for my usecase.<h2>Implementation</h2><p class=next-group><span aria-level=3 class=side-header role=heading><span>Uniformity</span></span>Popular non-cryptographic hash functions are a big no-no due to performance considerations, and preferably, we should avoid them altogether.<p>To do this, we need to inspect the input data. As a quick reminder, the keys are data structure offsets. The offsets aren’t uniformly random (why would they be, with a variable-length format?), but some bits have more entropy than others. Lower bits have little entropy due to alignment, higher bits have little entropy due to the structure, but some bits inbetween work well as an entropy source.<p>Here’s a distribution plot for 1.5 M keys, rotated by different amounts of bits:<p><div class=diagram><img alt="32 distribution plots, for shifts from 0 to 31 inclusive. For shift 0, the plot is clearly non-uniform, but looks close to that of a continuous function. For shifts 1 to 6, the plot shows increasingly many visible peaks with nothing inbetween. For shifts 7 to 12, these peaks grow in number until the plot becomes visibly uniform. For shifts 13 to 16, the plot is uniform. For shifts 17 to 31, uniformity slowly breaks down and the plot slowly starts to look closer to the original non-uniform almost-continuous plot."title="32 distribution plots, for shifts from 0 to 31 inclusive. For shift 0, the plot is clearly non-uniform, but looks close to that of a continuous function. For shifts 1 to 6, the plot shows increasingly many visible peaks with nothing inbetween. For shifts 7 to 12, these peaks grow in number until the plot becomes visibly uniform. For shifts 13 to 16, the plot is uniform. For shifts 17 to 31, uniformity slowly breaks down and the plot slowly starts to look closer to the original non-uniform almost-continuous plot."src=distribution.png></div><p>With <a href=https://en.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test>the KS test</a> we can ensure that the most uniform result (on a large scale; low bits, of course, stay non-uniform) is produced by rotation by <eq><math><mn>14</mn></math></eq> bits (and, surprisingly, by <eq><math><mn>11</mn></math></eq>), differing from a real uniform distribution by only <eq><math><mrow><mn>0.8</mn><mi>%</mi></mrow></math></eq> max. With just <em>one</em> instruction, we’ve turned the input into a suitable hash! On x86-64, that takes one tick.<p>But then I had a very good idea. I used <a href=https://uops.info/table.html>uops.info</a>. See, using uops.info gave me a whole new perspective and I was able to see an instruction I couldn’t have seen before.<p>It turns out that rotation is not the best one-tick way to increase uniformity. This ought to be surprising, because there’s very few one-tick instructions, and they typically perform linear arithmetic, which doesn’t shuffle bits in any way. But there’s <em>one</em> instruction that does: <code>bswap</code>. It swaps bits inside of a 32-bit register, and with certain inputs, it generates more entropy than rotation does. So in practice, we need to choose whether to use rotation or <code>bswap</code> depending on the data.<p class=next-group><span aria-level=3 class=side-header role=heading><span>Hash functions</span></span><em>Finally</em> we’re getting closer to writing some code. We need to design <eq><math><mrow><mi>A</mi><mi>p</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>x</mi></mrow></math></eq> and <eq><math><mrow><mi>B</mi><mi>u</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>t</mi></mrow></math></eq>, the functions for mapping keys to approximate hashes and for mapping keys to buckets.<p>Now here’s a problem. We’ve got a “uniform” <eq><math><mn>32</mn></math></eq>-bit number, but <eq><math><mrow><mi>A</mi><mi>p</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>x</mi></mrow></math></eq> needs to output a number between <eq><math><mn>0</mn></math></eq> and <eq><math><mrow><mi>M</mi><mo>=</mo></mrow><mrow><mn>1.01</mn><mi>N</mi></mrow></math></eq>, which isn’t necessarily a power of two, so we’ll need to perform another calculation to scale the uniform hash. Scale, you say? That’s just fixed-point multiplication: <eq><math><mrow><mo form=prefix stretchy=false>(</mo><mi>h</mi><mo>×</mo><mi>M</mi><mo form=postfix stretchy=false>)</mo><mo rspace=0em>></mo></mrow><mrow><mo lspace=0em>></mo></mrow><mrow><mn>32</mn></mrow></math></eq> maps <eq><math><mrow><mi>h</mi><mo>∈</mo></mrow><mrow><mo form=prefix stretchy=false>[</mo><mn>0</mn><mo separator=true>;</mo><msup><mn>2</mn><mn>32</mn></msup><mo form=postfix stretchy=false>)</mo></mrow></math></eq> to <eq><math><mrow><mo form=prefix stretchy=false>[</mo><mn>0</mn><mo separator=true>;</mo><mi>M</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq>, which is precisely what we need.<p>What about <eq><math><mrow><mi>B</mi><mi>u</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>t</mi></mrow></math></eq>? I’d rather avoid yet another multiplication, so we’ll have to bite the bullet and round the bucket count to a power of two (buckets take little space per key, so that’s okay). We can then use the <em>lower</em> half of the <eq><math><mrow><mn>32</mn><mo>×</mo></mrow><mrow><mn>32</mn></mrow></math></eq> multiplication, shifted to the right, as a bucket index.<p>On x86-64, multiplication takes 3 ticks, and the two shifts (to obtain the high part and to get the bucket index) can be computed in parallel, taking 1 tick each.<p>So that’s, uh, a good hash with a 5 tick latency:<pre><code class=language-rust><span class=hljs-keyword>struct</span> <span class="hljs-title class_">Precomputed</span> {
    entropy_shift: <span class=hljs-type>u32</span>,
    hash_space: <span class=hljs-type>u32</span>,
    bucket_shift: <span class=hljs-type>u32</span>,
}

<span class=hljs-keyword>struct</span> <span class="hljs-title class_">Hash</span> {
    approx: <span class=hljs-type>u32</span>,
    bucket: <span class=hljs-type>u32</span>,
}

<span class=hljs-keyword>fn</span> <span class="hljs-title function_">hash</span>(key: <span class=hljs-type>u32</span>, precomputed: Precomputed) <span class=hljs-punctuation>-></span> Hash {
    <span class=hljs-keyword>let</span> <span class=hljs-variable>h</span> = key.<span class="hljs-title function_ invoke__">rotate_right</span>(precomputed.entropy_shift); <span class=hljs-comment>// 1 tick</span>
    <span class=hljs-comment>// Alternatively: let h = key.swap_bytes(); // 1 tick</span>
    <span class=hljs-keyword>let</span> <span class=hljs-variable>product</span> = h <span class=hljs-keyword>as</span> <span class=hljs-type>u64</span> * precomputed.hash_space <span class=hljs-keyword>as</span> <span class=hljs-type>u64</span>; <span class=hljs-comment>// 3 ticks</span>
    Hash {
        approx: (product >> <span class=hljs-number>32</span>) <span class=hljs-keyword>as</span> <span class=hljs-type>u32</span>, <span class=hljs-comment>// 1 tick</span>
        bucket: (product <span class=hljs-keyword>as</span> <span class=hljs-type>u32</span>) >> precomputed.bucket_shift, <span class=hljs-comment>// 1 tick (computed concurrently)</span>
    }
}
</code></pre><p>Nevermind the memory loads; these will go away after inlining:<pre><code class=language-x86asm><span class=hljs-symbol>hash:</span>
    <span class=hljs-keyword>movzx</span>   <span class=hljs-built_in>ecx</span>, <span class=hljs-built_in>byte</span> <span class=hljs-built_in>ptr</span> [<span class=hljs-built_in>rsi</span>]
    <span class=hljs-keyword>ror</span>     <span class=hljs-built_in>edi</span>, <span class=hljs-built_in>cl</span> <span class=hljs-comment>; 1 tick</span>
    <span class=hljs-keyword>mov</span>     <span class=hljs-built_in>edx</span>, <span class=hljs-built_in>dword</span> <span class=hljs-built_in>ptr</span> [<span class=hljs-built_in>rsi</span> + <span class=hljs-number>4</span>]
    <span class=hljs-keyword>imul</span>    <span class=hljs-built_in>rdx</span>, <span class=hljs-built_in>rdi</span> <span class=hljs-comment>; 3 ticks</span>
    <span class=hljs-keyword>mov</span>     <span class=hljs-built_in>rax</span>, <span class=hljs-built_in>rdx</span>
    <span class=hljs-keyword>movzx</span>   <span class=hljs-built_in>ecx</span>, <span class=hljs-built_in>byte</span> <span class=hljs-built_in>ptr</span> [<span class=hljs-built_in>rsi</span> + <span class=hljs-number>8</span>]
    <span class=hljs-keyword>shr</span>     <span class=hljs-built_in>edx</span>, <span class=hljs-built_in>cl</span> <span class=hljs-comment>; 1 tick</span>
    <span class=hljs-keyword>shr</span>     <span class=hljs-built_in>rax</span>, <span class=hljs-number>32</span> <span class=hljs-comment>; 1 tick (computed concurrently)</span>
    <span class=hljs-keyword>ret</span>
</code></pre><p>Now all we have to do is compute the final hash with <eq><math><mrow><mrow><mtext></mtext><mi>mix</mi></mrow><mo form=prefix stretchy=false>(</mo><mrow><mi>A</mi><mi>p</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>x</mi></mrow><mo separator=true>,</mo><mrow><mi>D</mi><mi>i</mi><mi>s</mi><mi>p</mi></mrow><mo form=prefix stretchy=false>[</mo><mrow><mi>B</mi><mi>u</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>t</mi></mrow><mo form=postfix stretchy=false>]</mo><mo form=postfix stretchy=false>)</mo></mrow></math></eq>.<h2>Generation</h2><p class=next-group><span aria-level=3 class=side-header role=heading><span>The what?</span></span>Okay, now how do we <em>generate</em> the table in the first place? We need to decide on:<ul><li><code>entropy_shift</code> (or to switch to <code>swap_bytes</code>)<li><code>hash_space</code><li><code>bucket_shift</code><li>The displacement LUT</ul><p>None of these are as simple as they look like.<p class=next-group><span aria-level=3 class=side-header role=heading><span>Entropy shift</span></span>For this, we need a way to measure the uniformity of a distribution. Typical solutions assume the existence of a probability distribution function, but we only have access to a sample of the distribution, so we’ll use <a href=https://en.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test>the KS test</a> instead. In layman terms, we just sort the hashes in increasing order, draw a scatter plot, and compare it to a straight line.<p>Not that this needs to be particularly performant, but avoiding floating point operations sounds like a nice bonus, so let’s do that. We need to compute approximately <eq><math><mrow><munderover><mi>max</mi><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></munderover><mo>⁡</mo></mrow><mrow><mrow><mo fence=true form=prefix>|</mo><mfrac><msub><mi>h</mi><mi>i</mi></msub><msup><mn>2</mn><mn>32</mn></msup></mfrac><mo>−</mo><mfrac><mi>i</mi><mi>N</mi></mfrac><mo fence=true form=postfix>|</mo></mrow></mrow></math></eq>, which we can do as follows:<pre><code class=language-rust><span class=hljs-keyword>fn</span> <span class="hljs-title function_">compute_ks_for_sorted</span>(hashes: &[<span class=hljs-type>u32</span>]) <span class=hljs-punctuation>-></span> <span class=hljs-type>f32</span> {
    <span class=hljs-keyword>let</span> <span class=hljs-variable>scaled_abs</span> = hashes
        .<span class="hljs-title function_ invoke__">into_iter</span>()
        .<span class="hljs-title function_ invoke__">enumerate</span>()
        .<span class="hljs-title function_ invoke__">map</span>(|(i, hash)| (*hash <span class=hljs-keyword>as</span> <span class=hljs-type>u64</span> * hashes.<span class="hljs-title function_ invoke__">len</span>() <span class=hljs-keyword>as</span> <span class=hljs-type>u64</span>).<span class="hljs-title function_ invoke__">abs_diff</span>((i <span class=hljs-keyword>as</span> <span class=hljs-type>u64</span>) << <span class=hljs-number>32</span>))
        .<span class="hljs-title function_ invoke__">max</span>()
        .<span class="hljs-title function_ invoke__">unwrap</span>();
    (scaled_abs >> <span class=hljs-number>32</span>) <span class=hljs-keyword>as</span> <span class=hljs-type>f32</span> / hashes.<span class="hljs-title function_ invoke__">len</span>() <span class=hljs-keyword>as</span> <span class=hljs-type>f32</span>
}
</code></pre><p>This takes <eq><math><mn>1.5</mn></math></eq> ns per key to compute, so it’s fine, I guess?<p>Now we just need to figure out how to sort the hashes for 32 different shift amounts without sorting the array 32 times. Luckily, this is easy to do: when a sorted array is rotated to the left by one bit, the two halves (split by the highest bit pre-rotate and by the lowest bit post-rotate) are still sorted, so we can just merge them together in <eq><math><mrow><mi>O</mi><mo form=prefix stretchy=false>(</mo><mi>n</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq>:<pre><code class=language-rust><div class=expansible-code><input id=expansible1 type=checkbox><div class=highlighted><span class=hljs-keyword>fn</span> <span class="hljs-title function_">rotate_left_sorted</span>(source: &[<span class=hljs-type>u32</span>], target: &<span class=hljs-keyword>mut</span> [<span class=hljs-type>u32</span>]) {
    <span class=hljs-built_in>assert_eq!</span>(source.<span class="hljs-title function_ invoke__">len</span>(), target.<span class="hljs-title function_ invoke__">len</span>());

    <span class=hljs-keyword>let</span> <span class=hljs-variable>middle</span> = source.<span class="hljs-title function_ invoke__">partition_point</span>(|key| (key >> <span class=hljs-number>31</span>) == <span class=hljs-number>0</span>);
    <span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>i</span> = <span class=hljs-number>0</span>;
    <span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>j</span> = middle;

    <span class=hljs-comment>// Sorry, itertools, this is faster</span>
    <span class=hljs-keyword>while</span> i < middle && j < source.<span class="hljs-title function_ invoke__">len</span>() {
        <span class=hljs-keyword>let</span> <span class=hljs-variable>i_value</span> = source[i].<span class="hljs-title function_ invoke__">rotate_left</span>(<span class=hljs-number>1</span>);
        <span class=hljs-keyword>let</span> <span class=hljs-variable>j_value</span> = source[j].<span class="hljs-title function_ invoke__">rotate_left</span>(<span class=hljs-number>1</span>);
        <span class=hljs-keyword>if</span> i_value < j_value {
            target[i + j - middle] = i_value;
            i += <span class=hljs-number>1</span>;
        } <span class=hljs-keyword>else</span> {
            target[i + j - middle] = j_value;
            j += <span class=hljs-number>1</span>;
        }
    }
    <span class=hljs-keyword>while</span> i < middle {
        target[i + j - middle] = source[i].<span class="hljs-title function_ invoke__">rotate_left</span>(<span class=hljs-number>1</span>);
        i += <span class=hljs-number>1</span>;
    }
    <span class=hljs-keyword>while</span> j < source.<span class="hljs-title function_ invoke__">len</span>() {
        target[i + j - middle] = source[j].<span class="hljs-title function_ invoke__">rotate_left</span>(<span class=hljs-number>1</span>);
        j += <span class=hljs-number>1</span>;
    }
}
</div><label for=expansible1>Expand</label></div></code></pre><p>This takes <eq><math><mn>2</mn></math></eq> ns per key. Good enough.<p class=next-group><span aria-level=3 class=side-header role=heading><span>Hash space</span></span>This looks trivial: just round <eq><math><mrow><mn>1.01</mn><mi>n</mi></mrow></math></eq> up. But there’s three pitfalls here.<p>The easier one is that multiplying by an even number shifts entropy to the left, so there might not be enough entropy left for <eq><math><mrow><mi>B</mi><mi>u</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>t</mi></mrow></math></eq>. Thus <code>hash_space</code> needs to be odd.<p>The medium one is that this makes hash calculation completely deterministic. Do you remember that PHF building is a probabilistic process, and if too many collisions arise from the imperfect hash functions <eq><math><mrow><mrow><mi>A</mi><mi>p</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>x</mi></mrow><mo separator=true>,</mo></mrow><mrow><mrow><mi>B</mi><mi>u</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>t</mi></mrow></mrow></math></eq>, we need to regenerate them? Well, among all the variables we can easily control, our hash functions depend exclusively on <code>entropy_shift</code> and <code>hash_space</code>. We <em>really</em> want to play around with them, so we’ll have to try different <code>hash_space</code> values out: perhaps <eq><math><mrow><mn>1.01</mn><mi>n</mi><mo separator=true>,</mo></mrow><mrow><mn>1.02</mn><mi>n</mi><mo separator=true>,</mo></mrow><mrow><mn>1.03</mn><mi>n</mi><mo separator=true>,</mo></mrow><mrow><mo>…</mo></mrow></math></eq>. This also has a bonus of decreasing the load factor, thus offsetting the effect of a limited displacement range.<p>The harder one is that while <eq><math><mrow><mi>A</mi><mi>p</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>x</mi></mrow></math></eq> can be in-bounds, <eq><math><mrow><mrow><mtext></mtext><mi>mix</mi></mrow><mo form=prefix stretchy=false>(</mo><mrow><mi>A</mi><mi>p</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>x</mi></mrow><mo separator=true>,</mo><mrow><mi>D</mi><mi>i</mi><mi>s</mi><mi>p</mi></mrow><mo form=prefix stretchy=false>[</mo><mrow><mi>B</mi><mi>u</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>t</mi></mrow><mo form=postfix stretchy=false>]</mo><mo form=postfix stretchy=false>)</mo></mrow></math></eq> can be out-of-bounds. For example, for hash table size <eq><math><mn>5</mn></math></eq>, a key with approximate hash <eq><math><mn>4</mn></math></eq> and displacement <eq><math><mn>2</mn></math></eq> has final index <eq><math><mn>6</mn></math></eq> (for both <eq><math><mo lspace=0em rspace=0em>+</mo></math></eq> and <eq><math><mo lspace=0em rspace=0em>⊕︎</mo></math></eq> mixing functions). Handling this case as wrap-around is a performance hazard, and forbidding such out-of-bounds accesses decreases the probability of a successful build. The solution is to keep the output space of <eq><math><mrow><mi>A</mi><mi>p</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>x</mi></mrow></math></eq> (i.e. <code>hash_space</code>) limited to <eq><math><mrow><mn>1.01</mn><mi>n</mi></mrow></math></eq> (or another multiple of <eq><math><mi>n</mi></math></eq>), but pad the resulting hash table to the right such that all possible accesses are in-bounds.<p>There’s a conundrum here. Do we make <em>accesses to existing elements</em> in-bounds, or do we legalize <em>all accesses</em>? If accessed keys are guaranteed to be present in the hashmap, the former suffices; if we need to add an existence check (like in the first example in this post), we need to do the latter. My case calls for access verification, so we’ll need to make all accesses sound, increasing the hash table size to <em>[Insert incomprehensible math warning]</em> <eq><math><mrow><mn>1</mn><mo>+</mo></mrow><mrow><munderover><mi>max</mi><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>B</mi><mo>−</mo><mn>1</mn></mrow></munderover><mo>⁡</mo><mspace width=0.1667em></mspace></mrow><mrow><munderover><mi>max</mi><mrow><mi>x</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>M</mi><mo>−</mo><mn>1</mn></mrow></munderover><mo>⁡</mo><mspace width=0.1667em></mspace></mrow><mrow><mrow><mtext></mtext><mi>mix</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>x</mi><mo separator=true>,</mo><msub><mrow><mi>D</mi><mi>i</mi><mi>s</mi><mi>p</mi></mrow><mi>i</mi></msub><mo form=postfix stretchy=false>)</mo></mrow></math></eq>.<p>For the <eq><math><mo lspace=0em rspace=0em>+</mo></math></eq> mixing function, this is just <eq><math><mrow><mi>M</mi><mo>+</mo></mrow><mrow><munderover><mi>max</mi><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>B</mi><mo>−</mo><mn>1</mn></mrow></munderover><mo>⁡</mo><mspace width=0.1667em></mspace></mrow><mrow><msub><mrow><mi>D</mi><mi>i</mi><mi>s</mi><mi>p</mi></mrow><mi>i</mi></msub></mrow></math></eq>. For <eq><math><mo lspace=0em rspace=0em>⊕︎</mo></math></eq>, a tighter boundary is possible; I’m a nerd, so we’re going to solve this Leetcode problem now. Skip to the next section if you despise that sort of thing.<p>We’re looking for a way to calculate <eq><math><mrow><munderover><mi>max</mi><mrow><mi>x</mi><mo>=</mo><mn>0</mn></mrow><mi>X</mi></munderover><mo>⁡</mo><mspace width=0.1667em></mspace></mrow><mrow><mi>x</mi><mo>⊕︎</mo></mrow><mrow><mi>Y</mi></mrow></math></eq> in <eq><math><mrow><mi>O</mi><mo form=prefix stretchy=false>(</mo><mn>1</mn><mo form=postfix stretchy=false>)</mo></mrow></math></eq> for different <eq><math><mi>Y</mi></math></eq> values. I won’t bore you with details, but it works like this:<pre><code class=language-rust><span class=hljs-keyword>fn</span> <span class="hljs-title function_">max_xor</span>(x: <span class=hljs-type>usize</span>, y: <span class=hljs-type>usize</span>) <span class=hljs-punctuation>-></span> <span class=hljs-type>usize</span> {
    <span class=hljs-keyword>let</span> <span class=hljs-variable>bound</span> = (x & y).<span class="hljs-title function_ invoke__">checked_ilog2</span>().<span class="hljs-title function_ invoke__">unwrap_or</span>(<span class=hljs-number>0</span>);
    x | y | ((<span class=hljs-number>1</span> << bound) - <span class=hljs-number>1</span>)
}
</code></pre><div class=aside-group><aside><p>Hint: try to compute the largest <eq><math><mrow><mi>x</mi><mo>⊕︎</mo></mrow><mrow><mi>Y</mi></mrow></math></eq> bit by bit, from high to low. If <eq><math><mi>X</mi></math></eq> and <eq><math><mi>Y</mi></math></eq> have different bits at some position, the resulting bit can easily be <eq><math><mn>1</mn></math></eq>, which is the largest possible value. However, when both <eq><math><mi>X</mi></math></eq> and <eq><math><mi>Y</mi></math></eq> have a <eq><math><mn>1</mn></math></eq> bit, we can decrease <eq><math><mi>X</mi></math></eq> so that this bit is <eq><math><mn>0</mn></math></eq> and all the following bits are inverses of <eq><math><mi>Y</mi></math></eq>.</aside><p>Proving this is left as an exercise to the reader. I have no intuition for why this function is symmetric; if you figure it out, please let me know. Anyway; this function is monotonous in <eq><math><mi>X</mi></math></eq> (by definition) and symmetric (by implementation), so it’s monotonous in <eq><math><mi>Y</mi></math></eq>, so instead of substituting several displacements, we can just substitute the largest one, i.e. the hash table size is <eq><math><mrow><mn>1</mn><mo>+</mo></mrow><mrow><mrow><mrow><mi mathvariant=normal>m</mi></mrow><mrow><mi mathvariant=normal>a</mi></mrow><mrow><mi mathvariant=normal>x</mi></mrow><mi>_</mi><mrow><mi mathvariant=normal>x</mi></mrow><mrow><mi mathvariant=normal>o</mi></mrow><mrow><mi mathvariant=normal>r</mi></mrow></mrow><mrow><mo fence=true form=prefix>(</mo><mi>M</mi><mo>−</mo><mn>1</mn><mo separator=true>,</mo><munderover><mi>max</mi><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>B</mi><mo>−</mo><mn>1</mn></mrow></munderover><mo>⁡</mo><mspace width=0.1667em></mspace><msub><mrow><mi>D</mi><mi>i</mi><mi>s</mi><mi>p</mi></mrow><mi>i</mi></msub><mo fence=true form=postfix>)</mo></mrow></mrow></math></eq>.</div><p class=next-group><span aria-level=3 class=side-header role=heading><span>Fallback</span></span>Before we continue talking about generation parameters, we need to talk about generating a <em>family</em> of hash functions again. As a reminder, we need to generate new <eq><math><mrow><mrow><mi>A</mi><mi>p</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>x</mi></mrow><mo separator=true>,</mo></mrow><mrow><mrow><mi>B</mi><mi>u</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>t</mi></mrow></mrow></math></eq> hashes if the current ones lead to collisions. We can affect <code>hash_space</code> and <code>entropy_shift</code>, which is a nice hack, but it doesn’t always work, because it does not completely reshuffle the key hashes; rather, it tweaks them slightly, barely enough that the collision <em>might</em> go away.<p>So here’s how the fallback implementation works. The reason we have a slow multiplication calculation is that <code>hash_space</code> is not a power of two; if we <em>fail</em> to generate a small enough non-power-of-two table, we round <code>hash_space</code> up to a power of two, replacing the multiplication with a bitwise operation. This frees up 2 ticks, enabling us to bring a multiplication <em>back</em>. You see, multiplication by an odd number shuffles the bits quite well, so we can just multiply <code>h</code> by an honest-to-God random number:<pre><code class=language-rust><span class=hljs-keyword>fn</span> <span class="hljs-title function_">hash</span>(key: <span class=hljs-type>u32</span>, precomputed: Precomputed) <span class=hljs-punctuation>-></span> Hash {
    <span class=hljs-keyword>let</span> <span class=hljs-variable>h</span> = key.<span class="hljs-title function_ invoke__">rotate_right</span>(precomputed.entropy_shift); <span class=hljs-comment>// 1 tick</span>
    <span class=hljs-comment>// Alternatively: let h = key.swap_bytes(); // 1 tick</span>
    <span class=hljs-keyword>let</span> <span class=hljs-variable>h</span> = h <span class=hljs-keyword>as</span> <span class=hljs-type>u64</span> * precomputed.random_factor <span class=hljs-keyword>as</span> <span class=hljs-type>u64</span>; <span class=hljs-comment>// 3 ticks</span>
    Hash {
        approx: (h >> <span class=hljs-number>32</span>) <span class=hljs-keyword>as</span> <span class=hljs-type>u32</span> & precomputed.hash_space_minus_one, <span class=hljs-comment>// 2 ticks</span>
        bucket: (h <span class=hljs-keyword>as</span> <span class=hljs-type>u32</span>) >> precomputed.bucket_shift, <span class=hljs-comment>// 1 tick (computed concurrently)</span>
    }
}
</code></pre><p><code>random_factor</code> does not affect performance characteristics like <code>hash_space</code> did, so we can use an arbtirary factor. This significantly increases the chances of a successful generation, only decreasing fallback performance by 1 tick.<p class=next-group><span aria-level=3 class=side-header role=heading><span>Bucket shift</span></span>I lied, this one’s actually simple. A good change of pace. Do you feel relieved? Please feel relieved.<p>If you still remember, we compute <eq><math><mrow><mi>B</mi><mi>u</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>t</mi></mrow></math></eq> of a key as <code>(product as u32) >> bucket_shift</code>, so <code>bucket_shift</code> is just <eq><math><mrow><mn>32</mn><mo>−</mo></mrow><mrow><msub><mi>log</mi><mn>2</mn></msub><mo>⁡</mo><mspace width=0.1667em></mspace></mrow><mrow><mi>B</mi></mrow></math></eq>, and the bucket count is <eq><math><mrow><mfrac><mn>1</mn><mn>5</mn></mfrac><mi>N</mi></mrow></math></eq> (shamelessly stolen from CHD), rounded up to a power of two.<p class=next-group><span aria-level=3 class=side-header role=heading><span>Displacements</span></span>Displacements are a core part of PHFs, so this part’s more typical. We split keys into buckets according to <eq><math><mrow><mi>B</mi><mi>u</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>t</mi></mrow></math></eq>, sort the buckets in order of decreasing size, and assign displacements to buckets in order. We try displacements <eq><math><mrow><mn>0</mn><mo separator=true>,</mo></mrow><mrow><mn>1</mn><mo separator=true>,</mo></mrow><mrow><mn>2</mn><mo separator=true>,</mo></mrow><mrow><mo>…</mo></mrow><mrow><mo separator=true>,</mo></mrow><mrow><msup><mn>2</mn><mn>16</mn></msup><mo>−</mo></mrow><mrow><mn>1</mn></mrow></math></eq>; the first applicable displacement (s.t. the elements don’t collide with already assigned ones) is used. If no displacement works, we restart the algorithm with different hash functions.<p>The basic idea of what we’re trying to do is this:<pre><code class=language-rust><div class=expansible-code><input id=expansible2 type=checkbox><div class=highlighted><span class=hljs-keyword>struct</span> <span class="hljs-title class_">Phf</span> {
    hash_space: <span class=hljs-type>u32</span>,
    bucket_shift: <span class=hljs-type>u32</span>,
    displacements: <span class=hljs-type>Vec</span><<span class=hljs-type>u16</span>>,
}

<span class=hljs-keyword>fn</span> <span class="hljs-title function_">try_generate_phf</span>(keys: &[<span class=hljs-type>u32</span>]) <span class=hljs-punctuation>-></span> <span class=hljs-type>Option</span>&LTPhf> {
    <span class=hljs-comment>// Hash space. <span class=hljs-doctag>TODO:</span> Increase on failure.</span>
    <span class=hljs-keyword>let</span> <span class=hljs-variable>hash_space</span> = (keys.<span class="hljs-title function_ invoke__">len</span>() + keys.<span class="hljs-title function_ invoke__">len</span>().<span class="hljs-title function_ invoke__">div_ceil</span>(<span class=hljs-number>100</span>)) | <span class=hljs-number>1</span>;

    <span class=hljs-comment>// Number of buckets</span>
    <span class=hljs-keyword>let</span> <span class=hljs-variable>b</span> = (keys.<span class="hljs-title function_ invoke__">len</span>().<span class="hljs-title function_ invoke__">div_ceil</span>(<span class=hljs-number>5</span>) + <span class=hljs-number>1</span>).<span class="hljs-title function_ invoke__">next_power_of_two</span>();

    <span class=hljs-comment>// Split keys into buckets</span>
    <span class=hljs-keyword>let</span> <span class=hljs-variable>bucket_shift</span> = <span class=hljs-number>32</span> - b.<span class="hljs-title function_ invoke__">ilog2</span>();
    <span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>keys_per_bucket</span> = <span class=hljs-built_in>vec!</span>[<span class=hljs-type>Vec</span>::<span class="hljs-title function_ invoke__">new</span>(); b];
    <span class=hljs-keyword>for</span> <span class=hljs-variable>key</span> <span class=hljs-keyword>in</span> keys {
        <span class=hljs-comment>// <span class=hljs-doctag>TODO:</span> Apply entropy shift.</span>
        <span class=hljs-keyword>let</span> <span class=hljs-variable>bucket</span> = key.<span class="hljs-title function_ invoke__">wrapping_mul</span>(hash_space <span class=hljs-keyword>as</span> <span class=hljs-type>u32</span>) >> bucket_shift;
        keys_per_bucket[bucket <span class=hljs-keyword>as</span> <span class=hljs-type>usize</span>].<span class="hljs-title function_ invoke__">push</span>(*key);
    }

    <span class=hljs-comment>// Reserve space for elements, plus 2^16 - 1 for out-of-bounds displacements</span>
    <span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>free</span> = <span class=hljs-built_in>vec!</span>[<span class=hljs-literal>true</span>; hash_space + <span class=hljs-type>u16</span>::MAX <span class=hljs-keyword>as</span> <span class=hljs-type>usize</span>];

    <span class=hljs-comment>// We'll fill this per-bucket array during the course of the algorithm</span>
    <span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>displacements</span> = <span class=hljs-built_in>vec!</span>[<span class=hljs-number>0</span>; b];

    <span class=hljs-comment>// Handle buckets in order of decreasing size</span>
    <span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>bucket_order</span>: <span class=hljs-type>Vec</span><<span class=hljs-type>usize</span>> = (<span class=hljs-number>0</span>..b).<span class="hljs-title function_ invoke__">collect</span>();
    bucket_order.<span class="hljs-title function_ invoke__">sort_unstable_by_key</span>(|bucket| core::cmp::<span class="hljs-title function_ invoke__">Reverse</span>(keys_per_bucket[*bucket].<span class="hljs-title function_ invoke__">len</span>()));
    <span class=hljs-keyword>for</span> <span class=hljs-variable>bucket</span> <span class=hljs-keyword>in</span> bucket_order {
        <span class=hljs-comment>// Compute all Approx values preemptively</span>
        <span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>approx_for_bucket</span>: <span class=hljs-type>Vec</span><<span class=hljs-type>u32</span>> = keys_per_bucket[bucket]
            .<span class="hljs-title function_ invoke__">drain</span>(..)
            .<span class="hljs-title function_ invoke__">map</span>(|key| ((key <span class=hljs-keyword>as</span> <span class=hljs-type>u64</span> * hash_space <span class=hljs-keyword>as</span> <span class=hljs-type>u64</span>) >> <span class=hljs-number>32</span>) <span class=hljs-keyword>as</span> <span class=hljs-type>u32</span>)
            .<span class="hljs-title function_ invoke__">collect</span>();

        <span class=hljs-comment>// Ensure that Approx values don't collide inside the bucket</span>
        approx_for_bucket.<span class="hljs-title function_ invoke__">sort_unstable</span>();
        <span class=hljs-keyword>if</span> approx_for_bucket
            .<span class="hljs-title function_ invoke__">windows</span>(<span class=hljs-number>2</span>)
            .<span class="hljs-title function_ invoke__">any</span>(|window| window[<span class=hljs-number>0</span>] == window[<span class=hljs-number>1</span>])
        {
            <span class=hljs-keyword>return</span> <span class=hljs-literal>None</span>;
        }

        <span class=hljs-comment>// Find non-colliding displacement. On failure, return None.</span>
        <span class=hljs-keyword>let</span> <span class=hljs-variable>displacement</span> = (<span class=hljs-number>0</span>..=<span class=hljs-type>u16</span>::MAX).<span class="hljs-title function_ invoke__">find</span>(|displacement| {
            approx_for_bucket.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">all</span>(|approx| *<span class=hljs-keyword>unsafe</span> {
                free.<span class="hljs-title function_ invoke__">get_unchecked</span>(<span class="hljs-title function_ invoke__">mix</span>(*approx, *displacement) <span class=hljs-keyword>as</span> <span class=hljs-type>usize</span>)
            })
        })?;

        <span class=hljs-comment>// Place the bucket</span>
        displacements[bucket] = displacement;
        <span class=hljs-keyword>for</span> <span class=hljs-variable>approx</span> <span class=hljs-keyword>in</span> approx_for_bucket {
            *<span class=hljs-keyword>unsafe</span> { free.<span class="hljs-title function_ invoke__">get_unchecked_mut</span>(<span class="hljs-title function_ invoke__">mix</span>(approx, displacement) <span class=hljs-keyword>as</span> <span class=hljs-type>usize</span>) } = <span class=hljs-literal>false</span>;
        }
    }

    <span class="hljs-title function_ invoke__">Some</span>(Phf {
        hash_space: hash_space <span class=hljs-keyword>as</span> <span class=hljs-type>u32</span>,
        bucket_shift,
        displacements,
    })
}
</div><label for=expansible2>Expand</label></div></code></pre><p>This code works, but takes around <eq><math><mn>280</mn></math></eq> ns per key. We can do better.<h2>Faster bucket logic</h2><p class=next-group><span aria-level=3 class=side-header role=heading><span>Allocations & cache</span></span>There’s two obvious problems with this code.<p>One problem is that <code>keys_per_bucket</code> is a two-dimensional array containing <eq><math><mi>B</mi></math></eq> vectors. Most of these vectors are non-empty, and calling <code>malloc</code> approximately <eq><math><mi>B</mi></math></eq> times is really slow. Even if we reduce this to one allocation, we’re still going to jump all over the memory, polluting the cache.<p>To fix both of these, we need to find another approach. Most cache-oblivious algorithms use the same old trick: sorting data with a cache-friendly algorithm and reading it in order is faster than reading it out of order. So we’re going to sort the keys by bucket, <code>group_by</code> the result into buckets, and then split this sequence into per-size bucket lists.<pre><code class=language-rust><div class=expansible-code><input id=expansible3 type=checkbox><div class=highlighted><span class=hljs-comment>// Sort keys by bucket using a cache-friendly algorithm</span>
<span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>sorted_by_bucket</span> = keys.<span class="hljs-title function_ invoke__">to_vec</span>();
radsort::<span class="hljs-title function_ invoke__">sort_by_key</span>(&<span class=hljs-keyword>mut</span> sorted_by_bucket, |key| <span class="hljs-title function_ invoke__">key_to_bucket</span>(*key));

<span class=hljs-comment>// We'll store per-size bucket lists here</span>
<span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>buckets_by_size</span>: <span class=hljs-type>Vec</span><<span class=hljs-type>Vec</span><(<span class=hljs-type>u32</span>, <span class=hljs-type>usize</span>)>> = <span class=hljs-type>Vec</span>::<span class="hljs-title function_ invoke__">new</span>();

<span class=hljs-comment>// A manual group_by implementation</span>
<span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>left</span> = <span class=hljs-number>0</span>;
<span class=hljs-keyword>while</span> left < keys.<span class="hljs-title function_ invoke__">len</span>() {
    <span class=hljs-keyword>let</span> <span class=hljs-variable>bucket</span> = <span class="hljs-title function_ invoke__">key_to_bucket</span>(sorted_by_bucket[left]);

    <span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>right</span> = left;
    <span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>product</span>;
    <span class=hljs-keyword>while</span> right < keys.<span class="hljs-title function_ invoke__">len</span>() && {
        <span class=hljs-comment>// Keep going while the key has the same bucket as the previous one</span>
        product = sorted_by_bucket[right] <span class=hljs-keyword>as</span> <span class=hljs-type>u64</span> * hash_space <span class=hljs-keyword>as</span> <span class=hljs-type>u64</span>;
        bucket == product <span class=hljs-keyword>as</span> <span class=hljs-type>u32</span> >> bucket_shift
    } {
        <span class=hljs-comment>// Replace the key with its Approx value in-place for future use. We have already computed</span>
        <span class=hljs-comment>// the product, so this is cheap.</span>
        sorted_by_bucket[right] = (product >> <span class=hljs-number>32</span>) <span class=hljs-keyword>as</span> <span class=hljs-type>u32</span>;
        right += <span class=hljs-number>1</span>;
    }
    left = right;

    <span class=hljs-comment>// Add bucket to its per-size list</span>
    <span class=hljs-keyword>let</span> <span class=hljs-variable>size</span> = right - left;
    <span class=hljs-keyword>if</span> buckets_by_size.<span class="hljs-title function_ invoke__">len</span>() <= size {
        buckets_by_size.<span class="hljs-title function_ invoke__">resize</span>(size + <span class=hljs-number>1</span>, <span class=hljs-type>Vec</span>::<span class="hljs-title function_ invoke__">new</span>());
    }
    buckets_by_size[size].<span class="hljs-title function_ invoke__">push</span>((bucket, left));
}
</div><label for=expansible3>Expand</label></div></code></pre><p>Iterating over the buckets is then as simple as:<pre><code class=language-rust><span class=hljs-keyword>for</span> (size, buckets) <span class=hljs-keyword>in</span> buckets_by_size.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">enumerate</span>().<span class="hljs-title function_ invoke__">rev</span>() {
    <span class=hljs-keyword>for</span> &(bucket, start) <span class=hljs-keyword>in</span> buckets {
        <span class=hljs-keyword>let</span> <span class=hljs-variable>approx_for_bucket</span> = &<span class=hljs-keyword>mut</span> sorted_by_bucket[start..start + size];
        ...
    }
}
</code></pre><p>This alone increases performance almost twofold, to <eq><math><mn>145</mn></math></eq> ns per key. <code>radsort</code> is not the best radix sort implementation, but it’s the only ready one I found that supports stateful <code>sort_by_key</code>, so we’ll have to live with it unless someone wants to contribute to <a href=https://github.com/lakwet/voracious_sort>voracious_sort</a>.<p class=next-group><span aria-level=3 class=side-header role=heading><span>Displacements (XOR)</span></span>The second problem is this quadratic loop:<pre><code class=language-rust><span class=hljs-comment>// Find non-colliding displacement. On failure, return None.</span>
<span class=hljs-keyword>let</span> <span class=hljs-variable>displacement</span> = (<span class=hljs-number>0</span>..=<span class=hljs-type>u16</span>::MAX).<span class="hljs-title function_ invoke__">find</span>(|displacement| {
    approx_for_bucket.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">all</span>(|approx| *<span class=hljs-keyword>unsafe</span> {
        free.<span class="hljs-title function_ invoke__">get_unchecked</span>(<span class="hljs-title function_ invoke__">mix</span>(*approx, *displacement) <span class=hljs-keyword>as</span> <span class=hljs-type>usize</span>)
    })
})?;
</code></pre><p>The average displacement is quite large, so the outer loop can perform quite a few iterations. Meanwhile, the inner loop iterates through a small subset of indices all across the memory, which doesn’t even always fit in L2.<p>Luckily, this is easy to fix by simultaneously computing the predicate for <em>multiple</em> values of <code>displacement</code>, as if by unrolling the loop. But hey, <eq><math><mrow><mrow><mi>A</mi><mi>p</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>x</mi></mrow><mo>⊕︎</mo></mrow><mrow><mn>0</mn><mo separator=true>,</mo></mrow><mrow><mo>…</mo></mrow><mrow><mo separator=true>,</mo></mrow><mrow><mrow><mi>A</mi><mi>p</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>x</mi></mrow><mo>⊕︎</mo></mrow><mrow><mn>7</mn></mrow></math></eq> exactly covers an 8-aligned slice of <code>free</code>, which means <code>free</code> can cheaply be turned into a bitset!<p>Well… sort of. It <em>looks</em> like it should be as simple as<pre><code class=language-rust><div class=expansible-code><input id=expansible4 type=checkbox><div class=highlighted><span class=hljs-comment>// SAFETY: `free` must be a bitset large enough to fit `approx ^ displacement`.</span>
<span class=hljs-keyword>unsafe</span> <span class=hljs-keyword>fn</span> <span class="hljs-title function_">find_valid_displacement</span>(approx_for_bucket: &[<span class=hljs-type>u32</span>], free: &[<span class=hljs-type>u8</span>]) <span class=hljs-punctuation>-></span> <span class=hljs-type>Option</span><<span class=hljs-type>u16</span>> {
    <span class=hljs-comment>// Outer unrolled loop</span>
    <span class=hljs-keyword>for</span> <span class=hljs-variable>displacement_base</span> <span class=hljs-keyword>in</span> (<span class=hljs-number>0</span>..=<span class=hljs-type>u16</span>::MAX).<span class="hljs-title function_ invoke__">step_by</span>(<span class=hljs-number>8</span>) {
        <span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>global_bit_mask</span> = <span class=hljs-type>u8</span>::MAX;

        <span class=hljs-comment>// Iterate over keys</span>
        <span class=hljs-keyword>for</span> <span class=hljs-variable>approx</span> <span class=hljs-keyword>in</span> approx_for_bucket {
            <span class=hljs-keyword>let</span> <span class=hljs-variable>approx</span> = *approx <span class=hljs-keyword>as</span> <span class=hljs-type>usize</span>;
            <span class=hljs-comment>// Inner unrolled loop, aka bitmask logic</span>
            <span class=hljs-keyword>let</span> <span class=hljs-variable>bit_mask</span> =
                *<span class=hljs-keyword>unsafe</span> { free.<span class="hljs-title function_ invoke__">get_unchecked</span>((approx ^ displacement_base <span class=hljs-keyword>as</span> <span class=hljs-type>usize</span>) / <span class=hljs-number>8</span>) };
            global_bit_mask &= bit_mask <span class=hljs-keyword>as</span> <span class=hljs-type>usize</span>;
        }

        <span class=hljs-comment>// Find the first applicable displacement (i.e. such that all `free` values are 1)</span>
        <span class=hljs-keyword>if</span> global_bit_mask != <span class=hljs-number>0</span> {
            <span class=hljs-keyword>let</span> <span class=hljs-variable>displacement_offset</span> = global_bit_mask.<span class="hljs-title function_ invoke__">trailing_zeros</span>() <span class=hljs-keyword>as</span> <span class=hljs-type>u16</span>;
            <span class=hljs-keyword>return</span> <span class="hljs-title function_ invoke__">Some</span>(displacement_base + displacement_offset);
        }
    }

    <span class=hljs-literal>None</span>
}
</div><label for=expansible4>Expand</label></div></code></pre><p>But that’s actually wrong. We <em>want</em> to SIMDify the computation of<ul><li><code>free[approx[0] ^ 0] && free[approx[1] ^ 0] && free[approx[2] ^ 0] && ...</code><li><code>free[approx[0] ^ 1] && free[approx[1] ^ 1] && free[approx[2] ^ 1] && ...</code><li>…<li><code>free[approx[0] ^ 7] && free[approx[1] ^ 7] && free[approx[2] ^ 7] && ...</code></ul><p>Which we rewrite as<ul><li><code>free[approx[0] / 8][(approx[0] & 7) ^ 0] && ...</code><li><code>free[approx[0] / 8][(approx[0] & 7) ^ 1] && ...</code><li>…<li><code>free[approx[0] / 8][(approx[0] & 7) ^ 7] && ...</code></ul><p>But note that the bit index <eq><math><mn>0</mn></math></eq> to <eq><math><mn>7</mn></math></eq> needs to be XORed with <code>approx</code>, while in our code, we just directly access bits <eq><math><mn>0</mn></math></eq> to <eq><math><mn>7</mn></math></eq> without consideration for the low three bits of <code>approx</code>. If we want this scheme to work, we need to <em>shuffle bits inside a byte</em> by XORing <em>the bit index</em> (rather than the bits themselves) with <code>approx & 7</code>:<ul><li>If <code>approx & 7 == 0</code>, the shuffle order is <eq><math><mrow><mn>01234567</mn><mo>→</mo></mrow><mrow><mn>01234567</mn></mrow></math></eq>.<li>If <code>approx & 7 == 1</code>, the shuffle order is <eq><math><mrow><mn>01234567</mn><mo>→</mo></mrow><mrow><mn>10325476</mn></mrow></math></eq>.<li>If <code>approx & 7 == 2</code>, the shuffle order is <eq><math><mrow><mn>01234567</mn><mo>→</mo></mrow><mrow><mn>23016745</mn></mrow></math></eq>.<li>If <code>approx & 7 == 3</code>, the shuffle order is <eq><math><mrow><mn>01234567</mn><mo>→</mo></mrow><mrow><mn>32107654</mn></mrow></math></eq>.<li>…<li>If <code>approx & 7 == 7</code>, the shuffle order is <eq><math><mrow><mn>01234567</mn><mo>→</mo></mrow><mrow><mn>76543210</mn></mrow></math></eq>.</ul><p>You get the idea. The most performant way to compute this is with a LUT:<pre><code class=language-rust><div class=expansible-code><input id=expansible5 type=checkbox><div class=highlighted><span class=hljs-keyword>const</span> BIT_INDEX_XOR_LUT: [[<span class=hljs-type>u8</span>; <span class=hljs-number>256</span>]; <span class=hljs-number>8</span>] = {
    <span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>lut</span> = [[<span class=hljs-number>0</span>; <span class=hljs-number>256</span>]; <span class=hljs-number>8</span>];
    <span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>xor</span> = <span class=hljs-number>0</span>;
    <span class=hljs-comment>// For loops are unsupported in const, smh my head</span>
    <span class=hljs-keyword>while</span> xor < <span class=hljs-number>8</span> {
        <span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>bit_mask</span> = <span class=hljs-number>0</span>;
        <span class=hljs-keyword>while</span> bit_mask < <span class=hljs-number>256</span> {
            <span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>bit_index</span> = <span class=hljs-number>0</span>;
            <span class=hljs-keyword>while</span> bit_index < <span class=hljs-number>8</span> {
                lut[xor][bit_mask] |= ((bit_mask <span class=hljs-keyword>as</span> <span class=hljs-type>u8</span> >> bit_index) & <span class=hljs-number>1</span>) << (bit_index ^ xor);
                bit_index += <span class=hljs-number>1</span>;
            }
            bit_mask += <span class=hljs-number>1</span>;
        }
        xor += <span class=hljs-number>1</span>;
    }
    lut
};

global_bit_mask |= BIT_INDEX_XOR_LUT[approx % <span class=hljs-number>8</span>][bit_mask <span class=hljs-keyword>as</span> <span class=hljs-type>usize</span>];
</div><label for=expansible5>Expand</label></div></code></pre><p>This brings build time down to <eq><math><mn>65</mn></math></eq> ns per key, more than <eq><math><mrow><mn>2</mn><mo>×</mo></mrow></math></eq> faster than before.<p>Unfortunately, increasing this performance further is a lot harder. Increasing the step to 16 bits would either require a 2 MiB LUT, which is not really a good idea for many reasons, or introduce conditionals into the <code>global_bit_mask |= ...</code> calculation – hardly a positive change.<p class=next-group><span aria-level=3 class=side-header role=heading><span>Displacements (+)</span></span>Okay, that was it for <eq><math><mo lspace=0em rspace=0em>⊕︎</mo></math></eq>. What about <eq><math><mo lspace=0em rspace=0em>+</mo></math></eq>?<p>We’re in luck: bits <eq><math><mrow><mrow><mi>A</mi><mi>p</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>x</mi></mrow><mo>+</mo></mrow><mrow><mn>0</mn></mrow></math></eq> to <eq><math><mrow><mrow><mi>A</mi><mi>p</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>x</mi></mrow><mo>+</mo></mrow><mrow><mn>7</mn></mrow></math></eq> can be extracted simply by performing an unaligned 16-bit read, followed by a bit shift. But we don’t have to limit ourselves to validating <eq><math><mn>8</mn></math></eq> displacements at once: we can easily validate <eq><math><mn>57</mn></math></eq> displacements at once!<pre><code class=language-rust><div class=expansible-code><input id=expansible6 type=checkbox><div class=highlighted><span class=hljs-comment>// SAFETY: `free` must be large enough to fit `approx + displacement + 8`.</span>
<span class=hljs-keyword>unsafe</span> <span class=hljs-keyword>fn</span> <span class="hljs-title function_">find_valid_displacement</span>(approx_for_bucket: &[<span class=hljs-type>u32</span>], free: &[<span class=hljs-type>u8</span>]) <span class=hljs-punctuation>-></span> <span class=hljs-type>Option</span><<span class=hljs-type>u16</span>> {
    <span class=hljs-comment>// Outer unrolled loop</span>
    <span class=hljs-keyword>for</span> <span class=hljs-variable>displacement_base_index</span> <span class=hljs-keyword>in</span> <span class=hljs-number>0</span>..<span class=hljs-type>u16</span>::MAX / <span class=hljs-number>57</span> {
        <span class=hljs-comment>// We don't iterate through a few of the top 65536 displacements, but that's noise</span>
        <span class=hljs-keyword>let</span> <span class=hljs-variable>displacement_base</span> = displacement_base_index * <span class=hljs-number>57</span>;

        <span class=hljs-comment>// Can't trust bits farther than the first 57, because we shift out up to 7 bits, shifting</span>
        <span class=hljs-comment>// in meaningless zeros</span>
        <span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>global_bit_mask</span> = (<span class=hljs-number>1</span> << <span class=hljs-number>57</span>) - <span class=hljs-number>1</span>;

        <span class=hljs-comment>// Iterate over keys</span>
        <span class=hljs-keyword>for</span> <span class=hljs-variable>approx</span> <span class=hljs-keyword>in</span> approx_for_bucket {
            <span class=hljs-comment>// Inner unrolled loop, aka bitmask logic</span>
            <span class=hljs-keyword>let</span> <span class=hljs-variable>start</span> = *approx <span class=hljs-keyword>as</span> <span class=hljs-type>usize</span> + displacement_base <span class=hljs-keyword>as</span> <span class=hljs-type>usize</span>;
            <span class=hljs-keyword>let</span> <span class=hljs-variable>bit_mask</span> = <span class=hljs-keyword>unsafe</span> { free.<span class="hljs-title function_ invoke__">as_ptr</span>().<span class="hljs-title function_ invoke__">add</span>(start / <span class=hljs-number>8</span>).cast::<<span class=hljs-type>u64</span>>().<span class="hljs-title function_ invoke__">read_unaligned</span>() }
                >> (start % <span class=hljs-number>8</span>);
            global_bit_mask &= bit_mask;
        }

        <span class=hljs-keyword>if</span> global_bit_mask != <span class=hljs-number>0</span> {
            <span class=hljs-keyword>let</span> <span class=hljs-variable>displacement_offset</span> = global_bit_mask.<span class="hljs-title function_ invoke__">trailing_zeros</span>() <span class=hljs-keyword>as</span> <span class=hljs-type>u16</span>;
            <span class=hljs-keyword>return</span> <span class="hljs-title function_ invoke__">Some</span>(displacement_base + displacement_offset);
        }
    }

    <span class=hljs-literal>None</span>
}
</div><label for=expansible6>Expand</label></div></code></pre><p>This increases performance to <eq><math><mn>40</mn></math></eq> ns per key.</div></section><footer><div class=viewport-container><h2>Made with my own bare hands (why.)</h2></div></footer><script>window.addEventListener("keydown", e => {
				if (e.key === "Enter") {
					if (e.ctrlKey) {
						window.open("https://github.com/purplesyringa/site/edit/master/blog/designing-worlds-fastest-perfect-hash/index.md", "_blank");
					} else if (
						e.target.type === "checkbox"
						&& e.target.parentNode
						&& e.target.parentNode.className === "expansible-code"
					) {
						e.target.click();
					}
				}
			});</script>