<!doctypehtml><html prefix="og: http://ogp.me/ns#"lang=en_US><meta charset=utf-8><meta content=width=device-width,initial-scale=1 name=viewport><title>Finding duplicated code with tools from your CS course | purplesyringa's blog</title><link href=../../favicon.ico?v=2 rel=icon><link href=../../all.css rel=stylesheet><link href=../../blog.css rel=stylesheet><link href=../../vendor/Temml-Local.css rel=stylesheet><link crossorigin href=https://fonts.googleapis.com/css2?family=Noto+Sans:ital,wght@0,100..900;1,100..900&family=Roboto+Mono:ital,wght@0,100..700;1,100..700&family=Roboto:ital,wght@0,400;0,700;1,400;1,700&family=Slabo+27px&display=swap rel=stylesheet><link href=../../fonts/webfont.css rel=stylesheet><link media="screen and (prefers-color-scheme: dark"href=../../vendor/atom-one-dark.min.css rel=stylesheet><link media="screen and (prefers-color-scheme: light"href=../../vendor/a11y-light.min.css rel=stylesheet><link title="Blog posts"href=../../blog/feed.rss rel=alternate type=application/rss+xml><meta content="Finding duplicated code with tools from your CS course"property=og:title><meta content=article property=og:type><meta content=https://purplesyringa.moe/blog/finding-duplicated-code-with-tools-from-your-cs-course/og.png property=og:image><meta content=https://purplesyringa.moe/blog/finding-duplicated-code-with-tools-from-your-cs-course/ property=og:url><meta content='Suppose that you‚Äôre writing a static analyzer and you want to write a diagnostic for match arms with equal bodies:
match number {
1 => { // <--</span>
let x = 1;
f(x)
}
2 => f(g(h())),
3 => "",
4 => { // <--</span>
let x = 1;
f(x)
}
_ => unreachable!(),
}'property=og:description><meta content=en_US property=og:locale><meta content="purplesyringa's blog"property=og:site_name><meta content=summary_large_image name=twitter:card><meta content=https://purplesyringa.moe/blog/finding-duplicated-code-with-tools-from-your-cs-course/og.png name=twitter:image><script data-website-id=0da1961d-43f2-45cc-a8e2-75679eefbb69 defer src=https://zond.tei.su/script.js></script><body><header><div class=viewport-container><div class=media><a href=https://github.com/purplesyringa><img alt=GitHub src=../../images/github-mark-white.svg></a></div><h1><a href=/>purplesyringa</a></h1><nav><a href=../..>about</a><a class=current href=../../blog/>blog</a><a href=../../sink/>kitchen sink</a></nav></div></header><section><div class=viewport-container><h2>Finding duplicated code with tools from your CS course</h2><time>November 17, 2025</time><p>Suppose that you‚Äôre writing a static analyzer and you want to write a diagnostic for <code>match</code> arms with equal bodies:<pre><code class=language-rust><span class=hljs-keyword>match</span> number {
    <span class=hljs-number>1</span> => { <span class=hljs-comment>// &LT--</span>
        <span class=hljs-keyword>let</span> <span class=hljs-variable>x</span> = <span class=hljs-number>1</span>;
        <span class="hljs-title function_ invoke__">f</span>(x)
    }
    <span class=hljs-number>2</span> => <span class="hljs-title function_ invoke__">f</span>(<span class="hljs-title function_ invoke__">g</span>(<span class="hljs-title function_ invoke__">h</span>())),
    <span class=hljs-number>3</span> => <span class=hljs-string>""</span>,
    <span class=hljs-number>4</span> => { <span class=hljs-comment>// &LT--</span>
        <span class=hljs-keyword>let</span> <span class=hljs-variable>x</span> = <span class=hljs-number>1</span>;
        <span class="hljs-title function_ invoke__">f</span>(x)
    }
    _ => <span class=hljs-built_in>unreachable!</span>(),
}
</code></pre><p>Well, that looks simple enough: serialize each arm into a string and throw the strings into a hash map. Then someone renames a variable:<pre><code class=language-rust><span class=hljs-keyword>match</span> number {
    <span class=hljs-number>1</span> => { <span class=hljs-comment>// &LT--</span>
        <span class=hljs-keyword>let</span> <span class=hljs-variable>x</span> = <span class=hljs-number>1</span>;
        <span class="hljs-title function_ invoke__">f</span>(x)
    }
    <span class=hljs-number>2</span> => <span class="hljs-title function_ invoke__">f</span>(<span class="hljs-title function_ invoke__">g</span>(<span class="hljs-title function_ invoke__">h</span>())),
    <span class=hljs-number>3</span> => <span class=hljs-string>""</span>,
    <span class=hljs-number>4</span> => { <span class=hljs-comment>// &LT--</span>
        <span class=hljs-keyword>let</span> <span class=hljs-variable>y</span> = <span class=hljs-number>1</span>;
        <span class="hljs-title function_ invoke__">f</span>(y)
    }
    _ => <span class=hljs-built_in>unreachable!</span>(),
}
</code></pre><p>Now the strings no longer match, but the arms are still clearly equivalent. Scary! It‚Äôs not immediately obvious how to handle this correctly, let alone efficiently.<p>It turns out that this problem has interesting connections to the theory of computation and algebra. This is what this post is about: how odd tricks come together to tackle this challenge.<p class=next-group><span aria-level=3 class=side-header role=heading><span>Problem</span></span>We‚Äôll limit ourselves to syntactic analysis: snippets are considered equivalent if they match exactly, up to variable names. A smarter algorithm would realize that <eq><math><mrow><mn>2</mn><mo>+</mo></mrow><mrow><mn>2</mn></mrow></math></eq> and <eq><math><mn>4</mn></math></eq> are identical, but that‚Äôs tricky in the general case (are <code>a + b</code> and <code>b + a</code> equivalent? what if it‚Äôs an overloaded operator?), so we‚Äôll focus on something more rigid. There‚Äôs still plenty to talk about.<p>We can‚Äôt just ignore all variable names, since that‚Äôs going to trigger false positives. But as we‚Äôve just seen, we can‚Äôt use them directly either.<p>One possibility is to abolish hash tables. Looking at two arms individually, we can record the correspondence between variables declared in one arm and the other, and then validate that all variable accesses match that correspondence:<div class=table-wrapper><table><thead><tr><th>Snippet A<th>Snippet B<th>Correspondence<tbody><tr><td><code>let x = 1;</code> (defines¬†<code>x</code>)<td><code>let y = 1;</code> (defines¬†<code>y</code>)<td><code>x</code> maps to <code>y</code><tr><td><code>f(x)</code> (uses¬†<code>x</code>)<td><code>f(y)</code> (uses¬†<code>y</code>)<td>consistent</table></div><p>But that means that in a situation with, say, 20 arms, which is <em>exactly</em> the kind of situation where this diagnostic would be useful to catch copy-paste errors, we‚Äôre going to need 200-ish comparisons to verify that all arms are unique. That‚Äôs quite slow, even for a static analyzer. So how can we integrate this idea into the original hash table-based approach?<p>Luckily, we‚Äôre not alone in our struggles. We don‚Äôt have to solve this problem ourselves ‚Äì or, at least, this specific variation ‚Äì because that‚Äôs already been done ages ago. The notion we‚Äôve been struggling to formulate is called <eq><math><mi>Œ±</mi></math></eq>-equivalence. The only issue is that it‚Äôs defined outside of ‚Äútypical‚Äù programming. So I have two options:<ul><li>I can show you an ad-hoc solution that works only for this problem and is ultimately a dead end, or<li>I can take you back through time and teach you something new.</ul><p>Let‚Äôs take a detour, shall we?<p class=next-group><span aria-level=3 class=side-header role=heading><span>Side quest</span></span>Back at the dawn of computation, when people like Alan Turing were only starting their research, it was not yet clear what the word ‚Äúcomputation‚Äù was even supposed to mean.<p>Almost every system to date, including set theory and natural numbers, was based on techniques that were unusable for formalizing computation. Mathematicians often use first-order logic quantifiers like <eq><math><mi>‚àÉ</mi></math></eq> (‚Äúthere exists a value ‚Ä¶ such that ‚Ä¶‚Äù) and <eq><math><mi>‚àÄ</mi></math></eq> (‚Äúfor all values of ‚Ä¶, the following holds‚Äù). However, the fact that an object exists does not necessarily mean that it‚Äôs easy to find. Similarly, a proof branching on a condition cannot be translated to an algorithm if that condition cannot be determined efficiently. <eq><math><mrow><mi>‚àÉ</mi><mi>a</mi><mo separator=true>,</mo></mrow><mrow><mi>b</mi><mo separator=true>,</mo></mrow><mrow><mi>c</mi><mo separator=true>,</mo></mrow><mrow><mi>n</mi><mo>></mo></mrow><mrow><mn>2</mn><mo lspace=0.2222em rspace=0.2222em>:</mo></mrow><mrow><msup><mi>a</mi><mi>n</mi></msup><mo>+</mo></mrow><mrow><msup><mi>b</mi><mi>n</mi></msup><mo>=</mo></mrow><mrow><msup><mi>c</mi><mi>n</mi></msup></mrow></math></eq> can only be either ‚Äútrue‚Äù or ‚Äúfalse‚Äù, but a program cannot determine that.<p>So someone had to introduce a new framework: a model of a real-world computer that could be studied in isolation. One of such models was the <a href=https://en.wikipedia.org/wiki/Turing_machine>Turing machine</a>, which you‚Äôve likely already heard about. But it wasn‚Äôt the only one. Another candidate, distinct but equal in computational power, was <a href=https://en.wikipedia.org/wiki/Lambda_calculus>lambda calculus</a>.<p>If Turing machine is an esoteric imperative language, <eq><math><mi>Œª</mi></math></eq>-calculus is a functional one. Just like the Turing machine, it‚Äôs not supposed to be used directly, but rather acts as a substitute for complex real-world languages during research. And research it we did: thank <eq><math><mi>Œª</mi></math></eq>-calculus for advances in language design, type inference, and formal verification.<p>So why do we care about <eq><math><mi>Œª</mi></math></eq>-calculus while studying a lint for an imperative language? A core property of functional languages is that they enable local reasoning. While a mutating operation in an imperative language can potentially affect state at any later point, expressions in functional languages are pure, depend exclusively on their inputs, and don‚Äôt ‚Äúleak‚Äù anything but their return value. If you‚Äôre starting to figure out how this locality helps, good; otherwise, I‚Äôll answer this explicitly in a bit.<p class=next-group><span aria-level=3 class=side-header role=heading><span><eq><math><mi>Œª</mi></math></eq>-calculus</span></span>So what <em>is</em> <eq><math><mi>Œª</mi></math></eq>-calculus? It‚Äôs a language that allows you to create anonymous functions and invoke functions, and do nothing else. To create functions, you use what other languages often call lambda functions. Python says <code>lambda x: ...</code>, C++ says <code>[](auto x) { ... }</code>, and <eq><math><mi>Œª</mi></math></eq>-calculus says <eq><math><mrow><mi>Œª</mi><mi>x</mi><mi>.</mi><mo>‚Ä¶</mo></mrow></math></eq>. To invoke functions, you write the name of the function followed by its arguments: <eq><math><mrow><mi>f</mi><mspace width=0.1667em></mspace><mi>a</mi></mrow></math></eq>. Obviously, arguments are functions too.<p>It may seem surprising that this mechanism is powerful enough to implement <em>anything</em>, given that the only type we have is ‚Äúfunction‚Äù, and the only way to create named objects is to capture them as function arguments. That‚Äôs right ‚Äì you can‚Äôt even define globals here!<p>I‚Äôm not going to teach you <eq><math><mi>Œª</mi></math></eq>-calculus today, but I‚Äôll show two examples so that you aren‚Äôt completely blindsided. Here‚Äôs how booleans are typically defined:<section><eqn><math style="display:block math;"class=tml-display display=block><mtable columnalign=right displaystyle=true><mtr><mtd style="padding:0.7ex 0em 0.7ex 0em;"class=tml-right><mrow><mtext>true</mtext><mo lspace=0.2222em rspace=0em>:</mo><mo lspace=0em>=</mo><mi>Œª</mi><mi>x</mi><mi>.</mi><mo form=prefix stretchy=false>(</mo><mi>Œª</mi><mi>y</mi><mi>.</mi><mi>x</mi><mo form=postfix stretchy=false>)</mo></mrow></mtd></mtr><mtr><mtd style="padding:0.7ex 0em 0.7ex 0em;"class=tml-right><mrow><mtext>false</mtext><mo lspace=0.2222em rspace=0em>:</mo><mo lspace=0em>=</mo><mi>Œª</mi><mi>x</mi><mi>.</mi><mo form=prefix stretchy=false>(</mo><mi>Œª</mi><mi>y</mi><mi>.</mi><mi>y</mi><mo form=postfix stretchy=false>)</mo></mrow></mtd></mtr></mtable></math></eqn></section><p>Note that <eq><math><mi>Œª</mi></math></eq>-calculus only supports single-argument functions: to simulate more arguments, you <a href=https://en.wikipedia.org/wiki/Currying>define internal functions</a> capturing the outside context. Now, if you have a boolean <eq><math><mi>b</mi></math></eq> and you want to get the number <eq><math><mn>5</mn></math></eq> if it‚Äôs <code>true</code> and <eq><math><mn>8</mn></math></eq> if it‚Äôs <code>false</code>, you can write <eq><math><mrow><mo form=prefix stretchy=false>(</mo><mi>b</mi><mspace width=0.1667em></mspace><mn>5</mn><mo form=postfix stretchy=false>)</mo><mspace width=0.1667em></mspace><mn>8</mn></mrow></math></eq>. For example, if <eq><math><mi>b</mi></math></eq> is equal to <code>true</code>, this will evaluate to:<section><eqn><math style="display:block math;"class=tml-display display=block><mrow><mo form=prefix stretchy=false>(</mo><mo form=prefix stretchy=false>(</mo><mi>Œª</mi><mi>x</mi><mi>.</mi><mo form=prefix stretchy=false>(</mo><mi>Œª</mi><mi>y</mi><mi>.</mi><mi>x</mi><mo form=postfix stretchy=false>)</mo><mo form=postfix stretchy=false>)</mo><mspace width=0.1667em></mspace><mn>5</mn><mo form=postfix stretchy=false>)</mo><mspace width=0.1667em></mspace><mn>8</mn><mo>=</mo><mo form=prefix stretchy=false>(</mo><mi>Œª</mi><mi>y</mi><mi>.</mi><mn>5</mn><mo form=postfix stretchy=false>)</mo><mspace width=0.1667em></mspace><mn>8</mn><mo>=</mo><mn>5</mn><mi>.</mi></mrow></math></eqn></section><p>In effect, programs in <eq><math><mi>Œª</mi></math></eq>-calculus encode data into the control flow of functions: it‚Äôs common for a function to take both ‚Äúreal‚Äù arguments and ‚Äúcallbacks‚Äù, which are either selected or combined depending on what the function wants to return. You can use this trick to implement pairs as functions that pass their contents as two arguments to the callback:<section><eqn><math style="display:block math;"class=tml-display display=block><mrow><mo form=prefix stretchy=false>(</mo><mi>x</mi><mo separator=true>,</mo><mi>y</mi><mo form=postfix stretchy=false>)</mo><mo lspace=0.2222em rspace=0em>:</mo><mo lspace=0em>=</mo><mi>Œª</mi><mi>f</mi><mi>.</mi><mo form=prefix stretchy=false>(</mo><mo form=prefix stretchy=false>(</mo><mi>f</mi><mspace width=0.1667em></mspace><mi>x</mi><mo form=postfix stretchy=false>)</mo><mi>y</mi><mo form=postfix stretchy=false>)</mo><mi>.</mi></mrow></math></eqn></section><p>With makeshift ternaries, you can implement boolean logic (e.g. <code>a && b</code> is <code>a ? b : false</code>), and with pairs, you can implement linked lists. That gives you numbers, arrays, and all finite computation. Loops and recursion are also <a href=https://en.wikipedia.org/wiki/Fixed-point_combinator>possible to implement</a>, but ultimately offtopic for this article, so I‚Äôll wrap this up for now.<p class=next-group><span aria-level=3 class=side-header role=heading><span>Representations</span></span>Only being able to ‚Äúdeclare‚Äù a variable by defining a function is restrictive, but on the flip side, it simplfies code analysis.<p>Since a variable can only be accessed within the <eq><math><mi>Œª</mi></math></eq>-function that declares it, each variable access can be identified with the nesting level of the corresponding definition. For example, in <eq><math><mrow><mi>Œª</mi><mi>x</mi><mi>.</mi><mo form=prefix stretchy=false>(</mo><mi>Œª</mi><mi>y</mi><mi>.</mi><mi>y</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq>, the access <eq><math><mi>y</mi></math></eq> corresponds to the most nested definition visible at the time of access, so we‚Äôll write that as <eq><math><mrow style="padding:0 0 0.1em 0;border-bottom:0.065em solid;"><mn>1</mn></mrow></math></eq>. For <eq><math><mrow><mi>Œª</mi><mi>x</mi><mi>.</mi><mo form=prefix stretchy=false>(</mo><mi>Œª</mi><mi>y</mi><mi>.</mi><mi>x</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq>, it would be <eq><math><mrow style="padding:0 0 0.1em 0;border-bottom:0.065em solid;"><mn>2</mn></mrow></math></eq>, and so on. These numbers are called <a href=https://en.wikipedia.org/wiki/De_Bruijn_index>de Bruijn indices</a>, and they‚Äôre sufficient to resolve variables without ever mentioning their names.<p>Any <eq><math><mi>Œª</mi></math></eq>-calculus program can be rewritten to this format. For example:<section><eqn><math style="display:block math;"class=tml-display display=block><mtable displaystyle=true><mtr><mtd style="padding:0.7ex 0em 0.7ex 0em;"><mrow><mi>Œª</mi><mi>f</mi><mi>.</mi><mo form=prefix stretchy=false>(</mo><mi>Œª</mi><mi>x</mi><mi>.</mi><mi>f</mi><mo form=prefix stretchy=false>(</mo><mi>x</mi><mspace width=0.1667em></mspace><mi>x</mi><mo form=postfix stretchy=false>)</mo><mo form=postfix stretchy=false>)</mo><mo form=prefix stretchy=false>(</mo><mi>Œª</mi><mi>x</mi><mi>.</mi><mi>f</mi><mo form=prefix stretchy=false>(</mo><mi>x</mi><mspace width=0.1667em></mspace><mi>x</mi><mo form=postfix stretchy=false>)</mo><mo form=postfix stretchy=false>)</mo></mrow></mtd></mtr><mtr><mtd style="padding:0.7ex 0em 0.7ex 0em;"><mo stretchy=false>‚áì</mo></mtd></mtr><mtr><mtd style="padding:0.7ex 0em 0.7ex 0em;"><mrow><mi>Œª</mi><mi>.</mi><mo form=prefix stretchy=false>(</mo><mi>Œª</mi><mi>.</mi><mrow style="padding:0 0 0.1em 0;border-bottom:0.065em solid;"><mn>2</mn></mrow><mo form=prefix stretchy=false>(</mo><mrow style="padding:0 0 0.1em 0;border-bottom:0.065em solid;"><mn>1</mn></mrow><mspace width=0.1667em></mspace><mrow style="padding:0 0 0.1em 0;border-bottom:0.065em solid;"><mn>1</mn></mrow><mo form=postfix stretchy=false>)</mo><mo form=postfix stretchy=false>)</mo><mo form=prefix stretchy=false>(</mo><mi>Œª</mi><mi>.</mi><mrow style="padding:0 0 0.1em 0;border-bottom:0.065em solid;"><mn>2</mn></mrow><mo form=prefix stretchy=false>(</mo><mrow style="padding:0 0 0.1em 0;border-bottom:0.065em solid;"><mn>1</mn></mrow><mspace width=0.1667em></mspace><mrow style="padding:0 0 0.1em 0;border-bottom:0.065em solid;"><mn>1</mn></mrow><mo form=postfix stretchy=false>)</mo><mo form=postfix stretchy=false>)</mo></mrow></mtd></mtr></mtable></math></eqn></section><p>The variable names can be removed from the <eq><math><mi>Œª</mi></math></eq>-function definition, since they are now irrelevant. And that‚Äôs the superpower: the resulting expression is independent of variable names, but represents the same program, just in a different encoding. This means that such programs can be compared for equality straightforwardly without accounting for differences in names of locals. Yay!<p>Note that, with this scheme, the same variable can be seen with different indices from different scopes: <eq><math><mrow><mi>Œª</mi><mi>f</mi><mi>.</mi><mi>f</mi><mo form=prefix stretchy=false>(</mo><mi>Œª</mi><mi>x</mi><mi>.</mi><mi>f</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> is converted to <eq><math><mrow><mi>Œª</mi><mi>.</mi><mrow style="padding:0 0 0.1em 0;border-bottom:0.065em solid;"><mn>1</mn></mrow><mo form=prefix stretchy=false>(</mo><mi>Œª</mi><mi>.</mi><mrow style="padding:0 0 0.1em 0;border-bottom:0.065em solid;"><mn>2</mn></mrow><mo form=postfix stretchy=false>)</mo></mrow></math></eq>. Just keep that in mind for now and don‚Äôt let it trick you.<p>Of course, not all variables are local, i.e. defined within the snippet. For example, we can only rewrite <eq><math><mrow><mi>Œª</mi><mi>f</mi><mi>.</mi><mo form=prefix stretchy=false>(</mo><mi>f</mi><mspace width=0.1667em></mspace><mi>a</mi><mo form=postfix stretchy=false>)</mo><mspace width=0.1667em></mspace><mi>b</mi></mrow></math></eq> to <eq><math><mrow><mi>Œª</mi><mi>.</mi><mo form=prefix stretchy=false>(</mo><mrow style="padding:0 0 0.1em 0;border-bottom:0.065em solid;"><mn>1</mn></mrow><mspace width=0.1667em></mspace><mi>a</mi><mo form=postfix stretchy=false>)</mo><mspace width=0.1667em></mspace><mi>b</mi></mrow></math></eq>, leaving the names of the free (i.e. non-local) variables <eq><math><mi>a</mi></math></eq> and <eq><math><mi>b</mi></math></eq> intact. This mixed representation is called <em>locally nameless</em> for obvious reasons.<p class=next-group><span aria-level=3 class=side-header role=heading><span>Lint</span></span>Back to the original problem: writing a lint for repeating <code>match</code> arms. We don‚Äôt actually need to convert the imperative code to <eq><math><mi>Œª</mi></math></eq>-calculus, since it‚Äôs just a framework: we can extract the core ideas and attach them to the imperative IR. All we need is for each variable to have an associated definition scope, where each scope defines at most one variable. For example,<pre><code class=language-rust><span class=hljs-comment>// `a` is defined outside</span>
<span class=hljs-keyword>let</span> <span class=hljs-variable>x</span> = <span class=hljs-number>2</span> + <span class=hljs-number>2</span>;
<span class=hljs-keyword>let</span> <span class=hljs-variable>y</span> = <span class=hljs-string>"hello"</span>;
<span class=hljs-keyword>if</span> x == a {
    <span class=hljs-keyword>let</span> <span class=hljs-variable>z</span> = <span class=hljs-string>"world"</span>;
    <span class=hljs-built_in>println!</span>(<span class=hljs-string>"{y} {z}"</span>);
}
</code></pre><p>‚Ä¶could be interpreted as:<pre><code class=language-rust><span class=hljs-keyword>let</span> <span class=hljs-variable>x</span> {
    <span class=hljs-keyword>let</span> <span class=hljs-variable>y</span> {
        x = <span class=hljs-number>2</span> + <span class=hljs-number>2</span>;
        y = <span class=hljs-string>"hello"</span>;
        <span class=hljs-keyword>if</span> x == a {
            <span class=hljs-keyword>let</span> <span class=hljs-variable>z</span> {
                z = <span class=hljs-string>"world"</span>;
                <span class=hljs-built_in>println!</span>(<span class=hljs-string>"{y} {z}"</span>);
            }
        }
    }
}
</code></pre><p>‚Ä¶and then converted to:<pre><code class=language-rust><span class=hljs-keyword>let</span> {
    <span class=hljs-keyword>let</span> {
        _2 = <span class=hljs-number>2</span> + <span class=hljs-number>2</span>;
        _1 = <span class=hljs-string>"hello"</span>;
        <span class=hljs-keyword>if</span> _2 == a {
            <span class=hljs-keyword>let</span> {
                _1 = <span class=hljs-string>"world"</span>;
                <span class=hljs-built_in>println!</span>(<span class=hljs-string>"{_2} {_1}"</span>);
            }
        }
    }
}
</code></pre><p>‚Ä¶which can be directly inserted into a hash map.<p class=next-group><span aria-level=3 class=side-header role=heading><span>Simpler path?</span></span>Oh, but couldn‚Äôt we do something simpler earlier? Couldn‚Äôt we scan each <code>match</code> arm for a list of variable definitions and rewrite local variable accesses into indices from that list, resulting in something like:<pre><code class=language-rust><span class=hljs-keyword>let</span> <span class=hljs-variable>_1</span> = <span class=hljs-number>2</span> + <span class=hljs-number>2</span>;
<span class=hljs-keyword>let</span> <span class=hljs-variable>_2</span> = <span class=hljs-string>"hello"</span>;
<span class=hljs-keyword>if</span> _1 == a {
    <span class=hljs-keyword>let</span> <span class=hljs-variable>_3</span> = <span class=hljs-string>"world"</span>;
    <span class=hljs-built_in>println!</span>(<span class=hljs-string>"{_2} {_3}"</span>);
}
</code></pre><p>Yes, yes we could. But you see, I too have a superpower, called ‚Äúlying‚Äù.<p>We aren‚Äôt <em>just</em> trying to find repetitions among the arms of a single <code>match</code>. We‚Äôre doing that over the whole program. Maybe we‚Äôre writing more lints. Maybe we‚Äôre trying to compress code. Maybe we‚Äôre a theorem prover trying to reduce the size of the graph. Maybe we‚Äôre <a href=../jvm-exceptions-are-weird-a-decompiler-perspective/>writing a Java decompiler</a> <s>(ahem)</s>.<p>Either way, we‚Äôre doing this <em>at scale</em>. And that means that we can‚Äôt just insert the full representations of all subtrees into a single hash map: we‚Äôre going to run out of memory really fast. Barring that, this process is going to take an embarrassing amount of time, since we‚Äôll be constantly iterating over deeply nested nodes.<p>And that‚Äôs where the gamble pays out. What we want is some clever way to compute the nameless encoding of a large block from the encodings of its constituents, so that we don‚Äôt have to scan subtrees repeatedly. Preferably, we want simple concatenation to work:<section><eqn><math style="display:block math;"class=tml-display display=block><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>f</mi><mspace width=0.1667em></mspace><mi>a</mi><mo form=postfix stretchy=false>)</mo><mo>=</mo><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>f</mi><mo form=postfix stretchy=false>)</mo><mspace width=0.1667em></mspace><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>a</mi><mo form=postfix stretchy=false>)</mo><mi>.</mi></mrow></math></eqn></section><p>With de Bruijn indices, that‚Äôs exactly the case. For example, for <eq><math><mrow><mi>f</mi><mo>=</mo></mrow><mrow><mi>Œª</mi><mi>x</mi><mi>.</mi><mi>x</mi><mspace width=0.1667em></mspace><mi>x</mi></mrow></math></eq> and <eq><math><mrow><mi>a</mi><mo>=</mo></mrow><mrow><mi>Œª</mi><mi>y</mi><mi>.</mi><mi>y</mi></mrow></math></eq>, the representations are:<section><eqn><math style="display:block math;"class=tml-display display=block><mtable columnalign="right left"displaystyle=true><mtr><mtd style="padding:0.7ex 0em 0.7ex 0em;"class=tml-right><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>f</mi><mo form=postfix stretchy=false>)</mo></mrow></mtd><mtd style="padding:0.7ex 0em 0.7ex 0em;"class=tml-left><mrow><mo>=</mo><mi>Œª</mi><mi>.</mi><mrow style="padding:0 0 0.1em 0;border-bottom:0.065em solid;"><mn>1</mn></mrow><mspace width=0.1667em></mspace><mrow style="padding:0 0 0.1em 0;border-bottom:0.065em solid;"><mn>1</mn></mrow></mrow></mtd></mtr><mtr><mtd style="padding:0.7ex 0em 0.7ex 0em;"class=tml-right><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>a</mi><mo form=postfix stretchy=false>)</mo></mrow></mtd><mtd style="padding:0.7ex 0em 0.7ex 0em;"class=tml-left><mrow><mo>=</mo><mi>Œª</mi><mi>.</mi><mrow style="padding:0 0 0.1em 0;border-bottom:0.065em solid;"><mn>1</mn></mrow></mrow></mtd></mtr><mtr><mtd style="padding:0.7ex 0em 0.7ex 0em;"class=tml-right><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>f</mi><mspace width=0.1667em></mspace><mi>a</mi><mo form=postfix stretchy=false>)</mo></mrow></mtd><mtd style="padding:0.7ex 0em 0.7ex 0em;"class=tml-left><mrow><mo>=</mo><mo form=prefix stretchy=false>(</mo><mi>Œª</mi><mi>.</mi><mrow style="padding:0 0 0.1em 0;border-bottom:0.065em solid;"><mn>1</mn></mrow><mspace width=0.1667em></mspace><mrow style="padding:0 0 0.1em 0;border-bottom:0.065em solid;"><mn>1</mn></mrow><mo form=postfix stretchy=false>)</mo><mo form=prefix stretchy=false>(</mo><mi>Œª</mi><mi>.</mi><mrow style="padding:0 0 0.1em 0;border-bottom:0.065em solid;"><mn>1</mn></mrow><mo form=postfix stretchy=false>)</mo></mrow></mtd></mtr></mtable></math></eqn></section><p>Meanwhile, had we tried to use indices into a list of local variables, that wouldn‚Äôt work nearly as well. We‚Äôd get the same representations for <eq><math><mi>f</mi></math></eq> and <eq><math><mi>a</mi></math></eq>, but for <eq><math><mrow><mi>f</mi><mspace width=0.1667em></mspace><mi>a</mi></mrow></math></eq>, we‚Äôd expect to get <eq><math><mrow><mo form=prefix stretchy=false>(</mo><mi>Œª</mi><mi>.</mi><mrow style="padding:0 0 0.1em 0;border-bottom:0.065em solid;"><mn>1</mn></mrow><mspace width=0.1667em></mspace><mrow style="padding:0 0 0.1em 0;border-bottom:0.065em solid;"><mn>1</mn></mrow><mo form=postfix stretchy=false>)</mo><mo form=prefix stretchy=false>(</mo><mi>Œª</mi><mi>.</mi><mrow style="padding:0 0 0.1em 0;border-bottom:0.065em solid;"><mn>2</mn></mrow><mo form=postfix stretchy=false>)</mo></mrow></math></eq>, which doesn‚Äôt match the concatenation.<p>1-0 for learning math.<p>The only trouble is that function calls are only one part of the story ‚Äì there‚Äôs also function declarations. It sure seems like<section><eqn><math style="display:block math;"class=tml-display display=block><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>Œª</mi><mi>x</mi><mi>.</mi><mi>t</mi><mo form=postfix stretchy=false>)</mo><mo>=</mo><mi>Œª</mi><mi>.</mi><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>t</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eqn></section><p>‚Ä¶should work too, but that‚Äôs not quite true. Consider <eq><math><mrow><mi>Œª</mi><mi>x</mi><mi>.</mi><mi>x</mi></mrow></math></eq>. The locally nameless representation of <eq><math><mi>x</mi></math></eq> is just <eq><math><mi>x</mi></math></eq>, since it‚Äôs a non-local variable, thus accessed by name. But when we handle <eq><math><mrow><mi>Œª</mi><mi>x</mi><mi>.</mi><mi>x</mi></mrow></math></eq>, it becomes local, so the name should be replaced with an index, resulting in <eq><math><mrow><mi>Œª</mi><mi>.</mi><mrow style="padding:0 0 0.1em 0;border-bottom:0.065em solid;"><mn>1</mn></mrow></mrow></math></eq>. So a more honest algorithm looks like:<section><eqn><math style="display:block math;"class=tml-display display=block><mrow><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>Œª</mi><mi>x</mi><mi>.</mi><mi>t</mi><mo form=postfix stretchy=false>)</mo><mo>=</mo><mi>Œª</mi><mi>.</mi><mrow><mtext></mtext><mi>repr</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>t</mi><mo form=postfix stretchy=false>)</mo><mo form=prefix stretchy=false>[</mo><mi>x</mi><mo lspace=0.2222em rspace=0em>:</mo><mo lspace=0em>=</mo><mrow style="padding:0 0 0.1em 0;border-bottom:0.065em solid;"><mn>1</mn></mrow><mo form=postfix stretchy=false>]</mo><mo separator=true>,</mo></mrow></math></eqn></section><p>where <eq><math><mrow><mo form=prefix stretchy=false>[</mo><mi>x</mi><mo lspace=0.2222em rspace=0em>:</mo><mo lspace=0em>=</mo><mrow style="padding:0 0 0.1em 0;border-bottom:0.065em solid;"><mn>1</mn></mrow><mo form=postfix stretchy=false>]</mo></mrow></math></eq> denotes replacement, and the index in <eq><math><mrow style="padding:0 0 0.1em 0;border-bottom:0.065em solid;"><mn>1</mn></mrow></math></eq> is implicitly understood to be adjusted to the correct one depending on the nesting level.<p>Note that you don‚Äôt have to iterate over the subexpression to find the locations to change. Before analyzing the program, you can accumulate the positions at which each variable is mentioned, and then only mutate those locations with random access. So it‚Äôs going to take linear time in total.<p>This is a lot to take in, so let me put it in code so that we‚Äôre on the same page:<pre><code class=language-python>range_of_expr: <span class=hljs-built_in>dict</span>[Expr, <span class=hljs-built_in>tuple</span>[<span class=hljs-built_in>int</span>, <span class=hljs-built_in>int</span>]] = {}
variable_nesting: <span class=hljs-built_in>dict</span>[VariableName, <span class=hljs-built_in>int</span>] = {}
variable_accesses: <span class=hljs-built_in>dict</span>[VariableName, <span class=hljs-built_in>list</span>[<span class=hljs-built_in>tuple</span>[<span class=hljs-built_in>int</span>, <span class=hljs-built_in>int</span>]]] = {}
current_location: <span class=hljs-built_in>int</span> = <span class=hljs-number>0</span>

<span class=hljs-keyword>def</span> <span class="hljs-title function_">collect_locations</span>(<span class=hljs-params>expr: Expr, nesting: <span class=hljs-built_in>int</span></span>):
    <span class=hljs-keyword>global</span> current_location
    start = current_location
    <span class=hljs-keyword>match</span> expr:
        <span class=hljs-keyword>case</span> Variable(x):
            <span class=hljs-comment># x</span>
            current_location += <span class=hljs-number>1</span>
            variable_accesses[x].append((start, nesting - variable_nesting[x]))
        <span class=hljs-keyword>case</span> Function(x, body):
            <span class=hljs-comment># \, body</span>
            current_location += <span class=hljs-number>1</span>
            variable_nesting[x] = nesting
            variable_accesses[x] = []
            collect_locations(body, nesting + <span class=hljs-number>1</span>)
        <span class=hljs-keyword>case</span> Call(f, a):
            <span class=hljs-comment># (, f, a, )</span>
            current_location += <span class=hljs-number>1</span>
            collect_locations(f, nesting)
            collect_locations(a, nesting)
            current_location += <span class=hljs-number>1</span>
    end = current_location
    range_of_expr[expr] = (start, end)

collect_locations(root, <span class=hljs-number>0</span>)
output = [<span class=hljs-literal>None</span>] * current_location

<span class=hljs-keyword>def</span> <span class="hljs-title function_">calculate_representations</span>(<span class=hljs-params>expr: Expr</span>):
    start, end = range_of_expr[expr]
    <span class=hljs-keyword>match</span> expr:
        <span class=hljs-keyword>case</span> Variable(x):
            output[start] = x
        <span class=hljs-keyword>case</span> Function(x, body):
            output[start] = <span class=hljs-string>"\\"</span>
            calculate_representations(body)
            <span class=hljs-keyword>for</span> location, de_bruijn_index <span class=hljs-keyword>in</span> variable_accesses[x]:
                output[location] = de_bruijn_index
        <span class=hljs-keyword>case</span> Call(f, a):
            output[start] = <span class=hljs-string>"("</span>
            calculate_representations(f)
            calculate_representations(a)
            output[end - <span class=hljs-number>1</span>] = <span class=hljs-string>")"</span>
    <span class=hljs-built_in>print</span>(<span class=hljs-string>"The representation of"</span>, expr, <span class=hljs-string>"is"</span>, output[start:end])

calculate_representations(root)
</code></pre><p class=next-group><span aria-level=3 class=side-header role=heading><span>Hashing</span></span>Ironically, the only non-linear part of the algorithm is <code>output[start:end]</code> in the <code>print</code> statement, since the total length of representations is <eq><math><mrow><mi class=mathcal>ùí™</mi><mo form=prefix stretchy=false>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo form=postfix stretchy=false>)</mo></mrow></math></eq>. Yes, we‚Äôre getting bottlenecked by output. Now that we‚Äôre producing representations quickly, we need to figure out how to consume them at the same speed. But fixing this is easier said than done: we can‚Äôt insert the representations into a hash map or even properly hash them, since we simply don‚Äôt have the time.<p>However, we can still hash the representations <em>improperly</em>. Here‚Äôs what I mean by that. Suppose that we used the following ‚Äì very stupid, I know ‚Äì hash function:<div class=aside-group><aside><p><eq><math><mo lspace=0em rspace=0em>‚äïÔ∏é</mo></math></eq> denotes XOR in math formulas. <eq><math><mrow><mi>|</mi><mi>|</mi></mrow></math></eq> denotes concatenation.</aside><section><eqn><math style="display:block math;"class=tml-display display=block><mrow><mrow><mtext></mtext><mi>hash</mi></mrow><mo form=prefix stretchy=false>(</mo><msub><mi>c</mi><mn>0</mn></msub><msub><mi>c</mi><mn>1</mn></msub><mo>‚Ä¶</mo><msub><mi>c</mi><mrow><mi>n</mi><mo>‚àí</mo><mn>1</mn></mrow></msub><mo form=postfix stretchy=false>)</mo><mo>=</mo><msub><mi>c</mi><mn>0</mn></msub><mo>‚äïÔ∏é</mo><msub><mi>c</mi><mn>1</mn></msub><mo>‚äïÔ∏é</mo><mo>‚ãØ</mo><mo>‚äïÔ∏é</mo><msub><mi>c</mi><mrow><mi>n</mi><mo>‚àí</mo><mn>1</mn></mrow></msub></mrow></math></eqn></section></div><p>This formula makes it easy to compute the hash of concatenation of two hashed strings, without knowing their exact contents:<section><eqn><math style="display:block math;"class=tml-display display=block><mrow><mrow><mtext></mtext><mi>hash</mi></mrow><mo form=prefix stretchy=false>(</mo><msub><mi>s</mi><mn>1</mn></msub><mo lspace=0.1667em rspace=0.1667em><mi>|</mi><mi>|</mi></mo><msub><mi>s</mi><mn>2</mn></msub><mo form=postfix stretchy=false>)</mo><mo>=</mo><mrow><mtext></mtext><mi>hash</mi></mrow><mo form=prefix stretchy=false>(</mo><msub><mi>s</mi><mn>1</mn></msub><mo form=postfix stretchy=false>)</mo><mo>‚äïÔ∏é</mo><mrow><mtext></mtext><mi>hash</mi></mrow><mo form=prefix stretchy=false>(</mo><msub><mi>s</mi><mn>2</mn></msub><mo form=postfix stretchy=false>)</mo></mrow></math></eqn></section><p>But more importantly, it can handle replacements:<section><eqn><math style="display:block math;"class=tml-display display=block><mrow><mrow><mtext></mtext><mi>hash</mi></mrow><mo form=prefix stretchy=false>(</mo><msub><mi>s</mi><mn>1</mn></msub><mo lspace=0.1667em rspace=0.1667em><mi>|</mi><mi>|</mi></mo><msup><mi>c</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup><mo lspace=0.1667em rspace=0.1667em><mi>|</mi><mi>|</mi></mo><msub><mi>s</mi><mn>2</mn></msub><mo form=postfix stretchy=false>)</mo><mo>=</mo><mrow><mtext></mtext><mi>hash</mi></mrow><mo form=prefix stretchy=false>(</mo><msub><mi>s</mi><mn>1</mn></msub><mo lspace=0.1667em rspace=0.1667em><mi>|</mi><mi>|</mi></mo><mi>c</mi><mo lspace=0.1667em rspace=0.1667em><mi>|</mi><mi>|</mi></mo><msub><mi>s</mi><mn>2</mn></msub><mo form=postfix stretchy=false>)</mo><mo>‚äïÔ∏é</mo><mi>c</mi><mo>‚äïÔ∏é</mo><msup><mi>c</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup></mrow></math></eqn></section><p>Together, this allows us to efficiently compute hashes of all representations, without even storing those representations in memory. That‚Äôs great, except for the fact that XOR makes for a terrible hash.<div class=aside-group><aside><p>Polynomial hashing provides strong guarantees. If you treat a string <eq><math><mi>s</mi></math></eq> as a polynomial <eq><math><mrow><mi>s</mi><mo form=prefix stretchy=false>(</mo><mi>x</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> with coefficients matching individual characters, you‚Äôll find that its hash is the value <eq><math><mrow><mi>s</mi><mo form=prefix stretchy=false>(</mo><mi>b</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq>. The hashes of two strings <eq><math><msub><mi>s</mi><mn>1</mn></msub></math></eq>, <eq><math><msub><mi>s</mi><mn>2</mn></msub></math></eq> collide if <eq><math><mrow><msub><mi>s</mi><mn>1</mn></msub><mo form=prefix stretchy=false>(</mo><mi>b</mi><mo form=postfix stretchy=false>)</mo><mo>‚àí</mo></mrow><mrow><msub><mi>s</mi><mn>2</mn></msub><mo form=prefix stretchy=false>(</mo><mi>b</mi><mo form=postfix stretchy=false>)</mo><mo>=</mo></mrow><mrow><mn>0</mn></mrow></math></eq>, i.e. if <eq><math><mi>b</mi></math></eq> is the root of the polynomial <eq><math><mrow><msub><mi>s</mi><mn>1</mn></msub><mo form=prefix stretchy=false>(</mo><mi>x</mi><mo form=postfix stretchy=false>)</mo><mo>‚àí</mo></mrow><mrow><msub><mi>s</mi><mn>2</mn></msub><mo form=prefix stretchy=false>(</mo><mi>x</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq>. For strings of length <eq><math><mi>k</mi></math></eq>, this polynomial has degree <eq><math><mrow><mi>k</mi><mo>‚àí</mo></mrow><mrow><mn>1</mn></mrow></math></eq> and thus at most <eq><math><mrow><mi>k</mi><mo>‚àí</mo></mrow><mrow><mn>1</mn></mrow></math></eq> roots, so the collision rate is <eq><math><mrow><mo><</mo></mrow><mrow><mfrac><mi>k</mi><mi>p</mi></mfrac></mrow></math></eq>.</aside><p>But there‚Äôs better hashes that still support these operations. The most common one is the <a href=https://en.wikipedia.org/wiki/Rolling_hash#Polynomial_rolling_hash>polynomial hash</a>, defined as follows:<section><eqn><math style="display:block math;"class=tml-display display=block><mrow><mrow><mtext></mtext><mi>hash</mi></mrow><mo form=prefix stretchy=false>(</mo><msub><mi>c</mi><mn>0</mn></msub><msub><mi>c</mi><mn>1</mn></msub><mo>‚Ä¶</mo><msub><mi>c</mi><mrow><mi>n</mi><mo>‚àí</mo><mn>1</mn></mrow></msub><mo form=postfix stretchy=false>)</mo><mo>=</mo><msub><mi>c</mi><mn>0</mn></msub><mo>+</mo><msub><mi>c</mi><mn>1</mn></msub><mi>b</mi><mo>+</mo><msub><mi>c</mi><mn>2</mn></msub><msup><mi>b</mi><mn>2</mn></msup><mo>+</mo><mo>‚ãØ</mo><mo>+</mo><msub><mi>c</mi><mrow><mi>n</mi><mo>‚àí</mo><mn>1</mn></mrow></msub><msup><mi>b</mi><mrow><mi>n</mi><mo>‚àí</mo><mn>1</mn></mrow></msup><mo></mo><mspace width=1em></mspace><mrow><mtext></mtext><mi>mod</mi></mrow><mspace width=0.1667em></mspace><mspace width=0.1667em></mspace><mi>p</mi></mrow></math></eqn></section><p>Here, <eq><math><mi>p</mi></math></eq> and <eq><math><mi>b</mi></math></eq> are parameters of the hash. <eq><math><mi>p</mi></math></eq> is a large prime number, typically chosen by the programmer and fixed during execution. <eq><math><mi>b</mi></math></eq> is an arbitrary number from <eq><math><mn>0</mn></math></eq> to <eq><math><mrow><mi>p</mi><mo>‚àí</mo></mrow><mrow><mn>1</mn></mrow></math></eq>, typically chosen randomly at runtime. The polynomial hash is safer than XOR because characters don‚Äôt trivially cancel out.</div><p>To concatenate strings, we only need to know their hashes and lengths:<section><eqn><math style="display:block math;"class=tml-display display=block><mrow><mrow><mtext></mtext><mi>hash</mi></mrow><mo form=prefix stretchy=false>(</mo><msub><mi>s</mi><mn>1</mn></msub><mo lspace=0.1667em rspace=0.1667em><mi>|</mi><mi>|</mi></mo><msub><mi>s</mi><mn>2</mn></msub><mo form=postfix stretchy=false>)</mo><mo>=</mo><mrow><mtext></mtext><mi>hash</mi></mrow><mo form=prefix stretchy=false>(</mo><msub><mi>s</mi><mn>1</mn></msub><mo form=postfix stretchy=false>)</mo><mo>+</mo><mrow><mtext></mtext><mi>hash</mi></mrow><mo form=prefix stretchy=false>(</mo><msub><mi>s</mi><mn>2</mn></msub><mo form=postfix stretchy=false>)</mo><mspace width=0.1667em></mspace><msup><mi>b</mi><mrow><mi>|</mi><msub><mi>s</mi><mn>1</mn></msub><mi>|</mi></mrow></msup><mo></mo><mspace width=1em></mspace><mrow><mtext></mtext><mi>mod</mi></mrow><mspace width=0.1667em></mspace><mspace width=0.1667em></mspace><mi>p</mi></mrow></math></eqn></section><p>To replace a character, we need to know the original hash, the position of the affected character, and what is replaced with what:<section><eqn><math style="display:block math;"class=tml-display display=block><mrow><mrow><mtext></mtext><mi>hash</mi></mrow><mo form=prefix stretchy=false>(</mo><msub><mi>s</mi><mn>1</mn></msub><mo lspace=0.1667em rspace=0.1667em><mi>|</mi><mi>|</mi></mo><msup><mi>c</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup><mo lspace=0.1667em rspace=0.1667em><mi>|</mi><mi>|</mi></mo><msub><mi>s</mi><mn>2</mn></msub><mo form=postfix stretchy=false>)</mo><mo>=</mo><mrow><mtext></mtext><mi>hash</mi></mrow><mo form=prefix stretchy=false>(</mo><msub><mi>s</mi><mn>1</mn></msub><mo lspace=0.1667em rspace=0.1667em><mi>|</mi><mi>|</mi></mo><mi>c</mi><mo lspace=0.1667em rspace=0.1667em><mi>|</mi><mi>|</mi></mo><msub><mi>s</mi><mn>2</mn></msub><mo form=postfix stretchy=false>)</mo><mo>+</mo><mo form=prefix stretchy=false>(</mo><msup><mi>c</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup><mo>‚àí</mo><mi>c</mi><mo form=postfix stretchy=false>)</mo><mspace width=0.1667em></mspace><msup><mi>b</mi><mi>i</mi></msup><mo></mo><mspace width=1em></mspace><mrow><mtext></mtext><mi>mod</mi></mrow><mspace width=0.1667em></mspace><mspace width=0.1667em></mspace><mi>p</mi></mrow></math></eqn></section><p>All in all, this allows the hashes of all subexpressions to be computed in <eq><math><mrow><mi class=mathcal>ùí™</mi><mo form=prefix stretchy=false>(</mo><mi>n</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq>:<pre><code class=language-python>powers_of_b: <span class=hljs-built_in>list</span>[<span class=hljs-built_in>int</span>] = [<span class=hljs-number>1</span>]

<span class=hljs-comment># Computes `h * b ** count % p` in amortized constant time.</span>
<span class=hljs-keyword>def</span> <span class="hljs-title function_">shift</span>(<span class=hljs-params>h: <span class=hljs-built_in>int</span>, count: <span class=hljs-built_in>int</span></span>) -> <span class=hljs-built_in>int</span>:
    <span class=hljs-keyword>while</span> <span class=hljs-built_in>len</span>(powers_of_b) <= count:
        powers_of_b.append(powers_of_b[-<span class=hljs-number>1</span>] * b % p)
    <span class=hljs-keyword>return</span> h * powers_of_b[count] % p

<span class=hljs-comment># Not shown: a function capable of hashing variable names, de Bruijn indices, and characters</span>
<span class=hljs-comment># \, (, ) without collisions.</span>
<span class=hljs-keyword>def</span> <span class="hljs-title function_">hash_small</span>(<span class=hljs-params>x</span>) -> <span class=hljs-built_in>int</span>: ...

<span class=hljs-keyword>def</span> <span class="hljs-title function_">calculate_hashes</span>(<span class=hljs-params>expr: Expr</span>) -> <span class=hljs-built_in>int</span>:
    start, end = range_of_expr[expr]
    <span class=hljs-keyword>match</span> expr:
        <span class=hljs-keyword>case</span> Variable(x):
            h = hash_small(x)
        <span class=hljs-keyword>case</span> Function(x, body):
            h = hash_small(<span class=hljs-string>"\\"</span>) + shift(calculate_hashes(body), <span class=hljs-number>1</span>)
            <span class=hljs-keyword>for</span> location, de_bruijn_index <span class=hljs-keyword>in</span> variable_accesses[x]:
                h += shift(hash_small(de_bruijn_index) - hash_small(x), location - start)
                h %= p
        <span class=hljs-keyword>case</span> Call(f, a):
            h = (
                hash_small(<span class=hljs-string>"("</span>)
                + shift(calculate_hashes(f), <span class=hljs-number>1</span>)
                + shift(calculate_hashes(a), range_of_expr[a][<span class=hljs-number>0</span>] - start)
                + shift(hash_small(<span class=hljs-string>")"</span>), end - <span class=hljs-number>1</span> - start)
            )
    h %= p
    <span class=hljs-built_in>print</span>(<span class=hljs-string>"The hash of"</span>, expr, <span class=hljs-string>"is"</span>, h)
    <span class=hljs-keyword>return</span> h

calculate_hashes(root)
</code></pre><p class=next-group><span aria-level=3 class=side-header role=heading><span>Summing up</span></span>We‚Äôve figured out how to compare any subtrees for equality in constant time, at the cost of some linear-time precalculation. So that‚Äôs good.<p>Unfortunately, we had to use hashes, which means that there‚Äôs a small chance of a false positive: we might consider two distinct trees identical if their hashes match by accident. What can we do about it?<ol><li><p>Sometimes, such a false positive is perfectly acceptable. If the chosen prime <eq><math><mi>p</mi></math></eq> is large enough and <eq><math><mi>b</mi></math></eq> is truly random, there‚Äôs a very low chance of getting the wrong answer ‚Äì lower than <a href=https://en.wikipedia.org/wiki/Single-event_upset>a bit flip due to a stray particle</a>.</p><li><p>We can avoid false positives by comparing the subexpressions for equality if the hashes match. This gives us the ability to discard checks that we know would fail, and only focus on successes. Depending on your goal, this may either be an asymptotic slow-down back to <eq><math><mrow><mi class=mathcal>ùí™</mi><mo form=prefix stretchy=false>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo form=postfix stretchy=false>)</mo></mrow></math></eq> in the worst case, or not. For example, if you delete one of the duplicates as soon as you encounter it, it‚Äôs going to be <eq><math><mrow><mi class=mathcal>ùí™</mi><mo form=prefix stretchy=false>(</mo><mi>n</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq>; otherwise you might be in danger.</p><li><p>If you‚Äôre drawn to constant-time comparison, there is a way to <em>validate</em> the obtained hashes for lack of collisions in <eq><math><mrow><mi class=mathcal>ùí™</mi><mo form=prefix stretchy=false>(</mo><mi>n</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq>. If a collision is found, just regenerate the hashes with a different seed. This has expected linear time, but is slower than blind trust.</p><li><p>If you don‚Äôt like randomness, there‚Äôs a deterministic algorithm producing collision-free hashes in guaranteed <eq><math><mrow><mi class=mathcal>ùí™</mi><mo form=prefix stretchy=false>(</mo><mi>n</mi><mrow><mspace width=0.1667em></mspace><mi>log</mi><mo>‚Å°</mo><mspace width=0.1667em></mspace></mrow><mi>n</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> time.</p></ol><p>The algorithms in 3. and 4. are tricky, and this post is already quite long, so I‚Äôll cover them in a later, more technical post. <a href=../feed.rss>Subscribe to my RSS</a> if you don‚Äôt want to miss it.<p class=next-group><span aria-level=3 class=side-header role=heading><span>References</span></span>This post is partially based on the paper <a href=https://arxiv.org/abs/2105.02856>Hashing Modulo Alpha-Equivalence</a>, though the algorithm described in the paper is slightly different:<ul><li>The time complexity in the paper is listed as <eq><math><mrow><mi class=mathcal>ùí™</mi><mo form=prefix stretchy=false>(</mo><mi>n</mi><mspace width=0.1667em></mspace><msup><mi>log</mi><mn>2</mn></msup><mo>‚Å°</mo><mspace width=0.1667em></mspace><mi>n</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> due to the use of a balanced tree instead of a hash table. With a hash table, the expected time becomes <eq><math><mrow><mi class=mathcal>ùí™</mi><mo form=prefix stretchy=false>(</mo><mi>n</mi><mrow><mspace width=0.1667em></mspace><mi>log</mi><mo>‚Å°</mo><mspace width=0.1667em></mspace></mrow><mi>n</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq>.<li>The paper‚Äôs algorithm can be computed incrementally over subtrees instead of having to see the whole program at once, at the cost of the <eq><math><mrow><mrow><mi>log</mi><mo>‚Å°</mo><mspace width=0.1667em></mspace></mrow><mi>n</mi></mrow></math></eq> factor.<li>The paper uses a different hashing scheme. This post uses single-layer polynomial hashing, while the paper uses XOR, but passes the arguments through a pseudo-random hash function. This leads to slightly different collision rates and practical performance.</ul></div></section><footer><div class=viewport-container><h2>Made with my own bare hands (why.)</h2></div></footer><script>window.addEventListener("keydown", e => {
				if (e.key === "Enter") {
					if (e.ctrlKey) {
						window.open("https://github.com/purplesyringa/site/edit/master/blog/finding-duplicated-code-with-tools-from-your-cs-course/index.md", "_blank");
					} else if (
						e.target.type === "checkbox"
						&& e.target.parentNode
						&& e.target.parentNode.className === "expansible-code"
					) {
						e.target.click();
					}
				}
			});</script>