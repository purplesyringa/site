<!doctypehtml><html prefix="og: http://ogp.me/ns#"lang=en_US><meta charset=utf-8><meta content=width=device-width,initial-scale=1 name=viewport><title>Rust's v0 mangling scheme in a nutshell | purplesyringa's blog</title><link href=../../favicon.ico?v=2 rel=icon><link href=../../all.css rel=stylesheet><link href=../../blog.css rel=stylesheet><link href=../../vendor/Temml-Local.css rel=stylesheet><link crossorigin href=https://fonts.googleapis.com/css2?family=Noto+Sans:ital,wght@0,100..900;1,100..900&family=Roboto+Mono:ital,wght@0,100..700;1,100..700&family=Roboto:ital,wght@0,400;0,700;1,400;1,700&family=Slabo+27px&display=swap rel=stylesheet><link href=../../fonts/webfont.css rel=stylesheet><link media="screen and (prefers-color-scheme: dark"href=../../vendor/atom-one-dark.min.css rel=stylesheet><link media="screen and (prefers-color-scheme: light"href=../../vendor/a11y-light.min.css rel=stylesheet><link title="Blog posts"href=../../blog/feed.rss rel=alternate type=application/rss+xml><meta content="Rust's v0 mangling scheme in a nutshell"property=og:title><meta content=article property=og:type><meta content=https://purplesyringa.moe/blog/rusts-v0-mangling-scheme-in-a-nutshell/og.png property=og:image><meta content=https://purplesyringa.moe/blog/rusts-v0-mangling-scheme-in-a-nutshell/ property=og:url><meta content="Functions in binary files need to have unique names, so Rust needs to decide what to call its functions and statics. This format needs to be standardized so that debuggers and profilers can recover the full names (e.g. alloc::vec::Vec instead of just Vec).
About a month ago, Rust switched to symbol mangling v0 on nightly. The linked announcement describes some benefits of the new scheme compared to the previous ad-hoc hack:

Mangled names of generic functions now include generic parameters.
There are almost no opaque hashes, meaning that it’s easier to make a hypothetical alternative Rust compiler produce identical mangled names.
Mangled names no longer include characters like $ and., which some platforms don’t support.

That’s pretty interesting, but not very deep. I want to highlight some non-obious details that weren’t mentioned in the post."property=og:description><meta content=en_US property=og:locale><meta content="purplesyringa's blog"property=og:site_name><meta content=summary_large_image name=twitter:card><meta content=https://purplesyringa.moe/blog/rusts-v0-mangling-scheme-in-a-nutshell/og.png name=twitter:image><script data-website-id=0da1961d-43f2-45cc-a8e2-75679eefbb69 defer src=https://zond.tei.su/script.js></script><body><header><div class=viewport-container><div class=media><a href=https://github.com/purplesyringa><img alt=GitHub src=../../images/github-mark-white.svg></a></div><h1><a href=/>purplesyringa</a></h1><nav><a href=../..>about</a><a class=current href=../../blog/>blog</a><a href=../../sink/>kitchen sink</a></nav></div></header><section><div class=viewport-container><h2>Rust's v0 mangling scheme in a nutshell</h2><time>December 15, 2025</time><div class=aside-group><aside><p><a href=https://social.linux.pizza/@detondev/114942195938099088>Original meme</a></aside><p><div class=diagram><img alt='Picture of a nutshell captioned "v0 mangling scheme in a nutshell". A speech bubble with text "Help!" indicates a sound from inside the nutshell. An example of mangled symbol (_RNvCs15kBYyAo9fc_7mycrate7example) is superimposed on the nutshell.'title='Picture of a nutshell captioned "v0 mangling scheme in a nutshell". A speech bubble with text "Help!" indicates a sound from inside the nutshell. An example of mangled symbol (_RNvCs15kBYyAo9fc_7mycrate7example) is superimposed on the nutshell.'src=meme.png></div></div><p>Functions in binary files need to have unique names, so Rust needs to decide what to call its functions and <code>static</code>s. This format needs to be standardized so that debuggers and profilers can recover the full names (e.g. <code>alloc::vec::Vec</code> instead of just <code>Vec</code>).<p>About a month ago, <a href=https://blog.rust-lang.org/2025/11/20/switching-to-v0-mangling-on-nightly/>Rust switched to symbol mangling v0 on nightly</a>. The linked announcement describes some benefits of the new scheme compared to the previous ad-hoc hack:<ul><li>Mangled names of generic functions now include generic parameters.<li>There are almost no opaque hashes, meaning that it’s easier to make a hypothetical alternative Rust compiler produce identical mangled names.<li>Mangled names no longer include characters like <code>$</code> and <code>.</code>, which some platforms don’t support.</ul><p>That’s pretty interesting, but not very deep. I want to highlight some non-obious details that weren’t mentioned in the post.<p class=next-group><span aria-level=3 class=side-header role=heading><span>Why v0?</span></span>Why is the old mangling called <code>legacy</code> and the new mangling is called <code>v0</code>, instead of the more sensible <code>v1</code> and <code>v2</code>?<p>The new standard includes the mangling version in the symbol name. If the scheme ever needs to updated, the general encoding structure will be reused and the version field will be incremented. The distinction is not between old and new schemes, but rather between the pre-versioning and post-versioning eras. The current version is 0.<p class=next-group><span aria-level=3 class=side-header role=heading><span>Punycode</span></span>The new scheme supports Unicode identifiers. The surface Rust language doesn’t, but if this ever changes, the mangling side will be ready.<p><a href=https://en.wikipedia.org/wiki/Punycode>Punycode</a> is used to fit all of Unicode in the <code>[a-zA-Z0-9_]</code> range. You’re likely familar with Punycode from DNS, which only supports pure-ASCII hostnames. For example, <code>münchen.de</code> is encoded as <code>xn--mnchen-3ya.de</code>.<p>Unlike <code>base64</code>, Punycode keeps the ASCII portion of the string readable (<code>mnchen</code> in the previous example) and only encodes the non-ASCII subsequence. This improves human readability of mangled symbols. Punycode is also highly optimized for space.<p class=next-group><span aria-level=3 class=side-header role=heading><span>Base-58</span></span>Most integers (<code>const</code> generic parameters, array sizes, crate IDs, etc.) are encoded in base-58 for compactness. As an exception, identifiers are prefixed with their length in base 10: since identifiers can’t start with decimal digits, this saves a byte by avoiding a separator.<p class=next-group><span aria-level=3 class=side-header role=heading><span>Backrefs</span></span>To reduce repetitions within the symbol, <code>B&LToffset></code> can be used to repeat the value at position <code>offset</code> from the beginning of the mangled name. Compared to the Itanium ABI used by C++, which addresses AST nodes instead of byte positions, this allows v0 symbols to be demangled without allocation.<p class=next-group><span aria-level=3 class=side-header role=heading><span>Disambiguators</span></span>“Disambiguators” are opaque numbers that ensure uniqueness of objects that would otherwise have identical names. This is used for closures (which don’t have names by definition), different versions of the same crate, and methods in <code>impl</code> blocks with different <code>where</code> bounds.<pre><code class=language-rust><span class=hljs-comment>// Both `foo` methods are called `&LTT as Trait>::foo`, so a disambiguator is necessary.</span>

<span class=hljs-keyword>impl</span>&LTT> Trait <span class=hljs-keyword>for</span> <span class="hljs-title class_">T</span>
<span class=hljs-keyword>where</span>
    T: Trait2&LTAssoc = <span class=hljs-type>i8</span>>
{
    <span class=hljs-keyword>fn</span> <span class="hljs-title function_">foo</span>() { <span class=hljs-comment>/* impl 1 */</span> }
}

<span class=hljs-keyword>impl</span>&LTT> Trait <span class=hljs-keyword>for</span> <span class="hljs-title class_">T</span>
<span class=hljs-keyword>where</span>
    T: Trait2&LTAssoc = <span class=hljs-type>u32</span>>
{
    <span class=hljs-keyword>fn</span> <span class="hljs-title function_">foo</span>() { <span class=hljs-comment>/* impl 2 */</span> }
}
</code></pre><p class=next-group><span aria-level=3 class=side-header role=heading><span>Primitives</span></span>Primitive types are encoded with a single letter:<ul><li><code>a</code> = <code>i8</code><li><code>b</code> = <code>bool</code><li><code>c</code> = <code>char</code><li><code>d</code> = <code>f64</code><li><code>e</code> = <code>str</code><li>…<li><code>z</code> = <code>!</code></ul><p><code>d</code> clearly stands for <code>double</code>, but what does <code>e</code> mean?<p>For types defined in C, the mapping was directly taken from the Itanium ABI. For the rest of the types, the letters were assigned mostly sequentially. <code>c</code> corresponds to <code>char</code> in both standards, even though the types are very different.<p class=next-group><span aria-level=3 class=side-header role=heading><span>Placeholders</span></span>Generic parameters allow v0 to encode names like <code>&LTi32 as Add&LTi32>>::add</code>. But consider the <code>STATIC</code> in:<pre><code class=language-rust><span class=hljs-keyword>impl</span>&LTT, U> Trait&LTT> <span class=hljs-keyword>for</span> <span class="hljs-title class_">U</span> {
    <span class=hljs-keyword>fn</span> <span class="hljs-title function_">f</span>() {
        <span class=hljs-keyword>static</span> STATIC: <span class=hljs-type>i32</span> = <span class=hljs-number>0</span>;
    }
}
</code></pre><p>Since <code>STATIC</code> isn’t monomorphized, it will be named <code><_ as Trait<_>>::f::STATIC</code> with a placeholder instead of generic parameters.<p class=next-group><span aria-level=3 class=side-header role=heading><span>Lifetimes</span></span>Due to HRTB, two types can be distinct in runtime, but only differ only in lifetimes. Compare:<pre><code class=language-rust><span class=hljs-keyword>type</span> <span class="hljs-title class_">T1</span> = <span class=hljs-keyword>for</span><<span class=hljs-symbol>'a</span>> <span class="hljs-title function_ invoke__">fn</span>(&<span class=hljs-symbol>'a</span> <span class=hljs-keyword>mut</span> <span class=hljs-type>i32</span>, &<span class=hljs-symbol>'a</span> <span class=hljs-keyword>mut</span> <span class=hljs-type>i32</span>);
<span class=hljs-keyword>type</span> <span class="hljs-title class_">T2</span> = <span class=hljs-keyword>for</span><<span class=hljs-symbol>'a</span>, <span class=hljs-symbol>'b</span>> <span class="hljs-title function_ invoke__">fn</span>(&<span class=hljs-symbol>'a</span> <span class=hljs-keyword>mut</span> <span class=hljs-type>i32</span>, &<span class=hljs-symbol>'b</span> <span class=hljs-keyword>mut</span> <span class=hljs-type>i32</span>);
</code></pre><p>In v0, “binders” can define anonymous lifetimes, much like <code>for</code> in surface Rust syntax, and there is syntax for mentioning such lifetimes by index.</div></section><footer><div class=viewport-container><h2>Made with my own bare hands (why.)</h2></div></footer><script>window.addEventListener("keydown", e => {
				if (e.key === "Enter") {
					if (e.ctrlKey) {
						window.open("https://github.com/purplesyringa/site/edit/master/blog/rusts-v0-mangling-scheme-in-a-nutshell/index.md", "_blank");
					} else if (
						e.target.type === "checkbox"
						&& e.target.parentNode
						&& e.target.parentNode.className === "expansible-code"
					) {
						e.target.click();
					}
				}
			});</script>