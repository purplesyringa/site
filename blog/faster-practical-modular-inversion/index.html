<!doctypehtml><html prefix="og: http://ogp.me/ns#"lang=en_US><meta charset=utf-8><meta content=width=device-width,initial-scale=1 name=viewport><title>Faster practical modular inversion | purplesyringa's blog</title><link href=../../favicon.ico?v=2 rel=icon><link href=../../all.css rel=stylesheet><link href=../../blog.css rel=stylesheet><link href=../../vendor/Temml-Local.css rel=stylesheet><link crossorigin href=https://fonts.googleapis.com/css2?family=Noto+Sans:ital,wght@0,100..900;1,100..900&family=Roboto+Mono:ital,wght@0,100..700;1,100..700&family=Roboto:ital,wght@0,400;0,700;1,400;1,700&family=Slabo+27px&display=swap rel=stylesheet><link href=../../fonts/webfont.css rel=stylesheet><link media="screen and (prefers-color-scheme: dark"href=../../vendor/atom-one-dark.min.css rel=stylesheet><link media="screen and (prefers-color-scheme: light"href=../../vendor/a11y-light.min.css rel=stylesheet><link title="Blog posts"href=../../blog/feed.rss rel=alternate type=application/rss+xml><meta content="Faster practical modular inversion"property=og:title><meta content=article property=og:type><meta content=https://purplesyringa.moe/blog/faster-practical-modular-inversion/og.png property=og:image><meta content=https://purplesyringa.moe/blog/faster-practical-modular-inversion/ property=og:url><meta content="Last year, Lemire wrote about an optimized variation of the Euclidean algorithm for computing the greatest common divisor of two numbers, called binary Euclidean algorithm or Stein‚Äôs algorithm. It‚Äôs a best-of-class implementation, though it‚Äôs currently only used by libc++.
The post also briefly mentions the extended Euclidean algorithm, a related algorithm most often used to compute the modular multiplicative inverse (given a remainder a and a modulus m , find x such that a ‚ãÖ x mod m = 1 ):

There is also a binary version of the extended Euclidean algorithm[,] although it is quite a bit more involved and it is not clear that it [‚Ä¶] can be implemented at high speed, leveraging fast instructions, when working on integers that fit in general-purpose registers. [‚Ä¶]
My implementation of the binary extended Euclidean algorithm is quite a bit slower and not recommended. I expect that it should be possible to optimize it further.

That‚Äôs a big shame, because the extended Euclidean algorithm can be optimized in a very similar manner, and the underlying ideas were described in a 2020 paper. It‚Äôs probably not well-known because the paper focuses on constant-time evaluation and long arithmetic, so people might have assumed it‚Äôs irrelevant.
I‚Äôm hoping to bring justice to the extended Stein‚Äôs algorithm with this post. I‚Äôll cover how the algorithm works, its limitations, some optimizations compared to Pornin‚Äôs paper, and potential further improvements.
My implementation is available on GitHub as part of a Rust modular arithmetic library."property=og:description><meta content=en_US property=og:locale><meta content="purplesyringa's blog"property=og:site_name><meta content=summary_large_image name=twitter:card><meta content=https://purplesyringa.moe/blog/faster-practical-modular-inversion/og.png name=twitter:image><script data-website-id=0da1961d-43f2-45cc-a8e2-75679eefbb69 defer src=https://zond.tei.su/script.js></script><body><header><div class=viewport-container><div class=media><a href=https://github.com/purplesyringa><img alt=GitHub src=../../images/github-mark-white.svg></a></div><h1><a href=/>purplesyringa</a></h1><nav><a href=../..>about</a><a class=current href=../../blog/>blog</a><a href=../../sink/>kitchen sink</a></nav></div></header><section><div class=viewport-container><h2>Faster practical modular inversion</h2><time>December 20, 2025</time><div class=aside-group><aside><p>If you‚Äôre looking to contribute to OSS, that‚Äôs your cue.</aside><p>Last year, <a href=https://lemire.me/blog/2024/04/13/greatest-common-divisor-the-extended-euclidean-algorithm-and-speed/>Lemire wrote</a> about an optimized variation of <a href=https://en.wikipedia.org/wiki/Euclidean_algorithm>the Euclidean algorithm</a> for computing <a href=https://en.wikipedia.org/wiki/Greatest_common_divisor>the greatest common divisor</a> of two numbers, called <em>binary Euclidean algorithm</em> or <em>Stein‚Äôs algorithm</em>. It‚Äôs a best-of-class implementation, though it‚Äôs currently only used by libc++.</div><p>The post also briefly mentions <a href=https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm>the extended Euclidean algorithm</a>, a related algorithm most often used to compute the <a href=https://en.wikipedia.org/wiki/Modular_multiplicative_inverse>modular multiplicative inverse</a> (given a remainder <eq><math><mi>a</mi></math></eq> and a modulus <eq><math><mi>m</mi></math></eq>, find <eq><math><mi>x</mi></math></eq> such that <eq><math><mrow><mi>a</mi><mo>‚ãÖ</mo></mrow><mrow><mi>x</mi><mo lspace=0.2222em rspace=0.2222em>mod</mo></mrow><mrow><mi>m</mi><mo>=</mo></mrow><mrow><mn>1</mn></mrow></math></eq>):<blockquote><p>There is also a binary version of the extended Euclidean algorithm[,] although it is quite a bit more involved and it is not clear that it [‚Ä¶] can be implemented at high speed, leveraging fast instructions, when working on integers that fit in general-purpose registers. [‚Ä¶]<p>My implementation of the binary extended Euclidean algorithm is quite a bit slower and not recommended. I expect that it should be possible to optimize it further.<p><em>‚Äì Lemire</em></blockquote><p>That‚Äôs a big shame, because the extended Euclidean algorithm can be optimized in a very similar manner, and the underlying ideas were described <a href=https://eprint.iacr.org/2020/972.pdf>in a 2020 paper</a>. It‚Äôs probably not well-known because the paper focuses on constant-time evaluation and long arithmetic, so people might have assumed it‚Äôs irrelevant.<p>I‚Äôm hoping to bring justice to the extended Stein‚Äôs algorithm with this post. I‚Äôll cover how the algorithm works, its limitations, some optimizations compared to Pornin‚Äôs paper, and potential further improvements.<p>My implementation is <a href=https://github.com/purplesyringa/mod2k/blob/104603af3866ac274073a5b2af28f7a41550add1/src/xgcd.rs>available on GitHub</a> as part of a Rust modular arithmetic library.<p class=next-group><span aria-level=3 class=side-header role=heading><span>Disclaimer</span></span>The textbook algorithm can be used not only to compute inverses, but also to solve <a href=https://en.wikipedia.org/wiki/Diophantine_equation>linear Diophantine equations</a>. I will focus on the former in this post, since that‚Äôs where the optimizations shine at. I‚Äôll briefly cover the general case at the end of the post.<div class=aside-group><aside><p>Lemire‚Äôs benchmark seems to be skewed by the choice of the compiler (GCC vs Clang), its version (Clang 18 vs Clang 21), optimization flags (<code>-O2</code> vs <code>-O3</code>), the microarchitecture (Haswell vs Ice Lake vs Zen 2), and minutiae of the benchmarking code. Results don‚Äôt make much sense mathematically and look disproportionately affected by microarchitectural conditions.<p>If you want to get the fastest implementation, I suggest you inspect the assembly more closely than me, because I have no idea what‚Äôs going on.</aside><p>I will refrain from posting precise benchmarking data, because something strange is going on with the Lemire‚Äôs results and I don‚Äôt want to add to the mess. I‚Äôve measured that my implementation of the algorithm is <eq><math><mn>1.3</mn></math></eq> ‚Äì <eq><math><mn>2</mn></math></eq> times faster than the textbook implementation on average, even on M1, but you may see a completely different picture if your compiler produces slightly different codegen.</div><p class=next-group><span aria-level=3 class=side-header role=heading><span>GCD</span></span>Let‚Äôs start with the algorithm for computing the GCD of <eq><math><mi>a</mi></math></eq> and <eq><math><mi>b</mi></math></eq>. Suppose for now that <eq><math><mi>b</mi></math></eq> is odd. Here‚Äôs the core idea:<ul><li>If <eq><math><mi>a</mi></math></eq> is divisible by <eq><math><msup><mn>2</mn><mi>k</mi></msup></math></eq>, this factor can be removed: <eq><math><mrow><mrow><mtext></mtext><mi>gcd</mi></mrow><mo form=prefix stretchy=false>(</mo><msup><mn>2</mn><mi>k</mi></msup><mi>a</mi><mo separator=true>,</mo><mi>b</mi><mo form=postfix stretchy=false>)</mo><mo>=</mo></mrow><mrow><mrow><mtext></mtext><mi>gcd</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>a</mi><mo separator=true>,</mo><mi>b</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq>. This decreases the bit length of <eq><math><mi>a</mi></math></eq> by at least <eq><math><mn>1</mn></math></eq>, guaranteeing <eq><math><mrow><mi class=mathcal>ùí™</mi><mo form=prefix stretchy=false>(</mo><mrow><mi>log</mi><mo>‚Å°</mo><mspace width=0.1667em></mspace></mrow><mi>a</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> time complexity if we can apply this reduction consistently.<li>If both <eq><math><mi>a</mi></math></eq> and <eq><math><mi>b</mi></math></eq> are odd, rewriting <eq><math><mrow><mrow><mtext></mtext><mi>gcd</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>a</mi><mo separator=true>,</mo><mi>b</mi><mo form=postfix stretchy=false>)</mo><mo>=</mo></mrow><mrow><mrow><mtext></mtext><mi>gcd</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>a</mi><mo>‚àí</mo><mi>b</mi><mo separator=true>,</mo><mi>b</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq> guarantees <eq><math><mrow><msup><mi>a</mi><mo class=tml-prime lspace=0em rspace=0em>‚Ä≤</mo></msup><mo>=</mo></mrow><mrow><mi>a</mi><mo>‚àí</mo></mrow><mrow><mi>b</mi></mrow></math></eq> will be even and reducible on the next iteration. To avoid negative integers, swap <eq><math><mi>a</mi></math></eq> and <eq><math><mi>b</mi></math></eq> if <eq><math><mrow><mi>a</mi><mo><</mo></mrow><mrow><mi>b</mi></mrow></math></eq> beforehand; new <eq><math><mi>b</mi></math></eq> remains odd because <eq><math><mi>a</mi></math></eq> was odd.</ul><p>The implementation is very short:<pre><code class=language-rust><span class=hljs-keyword>while</span> a != <span class=hljs-number>0</span> {
    a >>= a.<span class="hljs-title function_ invoke__">trailing_zeros</span>();
    <span class=hljs-keyword>if</span> a < b {
        (a, b) = (b, a);
    }
    a -= b;
}
<span class=hljs-keyword>return</span> b;
</code></pre><p>If the initial <eq><math><mi>b</mi></math></eq> is not guaranteed to be odd, some adjustments are necessary:<pre><code class=language-rust><span class=hljs-keyword>let</span> <span class=hljs-variable>shift</span> = (a | b).<span class="hljs-title function_ invoke__">trailing_zeros</span>(); <span class=hljs-comment>// == min(a.trailing_zeros(), b.trailing_zeros())</span>
b >>= b.<span class="hljs-title function_ invoke__">trailing_zeros</span>();
<span class=hljs-comment>/* loop from the previous snippet */</span>
<span class=hljs-keyword>return</span> b << shift;
</code></pre><p>But for modular inversion, the modulus is usually odd, so I won‚Äôt dwell on this.<p class=next-group><span aria-level=3 class=side-header role=heading><span>Optimizations</span></span>This covers the general structure of the algorithm, but some optimizations are crucial for getting good performance.<p>The conditional swap should be compiled to branchless code to avoid branch misprediction. Compiler hints like <a href=https://clang.llvm.org/docs/LanguageExtensions.html#builtin-unpredictable>__builtin_unpredictable</a> or <a href=https://doc.rust-lang.org/stable/core/hint/fn.select_unpredictable.html>core::hint::select_unpredictable</a> may be useful.<p>The loop has a high latency because <code>trailing_zeros</code>, <code>>>=</code>, <code>if</code>, and <code>-=</code> are computed sequentially. But since <code>(-a).trailing_zeros() == a.trailing_zeros()</code>, <code>a.trailing_zeros()</code> can in principle be computed before the swap on the previous iteration:<pre><code class=language-rust><span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>q</span> = a.<span class="hljs-title function_ invoke__">trailing_zeros</span>();
<span class=hljs-keyword>while</span> a != <span class=hljs-number>0</span> {
    a >>= q;
    q = (a - b).<span class="hljs-title function_ invoke__">trailing_zeros</span>();
    <span class=hljs-keyword>if</span> a < b {
        (a, b) = (b - a, a);
    } <span class=hljs-keyword>else</span> {
        (a, b) = (a - b, b);
    }
}
</code></pre><p>This brings the latency down to 3 operations: <code>>>=</code>; <code>a - b</code> and <code>b - a</code> computed in parallel; <code>trailing_zeros</code> and <code>if</code> computed in parallel. It also slightly increases the number of operations (computing <code>b - a</code> and <code>a - b</code> and only using one), but the tradeoff pays off.<p>Pay close attention to <code>trailing_zeros</code> if you‚Äôre implementing this in C. The algorithm can invoke it with a zero input on the last iteration. This is well-defined in Rust, which maps <eq><math><mn>0</mn></math></eq> to the bit width of the data type, but in C <code>__builtin_clz(0)</code> is UB. Use <code>__builtin_clzg</code> to avoid issues. In C++, <code>std::countr_zero(0)</code> is well-defined.<blockquote><p>GCC <a href=https://gcc.gnu.org/onlinedocs/gcc/Bit-Operation-Builtins.html>documents</a> <code>__builtin_clz(0)</code> as having an ‚Äúundefined result‚Äù, so I initially assumed it means an indeterminate value. In reality, <a href=https://gcc.gnu.org/bugzilla/show_bug.cgi?id=116989>GCC maintainers consider it UB</a> and <a href=https://clang.llvm.org/docs/LanguageExtensions.html#builtin-clzg-and-builtin-ctzg>LLVM documents it as UB</a>‚Ä¶ but the optimizers seem to model it exactly like an indeterminate value? (e.g. LLVM considers <code>@llvm.cttz(0)</code> to produce <code>poison</code>) This is frankly ridiculous, someone do something about it.</blockquote><div class=aside-group><aside><p>Here‚Äôs a linear algebraic restatement if you want a different perspective.<p>Weighted sums are actually <a href=https://en.wikipedia.org/wiki/Linear_combination>linear combinations</a>, and the coefficients can be tracked because subtraction and division by a constant are both <a href=https://en.wikipedia.org/wiki/Linear_map>linear operators</a>.<p>The algorithm tracks a matrix <eq><math><mi>A</mi></math></eq> of a specific form, mapping <eq><math><mrow><mo form=prefix stretchy=false>(</mo><msub><mi>a</mi><mn>0</mn></msub><mspace width=0.1667em></mspace><msub><mi>b</mi><mn>0</mn></msub><msup><mo form=postfix stretchy=false>)</mo><mi>T</mi></msup></mrow></math></eq> to <eq><math><mrow><mo form=prefix stretchy=false>(</mo><mi>a</mi><mspace width=0.1667em></mspace><mi>b</mi><msup><mo form=postfix stretchy=false>)</mo><mi>T</mi></msup></mrow></math></eq>.<p>Treating values as opaque, <eq><math><mi>a</mi></math></eq> and <eq><math><mi>b</mi></math></eq> are elements of a <a href=https://en.wikipedia.org/wiki/Vector_space>vector space</a> with <a href=https://en.wikipedia.org/wiki/Basis_(linear_algebra)>basis</a> <eq><math><mrow><mo form=prefix stretchy=false>‚ü®</mo><msub><mi>a</mi><mn>0</mn></msub><mo separator=true>,</mo><msub><mi>b</mi><mn>0</mn></msub><mo form=postfix stretchy=false>‚ü©</mo></mrow></math></eq>, <eq><math><mi>A</mi></math></eq> is a <a href=https://en.wikipedia.org/wiki/Change_of_basis>change-of-basis matrix</a>, and the integers <eq><math><mi>a</mi></math></eq> and <eq><math><mi>b</mi></math></eq> in code are values of some <a href=https://en.wikipedia.org/wiki/Linear_form>evaluation functional</a> at <eq><math><mi>a</mi></math></eq> and <eq><math><mi>b</mi></math></eq>.<p>Simplifying <eq><math><mrow><mo form=prefix stretchy=false>‚ü®</mo><msub><mi>a</mi><mn>0</mn></msub><mo separator=true>,</mo><msub><mi>b</mi><mn>0</mn></msub><mo form=postfix stretchy=false>‚ü©</mo></mrow></math></eq> to <eq><math><mrow><mo form=prefix stretchy=false>‚ü®</mo><mn>0</mn><mo separator=true>,</mo><mrow><mtext></mtext><mi>gcd</mi></mrow><mo form=prefix stretchy=false>(</mo><msub><mi>a</mi><mn>0</mn></msub><mo separator=true>,</mo><msub><mi>b</mi><mn>0</mn></msub><mo form=postfix stretchy=false>)</mo><mo form=postfix stretchy=false>‚ü©</mo></mrow></math></eq> is essentially <a href=https://en.wikipedia.org/wiki/Lattice_reduction>lattice reduction</a>, which can be seen as a generalization of GCD to higher-dimensional spaces.</aside><p class=next-group><span aria-level=3 class=side-header role=heading><span>Extending</span></span>You might be wondering how this algorithm is related to modular inversion.<p>The trick is to express the values of <eq><math><mi>a</mi></math></eq> and <eq><math><mi>b</mi></math></eq> at each point as weighted sums of the original <eq><math><mi>a</mi></math></eq> and <eq><math><mi>b</mi></math></eq> (denoted <eq><math><mrow><msub><mi>a</mi><mn>0</mn></msub><mo separator=true>,</mo></mrow><mrow><msub><mi>b</mi><mn>0</mn></msub></mrow></math></eq>) with some coefficients <eq><math><mrow><msub><mi>k</mi><mi>i</mi></msub><mo separator=true>,</mo></mrow><mrow><msub><mi>l</mi><mi>i</mi></msub></mrow></math></eq>:<section><eqn><math style="display:block math;"class=tml-display display=block><mrow><mo fence=true form=prefix>{</mo><mtable><mtr><mtd style="padding:0.5ex 0em 0.5ex 0em;"class=tml-left><mrow><mi>a</mi><mo>=</mo><msub><mi>k</mi><mn>0</mn></msub><msub><mi>a</mi><mn>0</mn></msub><mo>+</mo><msub><mi>l</mi><mn>0</mn></msub><msub><mi>b</mi><mn>0</mn></msub></mrow></mtd></mtr><mtr><mtd style="padding:0.5ex 0em 0.5ex 0em;"class=tml-left><mrow><mi>b</mi><mo>=</mo><msub><mi>k</mi><mn>1</mn></msub><msub><mi>a</mi><mn>0</mn></msub><mo>+</mo><msub><mi>l</mi><mn>1</mn></msub><msub><mi>b</mi><mn>0</mn></msub></mrow></mtd></mtr></mtable><mo fence=true form=postfix></mo></mrow></math></eqn></section><p>If <eq><math><msub><mi>a</mi><mn>0</mn></msub></math></eq> is invertible modulo <eq><math><msub><mi>b</mi><mn>0</mn></msub></math></eq>, their GCD is <eq><math><mn>1</mn></math></eq>, and so at the end of the algorithm <eq><math><mrow><mi>b</mi><mo>=</mo></mrow><mrow><mn>1</mn></mrow></math></eq>. This gives us:<section><eqn><math style="display:block math;"class=tml-display display=block><mrow><msub><mi>k</mi><mn>1</mn></msub><msub><mi>a</mi><mn>0</mn></msub><mo>+</mo><msub><mi>l</mi><mn>1</mn></msub><msub><mi>b</mi><mn>0</mn></msub><mo>=</mo><mn>1</mn><mspace width=0.2778em></mspace><mo stretchy=false>‚üπ</mo><mspace width=0.2778em></mspace><msub><mi>k</mi><mn>1</mn></msub><msub><mi>a</mi><mn>0</mn></msub><mo>=</mo><mn>1</mn><mo></mo><mspace width=1em></mspace><mo form=prefix stretchy=false>(</mo><mrow><mtext></mtext><mi>mod</mi></mrow><mspace width=0.3333em></mspace><msub><mi>b</mi><mn>0</mn></msub><mo form=postfix stretchy=false>)</mo></mrow></math></eqn></section><p>That is, <eq><math><msub><mi>k</mi><mn>1</mn></msub></math></eq> is the inverse of <eq><math><msub><mi>a</mi><mn>0</mn></msub></math></eq> modulo <eq><math><msub><mi>b</mi><mn>0</mn></msub></math></eq>. So all we need to do is track the coefficients across iterations. We start with:<section><eqn><math style="display:block math;"class=tml-display display=block><mrow><mo fence=true form=prefix>{</mo><mtable><mtr><mtd style="padding:0.5ex 0em 0.5ex 0em;"class=tml-left><mrow><mi>a</mi><mo>=</mo><msub><mi>a</mi><mn>0</mn></msub><mo>=</mo><mn>1</mn><mspace width=0.1667em></mspace><msub><mi>a</mi><mn>0</mn></msub><mo>+</mo><mn>0</mn><mspace width=0.1667em></mspace><msub><mi>b</mi><mn>0</mn></msub></mrow></mtd></mtr><mtr><mtd style="padding:0.5ex 0em 0.5ex 0em;"class=tml-left><mrow><mi>b</mi><mo>=</mo><msub><mi>b</mi><mn>0</mn></msub><mo>=</mo><mn>0</mn><mspace width=0.1667em></mspace><msub><mi>a</mi><mn>0</mn></msub><mo>+</mo><mn>1</mn><mspace width=0.1667em></mspace><msub><mi>b</mi><mn>0</mn></msub></mrow></mtd></mtr></mtable><mo fence=true form=postfix></mo></mrow></math></eqn></section><p>When <eq><math><mi>a</mi></math></eq> is divided by <eq><math><msup><mn>2</mn><mi>q</mi></msup></math></eq>, the coefficients are divided by the same value:<section><eqn><math style="display:block math;"class=tml-display display=block><mrow><mi>a</mi><mo>=</mo><msub><mi>k</mi><mn>0</mn></msub><msub><mi>a</mi><mn>0</mn></msub><mo>+</mo><msub><mi>l</mi><mn>0</mn></msub><msub><mi>b</mi><mn>0</mn></msub><mspace width=0.2778em></mspace><mo stretchy=false>‚üπ</mo><mspace width=0.2778em></mspace><mfrac><mi>a</mi><msup><mn>2</mn><mi>q</mi></msup></mfrac><mo>=</mo><mfrac><msub><mi>k</mi><mn>0</mn></msub><msup><mn>2</mn><mi>q</mi></msup></mfrac><msub><mi>a</mi><mn>0</mn></msub><mo>+</mo><mfrac><msub><mi>l</mi><mn>0</mn></msub><msup><mn>2</mn><mi>q</mi></msup></mfrac><msub><mi>b</mi><mn>0</mn></msub></mrow></math></eqn></section><p>When <eq><math><mi>a</mi></math></eq> and <eq><math><mi>b</mi></math></eq> are swapped, the pairs <eq><math><mrow><mo form=prefix stretchy=false>(</mo><msub><mi>k</mi><mn>0</mn></msub><mo separator=true>,</mo><msub><mi>l</mi><mn>0</mn></msub><mo form=postfix stretchy=false>)</mo></mrow></math></eq> and <eq><math><mrow><mo form=prefix stretchy=false>(</mo><msub><mi>k</mi><mn>1</mn></msub><mo separator=true>,</mo><msub><mi>l</mi><mn>1</mn></msub><mo form=postfix stretchy=false>)</mo></mrow></math></eq> are swapped.<p>When <eq><math><mi>b</mi></math></eq> is subtracted from <eq><math><mi>a</mi></math></eq>, the coefficients are subtracted:<section><eqn><math style="display:block math;"class=tml-display display=block><mrow><mi>a</mi><mo>‚àí</mo><mi>b</mi><mo>=</mo><mo form=prefix stretchy=false>(</mo><msub><mi>k</mi><mn>0</mn></msub><mo>‚àí</mo><msub><mi>k</mi><mn>1</mn></msub><mo form=postfix stretchy=false>)</mo><msub><mi>a</mi><mn>0</mn></msub><mo>+</mo><mo form=prefix stretchy=false>(</mo><msub><mi>l</mi><mn>0</mn></msub><mo>‚àí</mo><msub><mi>l</mi><mn>1</mn></msub><mo form=postfix stretchy=false>)</mo><msub><mi>b</mi><mn>0</mn></msub></mrow></math></eqn></section><p>In other words, whatever we do to <eq><math><mi>a</mi></math></eq> and <eq><math><mi>b</mi></math></eq>, we also do to the coefficient pairs <eq><math><mrow><mo form=prefix stretchy=false>(</mo><msub><mi>k</mi><mn>0</mn></msub><mo separator=true>,</mo><msub><mi>l</mi><mn>0</mn></msub><mo form=postfix stretchy=false>)</mo></mrow></math></eq>.</div><p class=next-group><span aria-level=3 class=side-header role=heading><span>Limitations</span></span>Implementation attempts quickly reveal a problem: coefficients are not necessarily divisible by <eq><math><msup><mn>2</mn><mi>q</mi></msup></math></eq>, so it‚Äôs not clear how to represent them. Surely not with floats.<p>This is actually a core difference between Stein‚Äôs algorithm and the textbook Euclidean algorithm, which is implemented as <eq><math><mrow><mrow><mtext></mtext><mi>gcd</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>a</mi><mo separator=true>,</mo><mi>b</mi><mo form=postfix stretchy=false>)</mo><mo>=</mo></mrow><mrow><mrow><mtext></mtext><mi>gcd</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>b</mi><mo separator=true>,</mo><mi>a</mi><mo lspace=0.2222em rspace=0.2222em>mod</mo><mi>b</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq>.<p>The Euclidean algorithm uses division (<code>q = a / b</code>), but only to compute constant factors. The values are updated with subtraction and multiplication alone (<code>a -= b * q</code>). Stein‚Äôs algorithm divides values (<code>a /= 2^q</code>), causing non-integer coefficients.<p>This is likely why the extended Stein‚Äôs algorithm is unpopular. We‚Äôll use tricks tailored to modular inverse, but the general-purpose case covered at the end of the post essentially boils down to ‚Äúcompute modular inverse and post-process‚Äù. I believe it can still be faster than the textbook implementation, but I haven‚Äôt tested it.<p class=next-group><span aria-level=3 class=side-header role=heading><span>Fractions</span></span>We can track coefficients as fractions to stay in integers. The most efficient approach uses the same denominator <eq><math><msup><mn>2</mn><mi>p</mi></msup></math></eq> for all variables:<section><eqn><math style="display:block math;"class=tml-display display=block><mrow><mo fence=true form=prefix>{</mo><mtable><mtr><mtd style="padding:0.5ex 0em 0.5ex 0em;"class=tml-left><mrow><mi>a</mi><mo>=</mo><msup><mn>2</mn><mrow><mo form=prefix lspace=0em rspace=0em stretchy=false>‚àí</mo><mi>p</mi></mrow></msup><mspace width=0.1667em></mspace><mo form=prefix stretchy=false>(</mo><msub><mi>k</mi><mn>0</mn></msub><msub><mi>a</mi><mn>0</mn></msub><mo>+</mo><msub><mi>l</mi><mn>0</mn></msub><msub><mi>b</mi><mn>0</mn></msub><mo form=postfix stretchy=false>)</mo></mrow></mtd></mtr><mtr><mtd style="padding:0.5ex 0em 0.5ex 0em;"class=tml-left><mrow><mi>b</mi><mo>=</mo><msup><mn>2</mn><mrow><mo form=prefix lspace=0em rspace=0em stretchy=false>‚àí</mo><mi>p</mi></mrow></msup><mspace width=0.1667em></mspace><mo form=prefix stretchy=false>(</mo><msub><mi>k</mi><mn>1</mn></msub><msub><mi>a</mi><mn>0</mn></msub><mo>+</mo><msub><mi>l</mi><mn>1</mn></msub><msub><mi>b</mi><mn>0</mn></msub><mo form=postfix stretchy=false>)</mo></mrow></mtd></mtr></mtable><mo fence=true form=postfix></mo></mrow></math></eqn></section><p>We start with <eq><math><mrow><mi>p</mi><mo>=</mo></mrow><mrow><mn>0</mn></mrow></math></eq>. Instead of dividing <eq><math><mrow><msub><mi>k</mi><mn>0</mn></msub><mo separator=true>,</mo></mrow><mrow><msub><mi>l</mi><mn>0</mn></msub></mrow></math></eq> by <eq><math><msup><mn>2</mn><mi>q</mi></msup></math></eq>, we increase <eq><math><mi>p</mi></math></eq> by <eq><math><mi>q</mi></math></eq> and multiply <eq><math><mrow><msub><mi>k</mi><mn>1</mn></msub><mo separator=true>,</mo></mrow><mrow><msub><mi>l</mi><mn>1</mn></msub></mrow></math></eq> by <eq><math><msup><mn>2</mn><mi>q</mi></msup></math></eq>. Subtraction can ignore <eq><math><mi>p</mi></math></eq> because all coefficients use the same precision.<p>This seems pointless at first, since we need to know <eq><math><mrow><msup><mn>2</mn><mrow><mo lspace=0em rspace=0em>‚àí</mo><mi>p</mi></mrow></msup><mo lspace=0.2222em rspace=0.2222em>mod</mo></mrow><mrow><msub><mi>b</mi><mn>0</mn></msub></mrow></math></eq>, but if the modulus is fixed, we can precompute it. Each iteration reduces the total bit length of <eq><math><mi>a</mi></math></eq> and <eq><math><mi>b</mi></math></eq> by at least <eq><math><mi>q</mi></math></eq>, and after the last right-shift <eq><math><mrow><mi>a</mi><mo separator=true>,</mo></mrow><mrow><mi>b</mi><mo>‚â†</mo></mrow><mrow><mn>0</mn></mrow></math></eq>, so if the input numbers fit in <eq><math><mi>k</mi></math></eq> bits, the sum of <eq><math><mi>q</mi></math></eq> (and thus <eq><math><mi>p</mi></math></eq>) is limited by <eq><math><mrow><mn>2</mn><mi>k</mi><mo>‚àí</mo></mrow><mrow><mn>2</mn></mrow></math></eq>. This means that we can increase precision to <eq><math><mrow><mn>2</mn><mi>k</mi><mo>‚àí</mo></mrow><mrow><mn>2</mn></mrow></math></eq> at the end and use a single precomputed value <eq><math><mrow><msup><mn>2</mn><mrow><mo lspace=0em rspace=0em>‚àí</mo><mo form=prefix stretchy=false>(</mo><mn>2</mn><mi>k</mi><mo>‚àí</mo><mn>2</mn><mo form=postfix lspace=0em rspace=0em stretchy=false>)</mo></mrow></msup><mo lspace=0.2222em rspace=0.2222em>mod</mo></mrow><mrow><msub><mi>b</mi><mn>0</mn></msub></mrow></math></eq>.<p>The multitude of variables is getting confusing, so let‚Äôs simplify it. We‚Äôre looking for <eq><math><mrow><msub><mi>k</mi><mn>1</mn></msub><mo lspace=0.2222em rspace=0.2222em>mod</mo></mrow><mrow><msub><mi>b</mi><mn>0</mn></msub></mrow></math></eq> and don‚Äôt care about <eq><math><msub><mi>l</mi><mi>i</mi></msub></math></eq>, so tracking just <eq><math><msub><mi>k</mi><mn>0</mn></msub></math></eq> and <eq><math><msub><mi>k</mi><mn>1</mn></msub></math></eq> suffices. Let‚Äôs rename these variables to <eq><math><mi>u</mi></math></eq> and <eq><math><mi>v</mi></math></eq> respectively to get rid of indices. This gives us:<pre><code class=language-rust><span class=hljs-comment>// Example for 32-bit inputs (k = 32).</span>
<span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>u</span> = <span class=hljs-number>1</span>;
<span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>v</span> = <span class=hljs-number>0</span>;
<span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>p</span> = <span class=hljs-number>0</span>;
<span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>q</span> = a.<span class="hljs-title function_ invoke__">trailing_zeros</span>();
<span class=hljs-keyword>while</span> a != <span class=hljs-number>0</span> {
    a >>= q;
    v <<= q;
    p += q;

    q = (a - b).<span class="hljs-title function_ invoke__">trailing_zeros</span>();

    <span class=hljs-keyword>if</span> a < b {
        (a, b) = (b - a, a);
        (u, v) = (v, u);
    } <span class=hljs-keyword>else</span> {
        (a, b) = (a - b, b);
    }
    u -= v;
}
<span class=hljs-built_in>assert!</span>(b == <span class=hljs-number>1</span>, <span class=hljs-string>"not invertible"</span>);
v <<= <span class=hljs-number>62</span> - p;
<span class="hljs-title function_ invoke__">return</span> (v * inverse_of_2p62) % b0;
</code></pre><p>We don‚Äôt apply the latency-reducing trick to <eq><math><mi>u</mi></math></eq> and <eq><math><mi>v</mi></math></eq> because the latency is dominated by other calculations. Computing both <code>u - v</code> and <code>v - u</code> would most likely reduce performance, since we‚Äôre already pushing the CPU limit of parallel operations.<div class=aside-group><aside><p>Note that <eq><math><mi>u</mi></math></eq> is one bit longer than <eq><math><mi>v</mi></math></eq> at this point because <eq><math><mi>u</mi></math></eq> is increased at the end of the previous iteration, while <eq><math><mi>v</mi></math></eq> is increased at the beginning of the next iteration.</aside><p class=next-group><span aria-level=3 class=side-header role=heading><span>Types</span></span>It‚Äôs easy to prove by induction that at the beginning of each iteration,<section><eqn><math style="display:block math;"class=tml-display display=block><mrow><mo fence=true form=prefix>{</mo><mtable><mtr><mtd style="padding:0.5ex 0em 0.5ex 0em;"class=tml-left><mrow><mo>‚àí</mo><msup><mn>2</mn><mrow><mi>p</mi><mo>+</mo><mn>1</mn></mrow></msup><mo><</mo><mi>u</mi><mo><</mo><msup><mn>2</mn><mrow><mi>p</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow></mtd></mtr><mtr><mtd style="padding:0.5ex 0em 0.5ex 0em;"class=tml-left><mrow><mo>‚àí</mo><msup><mn>2</mn><mi>p</mi></msup><mo><</mo><mi>v</mi><mo>‚â§</mo><msup><mn>2</mn><mi>p</mi></msup></mrow></mtd></mtr></mtable><mo fence=true form=postfix></mo></mrow></math></eqn></section></div><p>This means that <eq><math><mi>u</mi></math></eq> and <eq><math><mi>v</mi></math></eq> fit in signed <eq><math><mrow><mi>p</mi><mo>+</mo></mrow><mrow><mn>2</mn></mrow></math></eq>-bit integers. Since <eq><math><mrow><mi>p</mi><mo>‚â§</mo></mrow><mrow><mn>2</mn><mi>k</mi><mo>‚àí</mo></mrow><mrow><mn>2</mn></mrow></math></eq>, that amounts to <eq><math><mrow><mn>2</mn><mi>k</mi></mrow></math></eq>-bit types, i.e. twice as wide as the input. And that‚Äôs a problem: while it works just fine for <eq><math><mn>32</mn></math></eq>-bit inputs, <eq><math><mn>64</mn></math></eq>-bit inputs require <code>i128</code> arithmetic, which slows down the algorithm considerably. We‚Äôll discuss what to about it in a bit.<p class=next-group><span aria-level=3 class=side-header role=heading><span>Montgomery</span></span>Before we do this, though, let‚Äôs finish the <eq><math><mn>32</mn></math></eq>-bit case. There‚Äôs just one thing left to improve: computing <eq><math><mrow><mi>v</mi><mo>‚ãÖ</mo></mrow><mrow><msup><mn>2</mn><mrow><mo form=prefix lspace=0em rspace=0em stretchy=false>‚àí</mo><mn>62</mn></mrow></msup><mo lspace=0.2222em rspace=0.2222em>mod</mo></mrow><mrow><msub><mi>b</mi><mn>0</mn></msub></mrow></math></eq>.<p>On the face of it, this is one multiplication and one reduction, but <a href=https://en.wikipedia.org/wiki/Montgomery_modular_multiplication>Montgomery multiplication</a> demonstrates that these operations can be performed faster together.<p>Assume for a moment that <eq><math><mi>v</mi></math></eq> is non-negative. The idea is to subtract a multiple of <eq><math><msub><mi>b</mi><mn>0</mn></msub></math></eq> from <eq><math><mi>v</mi></math></eq> such that the bottom <eq><math><mn>62</mn></math></eq> bits become zero, so that the remainder remains the same, but division by <eq><math><msup><mn>2</mn><mn>62</mn></msup></math></eq> can be performed with a shift. We‚Äôre looking for <eq><math><mi>t</mi></math></eq> such that<section><eqn><math style="display:block math;"class=tml-display display=block><mrow><mi>v</mi><mo>‚àí</mo><mi>t</mi><mo>‚ãÖ</mo><msub><mi>b</mi><mn>0</mn></msub><mo>=</mo><mn>0</mn><mo></mo><mspace width=1em></mspace><mo form=prefix stretchy=false>(</mo><mrow><mtext></mtext><mi>mod</mi></mrow><mspace width=0.3333em></mspace><msup><mn>2</mn><mn>62</mn></msup><mo form=postfix stretchy=false>)</mo></mrow></math></eqn></section><p>This is equivalent to <eq><math><mrow><mi>t</mi><mo>=</mo></mrow><mrow><mi>v</mi><mo>‚ãÖ</mo></mrow><mrow><msubsup><mi>b</mi><mn>0</mn><mrow><mo form=prefix lspace=0em rspace=0em stretchy=false>‚àí</mo><mn>1</mn></mrow></msubsup><mo></mo><mspace width=0.4444em></mspace><mo form=prefix stretchy=false>(</mo><mrow><mtext></mtext><mi>mod</mi></mrow><mspace width=0.3333em></mspace><msup><mn>2</mn><mn>62</mn></msup><mo form=postfix stretchy=false>)</mo></mrow></math></eq>, and by precomputing <eq><math><mrow><mi>j</mi><mo>=</mo></mrow><mrow><msubsup><mi>b</mi><mn>0</mn><mrow><mo form=prefix lspace=0em rspace=0em stretchy=false>‚àí</mo><mn>1</mn></mrow></msubsup><mo lspace=0.2222em rspace=0.2222em>mod</mo></mrow><mrow><msup><mn>2</mn><mn>62</mn></msup></mrow></math></eq>, we obtain <eq><math><mrow><mi>v</mi><mo>‚àí</mo></mrow><mrow><mo form=prefix stretchy=false>(</mo><mi>v</mi><mi>j</mi><mo lspace=0.2222em rspace=0.2222em>mod</mo><msup><mn>2</mn><mn>62</mn></msup><mo form=postfix stretchy=false>)</mo><msub><mi>b</mi><mn>0</mn></msub></mrow></math></eq> as the easily divisible value. Since <eq><math><mi>v</mi></math></eq> and <eq><math><mrow><mo form=prefix stretchy=false>(</mo><mi>v</mi><mi>j</mi><mo lspace=0.2222em rspace=0.2222em>mod</mo><msup><mn>2</mn><mn>62</mn></msup><mo form=postfix stretchy=false>)</mo><msub><mi>b</mi><mn>0</mn></msub></mrow></math></eq> have equal bottom <eq><math><mn>62</mn></math></eq> bits,<section><eqn><math style="display:block math;"class=tml-display display=block><mrow><mfrac><mrow><mi>v</mi><mo>‚àí</mo><mo form=prefix stretchy=false>(</mo><mi>v</mi><mi>j</mi><mo lspace=0.2222em rspace=0.2222em>mod</mo><msup><mn>2</mn><mn>62</mn></msup><mo form=postfix stretchy=false>)</mo><msub><mi>b</mi><mn>0</mn></msub></mrow><msup><mn>2</mn><mn>62</mn></msup></mfrac><mo>=</mo><mrow><mo fence=true form=prefix>‚åä</mo><mfrac><mi>v</mi><msup><mn>2</mn><mn>62</mn></msup></mfrac><mo fence=true form=postfix>‚åã</mo></mrow><mo>‚àí</mo><mrow><mo fence=true form=prefix>‚åä</mo><mfrac><mrow><mo form=prefix lspace=0em rspace=0em stretchy=false>(</mo><mi>v</mi><mi>j</mi><mo lspace=0.2222em rspace=0.2222em>mod</mo><msup><mn>2</mn><mn>62</mn></msup><mo form=postfix stretchy=false>)</mo><msub><mi>b</mi><mn>0</mn></msub></mrow><msup><mn>2</mn><mn>62</mn></msup></mfrac><mo fence=true form=postfix>‚åã</mo></mrow></mrow></math></eqn></section><p>We‚Äôve just found that <eq><math><mrow><mi>v</mi><mo>‚â§</mo></mrow><mrow><msup><mn>2</mn><mi>p</mi></msup><mo>‚â§</mo></mrow><mrow><msup><mn>2</mn><mn>62</mn></msup></mrow></math></eq>, so unless <eq><math><mrow><mi>v</mi><mo>=</mo></mrow><mrow><msup><mn>2</mn><mn>62</mn></msup></mrow></math></eq> exactly, this is just<section><eqn><math style="display:block math;"class=tml-display display=block><mrow><mo>‚àí</mo><mrow><mo fence=true form=prefix>‚åä</mo><mfrac><mrow><mo form=prefix lspace=0em rspace=0em stretchy=false>(</mo><mi>v</mi><mi>j</mi><mo lspace=0.2222em rspace=0.2222em>mod</mo><msup><mn>2</mn><mn>62</mn></msup><mo form=postfix stretchy=false>)</mo><msub><mi>b</mi><mn>0</mn></msub></mrow><msup><mn>2</mn><mn>62</mn></msup></mfrac><mo fence=true form=postfix>‚åã</mo></mrow><mo>=</mo><mo form=prefix stretchy=false>‚àí</mo><mrow><mo fence=true form=prefix>‚åä</mo><mfrac><mrow><mo form=prefix lspace=0em rspace=0em stretchy=false>(</mo><mi>v</mi><mo form=prefix stretchy=false>(</mo><mn>4</mn><mi>j</mi><mo form=postfix stretchy=false>)</mo><mo lspace=0.2222em rspace=0.2222em>mod</mo><msup><mn>2</mn><mn>64</mn></msup><mo form=postfix stretchy=false>)</mo><msub><mi>b</mi><mn>0</mn></msub></mrow><msup><mn>2</mn><mn>64</mn></msup></mfrac><mo fence=true form=postfix>‚åã</mo></mrow></mrow></math></eqn></section><p>This number is in range <eq><math><mrow><mo form=prefix stretchy=false>[</mo><mo form=prefix stretchy=false>‚àí</mo><msub><mi>b</mi><mn>0</mn></msub><mo>+</mo><mn>1</mn><mo separator=true>;</mo><mn>0</mn><mo form=postfix stretchy=false>]</mo></mrow></math></eq>. We know that <eq><math><mn>0</mn></math></eq> can never be an inverse, so it‚Äôs actually <eq><math><mrow><mo form=prefix stretchy=false>[</mo><mo form=prefix stretchy=false>‚àí</mo><msub><mi>b</mi><mn>0</mn></msub><mo>+</mo><mn>1</mn><mo separator=true>;</mo><mo form=prefix stretchy=false>‚àí</mo><mn>1</mn><mo form=postfix stretchy=false>]</mo></mrow></math></eq>, and by adding <eq><math><msub><mi>b</mi><mn>0</mn></msub></math></eq>, we obtain the exact remainder. This can be computed with only two multiplications and some glue:<pre><code class=language-rust><span class=hljs-keyword>fn</span> <span class="hljs-title function_">redc62</span>(v: <span class=hljs-type>i64</span>) <span class=hljs-punctuation>-></span> <span class=hljs-type>u32</span> {
    <span class=hljs-keyword>if</span> v == (<span class=hljs-number>1</span> << <span class=hljs-number>62</span>) {
        <span class=hljs-number>1</span>
    } <span class=hljs-keyword>else</span> {
        <span class=hljs-keyword>let</span> <span class=hljs-variable>x</span> = v.<span class="hljs-title function_ invoke__">unsigned_abs</span>().<span class="hljs-title function_ invoke__">wrapping_mul</span>(j << <span class=hljs-number>2</span>).<span class="hljs-title function_ invoke__">widening_mul</span>(b0 <span class=hljs-keyword>as</span> <span class=hljs-type>u64</span>).<span class=hljs-number>1</span> <span class=hljs-keyword>as</span> <span class=hljs-type>u32</span>;
        <span class=hljs-keyword>if</span> v > <span class=hljs-number>0</span> { b0 - x } <span class=hljs-keyword>else</span> { x }
    }
}
</code></pre><p>That‚Äôs it for <eq><math><mn>32</mn></math></eq>-bit and smaller inputs. Yay! Buy yourself a cupcake.<p class=next-group><span aria-level=3 class=side-header role=heading><span>64-bit inputs</span></span>For <eq><math><mn>64</mn></math></eq>-bit inputs, coefficients only fit in <code>i128</code>. This makes each operation twice as slow. We can reduce <eq><math><mi>u</mi></math></eq> and <eq><math><mi>v</mi></math></eq> modulo <eq><math><msub><mi>b</mi><mn>0</mn></msub></math></eq> on each iteration so that coefficients fit in <eq><math><mn>64</mn></math></eq> bits, since we only need <eq><math><mrow><mi>v</mi><mo lspace=0.2222em rspace=0.2222em>mod</mo></mrow><mrow><msub><mi>b</mi><mn>0</mn></msub></mrow></math></eq>, but this tanks performance too.<p>Hmm. Notice that at the beginning of the algorithm, <eq><math><mi>u</mi></math></eq> and <eq><math><mi>v</mi></math></eq> fit in <eq><math><mn>1</mn></math></eq> bit and then grow slowly. Only once their length exceeds <eq><math><mn>64</mn></math></eq> bits do we need long integers. What if we could somehow reset the length every few iterations, so that <eq><math><mn>64</mn></math></eq>-bit integers suffice?<p>Just like <eq><math><mi>a</mi></math></eq> and <eq><math><mi>b</mi></math></eq> can be represented as weighted sums of <eq><math><mrow><msub><mi>a</mi><mn>0</mn></msub><mo separator=true>,</mo></mrow><mrow><msub><mi>b</mi><mn>0</mn></msub></mrow></math></eq>, <eq><math><mi>u</mi></math></eq> and <eq><math><mi>v</mi></math></eq> can be represented as weighted sums of their earlier versions <eq><math><mrow><msub><mi>u</mi><mn>0</mn></msub><mo separator=true>,</mo></mrow><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow></math></eq>:<section><eqn><math style="display:block math;"class=tml-display display=block><mrow><mo fence=true form=prefix>{</mo><mtable><mtr><mtd style="padding:0.5ex 0em 0.5ex 0em;"class=tml-left><mrow><mi>u</mi><mo>=</mo><msub><mi>f</mi><mn>0</mn></msub><msub><mi>u</mi><mn>0</mn></msub><mo>+</mo><msub><mi>g</mi><mn>0</mn></msub><msub><mi>v</mi><mn>0</mn></msub></mrow></mtd></mtr><mtr><mtd style="padding:0.5ex 0em 0.5ex 0em;"class=tml-left><mrow><mi>v</mi><mo>=</mo><msub><mi>f</mi><mn>1</mn></msub><msub><mi>u</mi><mn>0</mn></msub><mo>+</mo><msub><mi>g</mi><mn>1</mn></msub><msub><mi>v</mi><mn>0</mn></msub></mrow></mtd></mtr></mtable><mo fence=true form=postfix></mo></mrow></math></eqn></section><p>The trick is to save <eq><math><mrow><msub><mi>u</mi><mn>0</mn></msub><mo separator=true>,</mo></mrow><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow></math></eq> and update short coefficients <eq><math><mrow><msub><mi>f</mi><mi>i</mi></msub><mo separator=true>,</mo></mrow><mrow><msub><mi>g</mi><mi>i</mi></msub></mrow></math></eq> instead of long values <eq><math><mrow><mi>u</mi><mo separator=true>,</mo></mrow><mrow><mi>v</mi></mrow></math></eq> in the loop. We start with <eq><math><mrow><msub><mi>u</mi><mn>0</mn></msub><mo>=</mo></mrow><mrow><mn>1</mn><mo separator=true>,</mo></mrow><mrow><msub><mi>v</mi><mn>0</mn></msub><mo>=</mo></mrow><mrow><mn>0</mn></mrow></math></eq> and trivial coefficients:<section><eqn><math style="display:block math;"class=tml-display display=block><mrow><mo fence=true form=prefix>{</mo><mtable><mtr><mtd style="padding:0.5ex 0em 0.5ex 0em;"class=tml-left><mrow><mi>u</mi><mo>=</mo><msub><mi>u</mi><mn>0</mn></msub><mo>=</mo><mn>1</mn><mspace width=0.1667em></mspace><msub><mi>u</mi><mn>0</mn></msub><mo>+</mo><mn>0</mn><mspace width=0.1667em></mspace><msub><mi>v</mi><mn>0</mn></msub></mrow></mtd></mtr><mtr><mtd style="padding:0.5ex 0em 0.5ex 0em;"class=tml-left><mrow><mi>v</mi><mo>=</mo><msub><mi>v</mi><mn>0</mn></msub><mo>=</mo><mn>0</mn><mspace width=0.1667em></mspace><msub><mi>u</mi><mn>0</mn></msub><mo>+</mo><mn>1</mn><mspace width=0.1667em></mspace><msub><mi>v</mi><mn>0</mn></msub></mrow></mtd></mtr></mtable><mo fence=true form=postfix></mo></mrow></math></eqn></section><p>When the coefficients <eq><math><mrow><msub><mi>f</mi><mi>i</mi></msub><mo separator=true>,</mo></mrow><mrow><msub><mi>g</mi><mi>i</mi></msub></mrow></math></eq> grow past <eq><math><mn>64</mn></math></eq> bits, we pause, compute <eq><math><mrow><mi>u</mi><mo separator=true>,</mo></mrow><mrow><mi>v</mi></mrow></math></eq> based on these formulas, replace <eq><math><mrow><msub><mi>u</mi><mn>0</mn></msub><mo separator=true>,</mo></mrow><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow></math></eq> with <eq><math><mrow><mi>u</mi><mo separator=true>,</mo></mrow><mrow><mi>v</mi></mrow></math></eq>, and reset the coefficients <eq><math><mrow><msub><mi>f</mi><mi>i</mi></msub><mo separator=true>,</mo></mrow><mrow><msub><mi>g</mi><mi>i</mi></msub></mrow></math></eq> back to trivial, bringing the length back to <eq><math><mn>1</mn></math></eq>.<pre><code class=language-rust><div class=expansible-code><input id=expansible1 type=checkbox><div class=highlighted><span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>u0</span> = <span class=hljs-number>1</span>;
<span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>v0</span> = <span class=hljs-number>0</span>;
<span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>q</span> = a.<span class="hljs-title function_ invoke__">trailing_zeros</span>();

<span class=hljs-keyword>while</span> a != <span class=hljs-number>0</span> {
    <span class=hljs-comment>// The coefficients relating (u, v) to (u0, v0).</span>
    <span class=hljs-keyword>let</span> <span class=hljs-variable>mut</span> (f0, g0) = (<span class=hljs-number>1</span>, <span class=hljs-number>0</span>);
    <span class=hljs-keyword>let</span> <span class=hljs-variable>mut</span> (f1, g1) = (<span class=hljs-number>0</span>, <span class=hljs-number>1</span>);
    <span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>p</span> = <span class=hljs-number>0</span>;

    <span class=hljs-comment>// Run the algorithm until p reaches the limit.</span>
    <span class=hljs-keyword>while</span> a != <span class=hljs-number>0</span> && p + q <= <span class=hljs-number>62</span> {
        a >>= q;
        f1 <<= q;
        g1 <<= q;
        p += q;

        q = (a - b).<span class="hljs-title function_ invoke__">trailing_zeros</span>();

        <span class=hljs-keyword>if</span> a < b {
            (a, b) = (b - a, a);
            (f0, f1) = (f1, f0);
            (g0, g1) = (g1, g0);
        } <span class=hljs-keyword>else</span> {
            (a, b) = (a - b, b);
        }
        f0 -= f1;
        g0 -= g1;
    }

    <span class=hljs-comment>// This section means different things depending on the reason the loop stopped:</span>
    <span class=hljs-comment>// - If we ran out of precision, this performs as much of the last action as possible and</span>
    <span class=hljs-comment>//   adjusts `q` so that the operation completes on the next iteration.</span>
    <span class=hljs-comment>// - If `a = 0`, this effectively raises the precision of f1/g1 to 62. It doesn't adjust</span>
    <span class=hljs-comment>//   `f0, g0` correctly, but this doesn't matter because `u` is not read on the exit path.</span>
    a >>= <span class=hljs-number>62</span> - p;
    f1 <<= <span class=hljs-number>62</span> - p;
    g1 <<= <span class=hljs-number>62</span> - p;
    q -= <span class=hljs-number>62</span> - p;

    <span class=hljs-comment>// Apply the coefficients.</span>
    <span class=hljs-keyword>let</span> <span class=hljs-variable>f0</span> = <span class="hljs-title function_ invoke__">redc62</span>(f0);
    <span class=hljs-keyword>let</span> <span class=hljs-variable>g0</span> = <span class="hljs-title function_ invoke__">redc62</span>(g0);
    <span class=hljs-keyword>let</span> <span class=hljs-variable>f1</span> = <span class="hljs-title function_ invoke__">redc62</span>(f1);
    <span class=hljs-keyword>let</span> <span class=hljs-variable>g1</span> = <span class="hljs-title function_ invoke__">redc62</span>(g1);
    (u0, v0) = ((f0 * u0 + g0 * v0) % b0, (f1 * u0 + g1 * v0) % b0);
}

<span class=hljs-built_in>assert!</span>(b == <span class=hljs-number>1</span>, <span class=hljs-string>"not invertible"</span>);
<span class=hljs-keyword>return</span> v0;
</div><label for=expansible1>Expand</label></div></code></pre><p class=next-group><span aria-level=3 class=side-header role=heading><span>Vectorization</span></span>The astute among you might realize this doesn‚Äôt improve much, since we went from updating two <eq><math><mn>128</mn></math></eq>-bit numbers in a loop to updating four <eq><math><mn>64</mn></math></eq>-bit numbers in a loop. But since we apply the exact same operations to <eq><math><msub><mi>f</mi><mi>i</mi></msub></math></eq> and <eq><math><msub><mi>g</mi><mi>i</mi></msub></math></eq>, we can vectorize them.<div class=aside-group><aside><p>This technique is called <a href=https://en.wikipedia.org/wiki/SWAR>SWAR</a>. It was invented before hardware SIMD support existed, but it‚Äôs useful to this day. I wrote about another application of SWAR <a href=../i-sped-up-serde-json-strings-by-20-percent/>here</a>.</aside><p>We can‚Äôt use SIMD because x86 doesn‚Äôt have <code>cmov</code> for vector registers, but we can decrease the coefficient length to <eq><math><mn>32</mn></math></eq> bits and pack two coefficients into one integer:</div><section><eqn><math style="display:block math;"class=tml-display display=block><mrow><mo fence=true form=prefix>{</mo><mtable><mtr><mtd style="padding:0.5ex 0em 0.5ex 0em;"class=tml-left><mrow><msub><mi>c</mi><mn>0</mn></msub><mo>=</mo><msub><mi>f</mi><mn>0</mn></msub><mo>+</mo><msup><mn>2</mn><mn>32</mn></msup><mspace width=0.1667em></mspace><msub><mi>g</mi><mn>0</mn></msub></mrow></mtd></mtr><mtr><mtd style="padding:0.5ex 0em 0.5ex 0em;"class=tml-left><mrow><msub><mi>c</mi><mn>1</mn></msub><mo>=</mo><msub><mi>f</mi><mn>1</mn></msub><mo>+</mo><msup><mn>2</mn><mn>32</mn></msup><mspace width=0.1667em></mspace><msub><mi>g</mi><mn>1</mn></msub></mrow></mtd></mtr></mtable><mo fence=true form=postfix></mo></mrow></math></eqn></section><p>This simplifies the inner loop to:<pre><code class=language-rust><span class=hljs-keyword>while</span> a != <span class=hljs-number>0</span> && p + q <= <span class=hljs-number>30</span> {
    a >>= q;
    c1 <<= q;
    p += q;

    q = (a - b).<span class="hljs-title function_ invoke__">trailing_zeros</span>();

    <span class=hljs-keyword>if</span> a < b {
        (a, b) = (b - a, a);
        (c0, c1) = (c1, c0);
    } <span class=hljs-keyword>else</span> {
        (a, b) = (a - b, b);
    }
    c0 -= c1;
}
</code></pre><p>Just like <eq><math><mi>u</mi></math></eq> and <eq><math><mi>v</mi></math></eq>, <eq><math><msub><mi>c</mi><mn>0</mn></msub></math></eq> and <eq><math><msub><mi>c</mi><mn>1</mn></msub></math></eq> take <eq><math><mrow><mi>p</mi><mo>+</mo></mrow><mrow><mn>2</mn></mrow></math></eq> bits, so we limit <eq><math><mi>p</mi></math></eq> by <eq><math><mrow><mn>32</mn><mo>‚àí</mo></mrow><mrow><mn>2</mn><mo>=</mo></mrow><mrow><mn>30</mn></mrow></math></eq>. But with care, we can squeeze out one more bit. Recall the inequalities:<section><eqn><math style="display:block math;"class=tml-display display=block><mrow><mo fence=true form=prefix>{</mo><mtable><mtr><mtd style="padding:0.5ex 0em 0.5ex 0em;"class=tml-left><mrow><mo>‚àí</mo><msup><mn>2</mn><mrow><mi>p</mi><mo>+</mo><mn>1</mn></mrow></msup><mo><</mo><mi>u</mi><mo><</mo><msup><mn>2</mn><mrow><mi>p</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow></mtd></mtr><mtr><mtd style="padding:0.5ex 0em 0.5ex 0em;"class=tml-left><mrow><mo>‚àí</mo><msup><mn>2</mn><mi>p</mi></msup><mo><</mo><mi>v</mi><mo>‚â§</mo><msup><mn>2</mn><mi>p</mi></msup></mrow></mtd></mtr></mtable><mo fence=true form=postfix></mo></mrow></math></eqn></section><p>Only <eq><math><mi>u</mi></math></eq> takes <eq><math><mrow><mi>p</mi><mo>+</mo></mrow><mrow><mn>2</mn></mrow></math></eq> bits. <eq><math><mi>v</mi></math></eq> fits in <eq><math><mrow><mi>p</mi><mo>+</mo></mrow><mrow><mn>1</mn></mrow></math></eq>, if barely: signed integer types represent the range <eq><math><mrow><mo form=prefix stretchy=false>[</mo><mo form=prefix stretchy=false>‚àí</mo><msup><mn>2</mn><mi>p</mi></msup><mo separator=true>;</mo><msup><mn>2</mn><mi>p</mi></msup><mo>‚àí</mo><mn>1</mn><mo form=postfix stretchy=false>]</mo></mrow></math></eq>, while this is <eq><math><mrow><mo form=prefix stretchy=false>[</mo><mo form=prefix stretchy=false>‚àí</mo><msup><mn>2</mn><mi>p</mi></msup><mo>+</mo><mn>1</mn><mo separator=true>;</mo><msup><mn>2</mn><mi>p</mi></msup><mo form=postfix stretchy=false>]</mo></mrow></math></eq>, but the number of distinct values is the same. So even if we run out of the <eq><math><mn>30</mn></math></eq>-bit limit, we can shift <eq><math><mi>v</mi></math></eq> once more. This affects the code after the inner loop:<pre><code class=language-rust><span class=hljs-comment>// 31 would be 30 without this optimization</span>
a >>= <span class=hljs-number>31</span> - p;
c1 <<= <span class=hljs-number>31</span> - p;
q -= <span class=hljs-number>31</span> - p;

<span class=hljs-keyword>let</span> (f0, g0) = <span class="hljs-title function_ invoke__">parse_coefficients</span>(c0);
<span class=hljs-keyword>let</span> (f1, g1) = <span class="hljs-title function_ invoke__">parse_coefficients</span>(c1);
<span class=hljs-keyword>let</span> <span class=hljs-variable>f0</span> = <span class="hljs-title function_ invoke__">redc31</span>(f0);
<span class=hljs-keyword>let</span> <span class=hljs-variable>g0</span> = <span class="hljs-title function_ invoke__">redc31</span>(g0);
<span class=hljs-keyword>let</span> <span class=hljs-variable>f1</span> = <span class="hljs-title function_ invoke__">redc31</span>(f1);
<span class=hljs-keyword>let</span> <span class=hljs-variable>g1</span> = <span class="hljs-title function_ invoke__">redc31</span>(g1);
(u0, v0) = ((f0 * u0 + g0 * v0) % b0, (f1 * u0 + g1 * v0) % b0);
</code></pre><p>Note that the inner loop is still limited by <eq><math><mn>30</mn></math></eq>, since it not only shifts <eq><math><mi>v</mi></math></eq>, but also subtracts from <eq><math><mi>u</mi></math></eq>, which could cause an overflow with a limit of <eq><math><mn>31</mn></math></eq>.<div class=aside-group><aside><p>Pornin uses a simpler way to pack <eq><math><mrow><msub><mi>f</mi><mi>i</mi></msub><mo separator=true>,</mo></mrow><mrow><msub><mi>g</mi><mi>i</mi></msub></mrow></math></eq> into <eq><math><msub><mi>c</mi><mi>i</mi></msub></math></eq>: by adding <eq><math><mrow><msup><mn>2</mn><mn>31</mn></msup><mo>‚àí</mo></mrow><mrow><mn>1</mn></mrow></math></eq> to <eq><math><msub><mi>f</mi><mi>i</mi></msub></math></eq> and <eq><math><msub><mi>g</mi><mi>i</mi></msub></math></eq>, we can ensure the two parts don‚Äôt interfere with each other‚Äôs bits. But this makes arithmetic slower due to conversions between the biased and non-biased forms.</aside><p>Parsing coefficients from <eq><math><msub><mi>c</mi><mi>i</mi></msub></math></eq> is slightly tricky due to the unusual signed integer format, but not impossibly so:<section><eqn><math style="display:block math;"class=tml-display display=block><mrow><mrow><mtext></mtext><mi>int</mi></mrow><mo form=prefix stretchy=false>(</mo><mi>x</mi><mo form=postfix stretchy=false>)</mo><mo>=</mo><mrow><mo fence=true form=prefix>{</mo><mtable><mtr><mtd style="padding:0.5ex 0em 0.5ex 0em;"class=tml-left><mi>x</mi></mtd><mtd style="padding:0.5ex 0em 0.5ex 1em;"class=tml-left><mrow><mtext>if¬†</mtext><mi>x</mi><mo>‚â§</mo><msup><mn>2</mn><mn>31</mn></msup></mrow></mtd></mtr><mtr><mtd style="padding:0.5ex 0em 0.5ex 0em;"class=tml-left><mrow><mi>x</mi><mo>‚àí</mo><msup><mn>2</mn><mn>32</mn></msup></mrow></mtd><mtd style="padding:0.5ex 0em 0.5ex 1em;"class=tml-left><mrow><mtext>if¬†</mtext><mi>x</mi><mo>></mo><msup><mn>2</mn><mn>31</mn></msup></mrow></mtd></mtr></mtable><mo fence=true form=postfix></mo></mrow></mrow></math></eqn></section><section><eqn><math style="display:block math;"class=tml-display display=block><mrow><mo fence=true form=prefix>{</mo><mtable><mtr><mtd style="padding:0.5ex 0em 0.5ex 0em;"class=tml-left><mrow><msub><mi>f</mi><mi>i</mi></msub><mo>=</mo><mrow><mtext></mtext><mi>int</mi></mrow><mo form=prefix stretchy=false>(</mo><msub><mi>c</mi><mi>i</mi></msub><mo lspace=0.2222em rspace=0.2222em>mod</mo><msup><mn>2</mn><mn>32</mn></msup><mo form=postfix stretchy=false>)</mo></mrow></mtd></mtr><mtr><mtd style="padding:0.5ex 0em 0.5ex 0em;"class=tml-left><mrow><msub><mi>g</mi><mi>i</mi></msub><mo>=</mo><mrow><mtext></mtext><mi>int</mi></mrow><mrow><mo fence=true form=prefix>(</mo><mrow><mo fence=true form=prefix>‚åä</mo><mstyle displaystyle=true scriptlevel=0><mfrac><mrow><msub><mi>c</mi><mi>i</mi></msub><mo>+</mo><msup><mn>2</mn><mn>31</mn></msup><mo>‚àí</mo><mn>1</mn></mrow><msup><mn>2</mn><mn>32</mn></msup></mfrac></mstyle><mo fence=true form=postfix>‚åã</mo></mrow><mo fence=true form=postfix>)</mo></mrow></mrow></mtd></mtr></mtable><mo fence=true form=postfix></mo></mrow></math></eqn></section><p>This assumes that <eq><math><msub><mi>c</mi><mi>i</mi></msub></math></eq> is stored in an unsigned type.</div><p class=next-group><span aria-level=3 class=side-header role=heading><span>Symmetry</span></span>With packed coefficients, the inner loop is similar to the unoptimized version, differing only in <eq><math><mrow><msub><mi>c</mi><mn>0</mn></msub><mo separator=true>,</mo></mrow><mrow><msub><mi>c</mi><mn>1</mn></msub></mrow></math></eq> vs <eq><math><mrow><mi>u</mi><mo separator=true>,</mo></mrow><mrow><mi>v</mi></mrow></math></eq>. This allows us to cheaply combine two approaches: track the true values <eq><math><mrow><mi>u</mi><mo separator=true>,</mo></mrow><mrow><mi>v</mi></mrow></math></eq> for the first <eq><math><mn>62</mn></math></eq> iterations and then switch to coefficients. It‚Äôs faster than relying on coefficients alone because it recalculates <eq><math><mrow><msub><mi>u</mi><mn>0</mn></msub><mo separator=true>,</mo></mrow><mrow><msub><mi>v</mi><mn>0</mn></msub></mrow></math></eq> less often.<p>The final implementation looks something like this:<pre><code class=language-rust><div class=expansible-code><input id=expansible2 type=checkbox><div class=highlighted><span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>u0</span> = <span class=hljs-number>1</span>;
<span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>v0</span> = <span class=hljs-number>0</span>;
<span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>q</span> = a.<span class="hljs-title function_ invoke__">trailing_zeros</span>();
<span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>is_first_iteration</span> = <span class=hljs-literal>true</span>;

<span class=hljs-keyword>while</span> a != <span class=hljs-number>0</span> {
    <span class=hljs-comment>// Either coefficients in SWAR format, or the values u/v, depending on the iteration.</span>
    <span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>c0</span> = <span class=hljs-number>1</span>;
    <span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>c1</span> = <span class=hljs-keyword>if</span> is_first_iteration { <span class=hljs-number>0</span> } <span class=hljs-keyword>else</span> { <span class=hljs-number>1</span> << <span class=hljs-number>32</span> };
    <span class=hljs-keyword>let</span> <span class=hljs-keyword>mut </span><span class=hljs-variable>p_left</span> = <span class=hljs-keyword>if</span> is_first_iteration { <span class=hljs-number>63</span> } <span class=hljs-keyword>else</span> { <span class=hljs-number>31</span> };

    <span class=hljs-keyword>while</span> a != <span class=hljs-number>0</span> && q < p_left { <span class=hljs-comment>// < instead of <= is load-bearing</span>
        a >>= q;
        c1 <<= q;
        p_left -= q;

        q = (a - b).<span class="hljs-title function_ invoke__">trailing_zeros</span>();

        <span class=hljs-keyword>if</span> a < b {
            (a, b) = (b - a, a);
            (c0, c1) = (c1, c0);
        } <span class=hljs-keyword>else</span> {
            (a, b) = (a - b, b);
        }
        c0 -= c1;
    }

    a >>= p_left;
    c1 <<= p_left;
    q -= p_left;

    <span class=hljs-keyword>if</span> is_first_iteration {
        u0 = <span class="hljs-title function_ invoke__">redc63</span>(c0);
        v0 = <span class="hljs-title function_ invoke__">redc63</span>(c1);
    } <span class=hljs-keyword>else</span> {
        <span class=hljs-keyword>let</span> (f0, g0) = <span class="hljs-title function_ invoke__">parse_coefficient</span>(c0);
        <span class=hljs-keyword>let</span> (f1, g1) = <span class="hljs-title function_ invoke__">parse_coefficient</span>(c1);
        <span class=hljs-keyword>let</span> <span class=hljs-variable>f0</span> = <span class="hljs-title function_ invoke__">redc31</span>(f0);
        <span class=hljs-keyword>let</span> <span class=hljs-variable>g0</span> = <span class="hljs-title function_ invoke__">redc31</span>(g0);
        <span class=hljs-keyword>let</span> <span class=hljs-variable>f1</span> = <span class="hljs-title function_ invoke__">redc31</span>(f1);
        <span class=hljs-keyword>let</span> <span class=hljs-variable>g1</span> = <span class="hljs-title function_ invoke__">redc31</span>(g1);
        (u0, v0) = ((f0 * u0 + g0 * v0) % m, (f1 * u0 + g1 * v0) % m);
    }

    is_first_iteration = <span class=hljs-literal>false</span>;
}

<span class=hljs-built_in>assert!</span>(b == <span class=hljs-number>1</span>, <span class=hljs-string>"not invertible"</span>);
<span class=hljs-keyword>return</span> v0;
</div><label for=expansible2>Expand</label></div></code></pre><p>We store <code>p_left</code> instead of <code>p</code> so that <code>p_left -= q</code> and <code>q < p_left</code> can be computed with a single instruction.<p>The <eq><math><mn>32</mn></math></eq>-bit and <eq><math><mn>64</mn></math></eq>-bit cases can use the same implementation, as replacing <code>q < p_left</code> with <code>true</code> makes this code identical to the <eq><math><mn>32</mn></math></eq>-bit algorithm, and compilers recognize this.<p><code>redc31(x)</code> can be implemented as <code>redc63(x << 32)</code>.<p>And that‚Äôs it! You now know a cool way to compute <eq><math><mn>64</mn></math></eq>-bit modular inverses.<p class=next-group><span aria-level=3 class=side-header role=heading><span>General case</span></span>To support variable <eq><math><msub><mi>b</mi><mn>0</mn></msub></math></eq>, we can compute <eq><math><mrow><mi>j</mi><mo>=</mo></mrow><mrow><msubsup><mi>b</mi><mn>0</mn><mrow><mo form=prefix lspace=0em rspace=0em stretchy=false>‚àí</mo><mn>1</mn></mrow></msubsup><mo lspace=0.2222em rspace=0.2222em>mod</mo></mrow><mrow><msup><mn>2</mn><mn>64</mn></msup></mrow></math></eq> in runtime. This can be done very quickly with <a href=https://arxiv.org/pdf/2204.04342>an algorithm by Jeffrey Hurchalla</a>.<p><eq><math><mi>j</mi></math></eq> only exists if <eq><math><msub><mi>b</mi><mn>0</mn></msub></math></eq> is odd. If it‚Äôs even, swap <eq><math><msub><mi>a</mi><mn>0</mn></msub></math></eq> and <eq><math><msub><mi>b</mi><mn>0</mn></msub></math></eq>. If both are even, divide them by their common power of two and choose whichever becomes odd as <eq><math><msub><mi>b</mi><mn>0</mn></msub></math></eq>.<p>To replace the extended Euclidean algorithm, we need to find <em>integers</em> <eq><math><mrow><mi>x</mi><mo separator=true>,</mo></mrow><mrow><mi>y</mi></mrow></math></eq> such that:<section><eqn><math style="display:block math;"class=tml-display display=block><mrow><msub><mi>a</mi><mn>0</mn></msub><mi>x</mi><mo>+</mo><msub><mi>b</mi><mn>0</mn></msub><mi>y</mi><mo>=</mo><mrow><mtext></mtext><mi>gcd</mi></mrow><mo form=prefix stretchy=false>(</mo><msub><mi>a</mi><mn>0</mn></msub><mo separator=true>,</mo><msub><mi>b</mi><mn>0</mn></msub><mo form=postfix stretchy=false>)</mo></mrow></math></eqn></section><p>Luckily, our <eq><math><mi>v</mi></math></eq> is no longer a fraction, but rather a remainder modulo <eq><math><msub><mi>b</mi><mn>0</mn></msub></math></eq>, so we can substitute <eq><math><mrow><mi>x</mi><mo>=</mo></mrow><mrow><mi>v</mi></mrow></math></eq>. <eq><math><mi>y</mi></math></eq> can then be computed from the equation:<section><eqn><math style="display:block math;"class=tml-display display=block><mrow><mi>y</mi><mo>=</mo><mfrac><mrow><mrow><mtext></mtext><mi>gcd</mi></mrow><mo form=prefix stretchy=false>(</mo><msub><mi>a</mi><mn>0</mn></msub><mo separator=true>,</mo><msub><mi>b</mi><mn>0</mn></msub><mo form=postfix stretchy=false>)</mo><mo>‚àí</mo><msub><mi>a</mi><mn>0</mn></msub><mi>x</mi></mrow><msub><mi>b</mi><mn>0</mn></msub></mfrac><mo>=</mo><mfrac><mrow><mi>b</mi><mo>‚àí</mo><msub><mi>a</mi><mn>0</mn></msub><mi>x</mi></mrow><msub><mi>b</mi><mn>0</mn></msub></mfrac></mrow></math></eqn></section><p>Since this division is exact, it can be calculated with multiplication by <eq><math><mi>j</mi></math></eq>:<section><eqn><math style="display:block math;"class=tml-display display=block><mrow><mi>y</mi><mo>=</mo><mi>j</mi><mo>‚ãÖ</mo><mo form=prefix stretchy=false>(</mo><mi>b</mi><mo>‚àí</mo><msub><mi>a</mi><mn>0</mn></msub><mi>x</mi><mo form=postfix stretchy=false>)</mo><mo></mo><mspace width=1em></mspace><mo form=prefix stretchy=false>(</mo><mrow><mtext></mtext><mi>mod</mi></mrow><mspace width=0.3333em></mspace><msup><mn>2</mn><mn>64</mn></msup><mo form=postfix stretchy=false>)</mo></mrow></math></eqn></section><p>Despite this complexity, I believe this method can be faster than the extended Euclidean algorithm. The auxiliary logic takes constant time, except for computing <eq><math><mi>h</mi></math></eq> in <eq><math><mrow><mi class=mathcal>ùí™</mi><mo form=prefix stretchy=false>(</mo><mrow><mi>log</mi><mo>‚Å°</mo><mspace width=0.1667em></mspace></mrow><mi>k</mi><mo form=postfix stretchy=false>)</mo><mo>=</mo></mrow><mrow><mi class=mathcal>ùí™</mi><mo form=prefix stretchy=false>(</mo><mrow><mi>log</mi><mo>‚Å°</mo><mspace width=0.1667em></mspace></mrow><mrow><mi>log</mi><mo>‚Å°</mo><mspace width=0.1667em></mspace></mrow><mi>a</mi><mo form=postfix stretchy=false>)</mo></mrow></math></eq>, which is still pretty good.<p class=next-group><span aria-level=3 class=side-header role=heading><span>Outro</span></span>As a reminder, you can find my code <a href=https://github.com/purplesyringa/mod2k/blob/104603af3866ac274073a5b2af28f7a41550add1/src/xgcd.rs>on GitHub</a>. The source of latency-optimized GCD is <a href=https://lemire.me/blog/2024/04/13/greatest-common-divisor-the-extended-euclidean-algorithm-and-speed/>this post</a>. Using coefficients to reset bit lengths of <eq><math><mrow><mi>u</mi><mo separator=true>,</mo></mrow><mrow><mi>v</mi></mrow></math></eq> comes from <a href=https://eprint.iacr.org/2020/972.pdf>this paper</a>, which also covers the case when values don‚Äôt fit in general-purpose registers.</div></section><footer><div class=viewport-container><h2>Made with my own bare hands (why.)</h2></div></footer><script>window.addEventListener("keydown", e => {
				if (e.key === "Enter") {
					if (e.ctrlKey) {
						window.open("https://github.com/purplesyringa/site/edit/master/blog/faster-practical-modular-inversion/index.md", "_blank");
					} else if (
						e.target.type === "checkbox"
						&& e.target.parentNode
						&& e.target.parentNode.className === "expansible-code"
					) {
						e.target.click();
					}
				}
			});</script>